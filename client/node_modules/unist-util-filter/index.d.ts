/**
 * Create a new tree consisting of copies of all nodes that pass test.
 * The tree is walked in preorder (NLR), visiting the node itself, then its head, etc.
 *
 * @param tree Tree to filter.
 * @param options Configuration (optional).
 * @param test is-compatible test (such as a type).
 * @returns Given `tree` or `null` if it didnâ€™t pass `test`.
 */
export const filter: (<
  Tree extends import('unist').Node<import('unist').Data>,
  Check extends import('unist-util-is').Test
>(
  node: Tree,
  options: FilterOptions,
  test: Check
) => import('./complex-types').Matches<Tree, Check>) &
  (<
    Tree_1 extends import('unist').Node<import('unist').Data>,
    Check_1 extends import('unist-util-is').Test
  >(
    node: Tree_1,
    test: Check_1
  ) => import('./complex-types').Matches<Tree_1, Check_1>) &
  (<Tree_2 extends import('unist').Node<import('unist').Data>>(
    node: Tree_2,
    options?: FilterOptions | undefined
  ) => Tree_2)
export type Node = import('unist').Node
export type Parent = import('unist').Parent
export type Test = import('unist-util-is').Test
/**
 * Options for unist util filter
 */
export type FilterOptions = {
  /**
   * Whether to drop parent nodes if they had children, but all their children were filtered out.
   */
  cascade?: boolean | undefined
}
