{
  "version": 3,
  "names": [
    "selectWord",
    "text",
    "selection",
    "length",
    "start",
    "end",
    "getSurroundingWord",
    "getBreaksNeededForEmptyLineBefore",
    "startPosition",
    "neededBreaks",
    "isInFirstLine",
    "i",
    "charCodeAt",
    "getBreaksNeededForEmptyLineAfter",
    "isInLastLine",
    "position",
    "Error",
    "isWordDelimiter",
    "c"
  ],
  "sources": [
    "../../src/utils/markdownUtils.ts"
  ],
  "sourcesContent": [
    "import { TextRange } from '../commands';\n\nexport interface TextSection {\n  text: string;\n  selection: TextRange;\n}\n\nexport function selectWord({ text, selection }: TextSection): TextRange {\n  if (text && text.length && selection.start === selection.end) {\n    // the user is pointing to a word\n    return getSurroundingWord(text, selection.start);\n  }\n  return selection;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\nexport function getBreaksNeededForEmptyLineBefore(text = '', startPosition: number): number {\n  if (startPosition === 0) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  let neededBreaks = 2;\n  let isInFirstLine = true;\n  for (let i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\n    switch (text.charCodeAt(i)) {\n      case 32: // blank space\n        continue;\n      case 10: // line break\n        neededBreaks--;\n        isInFirstLine = false;\n        break;\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInFirstLine ? 0 : neededBreaks;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\nexport function getBreaksNeededForEmptyLineAfter(text = '', startPosition: number): number {\n  if (startPosition === text.length - 1) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  let neededBreaks = 2;\n  let isInLastLine = true;\n  for (let i = startPosition; i < text.length && neededBreaks >= 0; i++) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        continue;\n      case 10: {\n        neededBreaks--;\n        isInLastLine = false;\n        break;\n      }\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInLastLine ? 0 : neededBreaks;\n}\n\nexport function getSurroundingWord(text: string, position: number): TextRange {\n  if (!text) throw Error(\"Argument 'text' should be truthy\");\n\n  const isWordDelimiter = (c: string) => c === ' ' || c.charCodeAt(0) === 10;\n\n  // leftIndex is initialized to 0 because if selection is 0, it won't even enter the iteration\n  let start = 0;\n  // rightIndex is initialized to text.length because if selection is equal to text.length it won't even enter the interation\n  let end = text.length;\n\n  // iterate to the left\n  for (let i = position; i - 1 > -1; i--) {\n    if (isWordDelimiter(text[i - 1])) {\n      start = i;\n      break;\n    }\n  }\n\n  // iterate to the right\n  for (let i = position; i < text.length; i++) {\n    if (isWordDelimiter(text[i])) {\n      end = i;\n      break;\n    }\n  }\n\n  return { start, end };\n}\n"
  ],
  "mappings": "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"
}