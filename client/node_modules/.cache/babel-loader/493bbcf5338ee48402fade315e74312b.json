{"ast":null,"code":"import { NodeType, NodeProp, NodeSet, Tree, Parser, parseMixed } from '@lezer/common';\nimport { styleTags, tags, Tag } from '@lezer/highlight';\n\nclass CompositeBlock {\n  constructor(type, // Used for indentation in list items, markup character in lists\n  value, from, hash, end, children, positions) {\n    this.type = type;\n    this.value = value;\n    this.from = from;\n    this.hash = hash;\n    this.end = end;\n    this.children = children;\n    this.positions = positions;\n    this.hashProp = [[NodeProp.contextHash, hash]];\n  }\n\n  static create(type, value, from, parentHash, end) {\n    let hash = parentHash + (parentHash << 8) + type + (value << 4) | 0;\n    return new CompositeBlock(type, value, from, hash, end, [], []);\n  }\n\n  addChild(child, pos) {\n    if (child.prop(NodeProp.contextHash) != this.hash) child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);\n    this.children.push(child);\n    this.positions.push(pos);\n  }\n\n  toTree(nodeSet) {\n    let end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.end;\n    let last = this.children.length - 1;\n    if (last >= 0) end = Math.max(end, this.positions[last] + this.children[last].length + this.from);\n    let tree = new Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({\n      makeTree: (children, positions, length) => new Tree(NodeType.none, children, positions, length, this.hashProp)\n    });\n    return tree;\n  }\n\n}\n\nvar Type;\n\n(function (Type) {\n  Type[Type[\"Document\"] = 1] = \"Document\";\n  Type[Type[\"CodeBlock\"] = 2] = \"CodeBlock\";\n  Type[Type[\"FencedCode\"] = 3] = \"FencedCode\";\n  Type[Type[\"Blockquote\"] = 4] = \"Blockquote\";\n  Type[Type[\"HorizontalRule\"] = 5] = \"HorizontalRule\";\n  Type[Type[\"BulletList\"] = 6] = \"BulletList\";\n  Type[Type[\"OrderedList\"] = 7] = \"OrderedList\";\n  Type[Type[\"ListItem\"] = 8] = \"ListItem\";\n  Type[Type[\"ATXHeading1\"] = 9] = \"ATXHeading1\";\n  Type[Type[\"ATXHeading2\"] = 10] = \"ATXHeading2\";\n  Type[Type[\"ATXHeading3\"] = 11] = \"ATXHeading3\";\n  Type[Type[\"ATXHeading4\"] = 12] = \"ATXHeading4\";\n  Type[Type[\"ATXHeading5\"] = 13] = \"ATXHeading5\";\n  Type[Type[\"ATXHeading6\"] = 14] = \"ATXHeading6\";\n  Type[Type[\"SetextHeading1\"] = 15] = \"SetextHeading1\";\n  Type[Type[\"SetextHeading2\"] = 16] = \"SetextHeading2\";\n  Type[Type[\"HTMLBlock\"] = 17] = \"HTMLBlock\";\n  Type[Type[\"LinkReference\"] = 18] = \"LinkReference\";\n  Type[Type[\"Paragraph\"] = 19] = \"Paragraph\";\n  Type[Type[\"CommentBlock\"] = 20] = \"CommentBlock\";\n  Type[Type[\"ProcessingInstructionBlock\"] = 21] = \"ProcessingInstructionBlock\"; // Inline\n\n  Type[Type[\"Escape\"] = 22] = \"Escape\";\n  Type[Type[\"Entity\"] = 23] = \"Entity\";\n  Type[Type[\"HardBreak\"] = 24] = \"HardBreak\";\n  Type[Type[\"Emphasis\"] = 25] = \"Emphasis\";\n  Type[Type[\"StrongEmphasis\"] = 26] = \"StrongEmphasis\";\n  Type[Type[\"Link\"] = 27] = \"Link\";\n  Type[Type[\"Image\"] = 28] = \"Image\";\n  Type[Type[\"InlineCode\"] = 29] = \"InlineCode\";\n  Type[Type[\"HTMLTag\"] = 30] = \"HTMLTag\";\n  Type[Type[\"Comment\"] = 31] = \"Comment\";\n  Type[Type[\"ProcessingInstruction\"] = 32] = \"ProcessingInstruction\";\n  Type[Type[\"URL\"] = 33] = \"URL\"; // Smaller tokens\n\n  Type[Type[\"HeaderMark\"] = 34] = \"HeaderMark\";\n  Type[Type[\"QuoteMark\"] = 35] = \"QuoteMark\";\n  Type[Type[\"ListMark\"] = 36] = \"ListMark\";\n  Type[Type[\"LinkMark\"] = 37] = \"LinkMark\";\n  Type[Type[\"EmphasisMark\"] = 38] = \"EmphasisMark\";\n  Type[Type[\"CodeMark\"] = 39] = \"CodeMark\";\n  Type[Type[\"CodeText\"] = 40] = \"CodeText\";\n  Type[Type[\"CodeInfo\"] = 41] = \"CodeInfo\";\n  Type[Type[\"LinkTitle\"] = 42] = \"LinkTitle\";\n  Type[Type[\"LinkLabel\"] = 43] = \"LinkLabel\";\n})(Type || (Type = {})); /// Data structure used to accumulate a block's content during [leaf\n/// block parsing](#BlockParser.leaf).\n\n\nclass LeafBlock {\n  /// @internal\n  constructor( /// The start position of the block.\n  start, /// The block's text content.\n  content) {\n    this.start = start;\n    this.content = content; /// @internal\n\n    this.marks = []; /// The block parsers active for this block.\n\n    this.parsers = [];\n  }\n\n} /// Data structure used during block-level per-line parsing.\n\n\nclass Line {\n  constructor() {\n    /// The line's full text.\n    this.text = \"\"; /// The base indent provided by the composite contexts (that have\n    /// been handled so far).\n\n    this.baseIndent = 0; /// The string position corresponding to the base indent.\n\n    this.basePos = 0; /// The number of contexts handled @internal\n\n    this.depth = 0; /// Any markers (i.e. block quote markers) parsed for the contexts. @internal\n\n    this.markers = []; /// The position of the next non-whitespace character beyond any\n    /// list, blockquote, or other composite block markers.\n\n    this.pos = 0; /// The column of the next non-whitespace character.\n\n    this.indent = 0; /// The character code of the character after `pos`.\n\n    this.next = -1;\n  } /// @internal\n\n\n  forward() {\n    if (this.basePos > this.pos) this.forwardInner();\n  } /// @internal\n\n\n  forwardInner() {\n    let newPos = this.skipSpace(this.basePos);\n    this.indent = this.countIndent(newPos, this.pos, this.indent);\n    this.pos = newPos;\n    this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);\n  } /// Skip whitespace after the given position, return the position of\n  /// the next non-space character or the end of the line if there's\n  /// only space after `from`.\n\n\n  skipSpace(from) {\n    return skipSpace(this.text, from);\n  } /// @internal\n\n\n  reset(text) {\n    this.text = text;\n    this.baseIndent = this.basePos = this.pos = this.indent = 0;\n    this.forwardInner();\n    this.depth = 1;\n\n    while (this.markers.length) this.markers.pop();\n  } /// Move the line's base position forward to the given position.\n  /// This should only be called by composite [block\n  /// parsers](#BlockParser.parse) or [markup skipping\n  /// functions](#NodeSpec.composite).\n\n\n  moveBase(to) {\n    this.basePos = to;\n    this.baseIndent = this.countIndent(to, this.pos, this.indent);\n  } /// Move the line's base position forward to the given _column_.\n\n\n  moveBaseColumn(indent) {\n    this.baseIndent = indent;\n    this.basePos = this.findColumn(indent);\n  } /// Store a composite-block-level marker. Should be called from\n  /// [markup skipping functions](#NodeSpec.composite) when they\n  /// consume any non-whitespace characters.\n\n\n  addMarker(elt) {\n    this.markers.push(elt);\n  } /// Find the column position at `to`, optionally starting at a given\n  /// position and column.\n\n\n  countIndent(to) {\n    let from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let indent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    for (let i = from; i < to; i++) indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n\n    return indent;\n  } /// Find the position corresponding to the given column.\n\n\n  findColumn(goal) {\n    let i = 0;\n\n    for (let indent = 0; i < this.text.length && indent < goal; i++) indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n\n    return i;\n  } /// @internal\n\n\n  scrub() {\n    if (!this.baseIndent) return this.text;\n    let result = \"\";\n\n    for (let i = 0; i < this.basePos; i++) result += \" \";\n\n    return result + this.text.slice(this.basePos);\n  }\n\n}\n\nfunction skipForList(bl, cx, line) {\n  if (line.pos == line.text.length || bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent) return true;\n  if (line.indent >= line.baseIndent + 4) return false;\n  let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);\n  return size > 0 && (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) && line.text.charCodeAt(line.pos + size - 1) == bl.value;\n}\n\nconst DefaultSkipMarkup = {\n  [Type.Blockquote](bl, cx, line) {\n    if (line.next != 62\n    /* '>' */\n    ) return false;\n    line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));\n    line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));\n    bl.end = cx.lineStart + line.text.length;\n    return true;\n  },\n\n  [Type.ListItem](bl, _cx, line) {\n    if (line.indent < line.baseIndent + bl.value && line.next > -1) return false;\n    line.moveBaseColumn(line.baseIndent + bl.value);\n    return true;\n  },\n\n  [Type.OrderedList]: skipForList,\n  [Type.BulletList]: skipForList,\n\n  [Type.Document]() {\n    return true;\n  }\n\n};\n\nfunction space(ch) {\n  return ch == 32 || ch == 9 || ch == 10 || ch == 13;\n}\n\nfunction skipSpace(line) {\n  let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  while (i < line.length && space(line.charCodeAt(i))) i++;\n\n  return i;\n}\n\nfunction skipSpaceBack(line, i, to) {\n  while (i > to && space(line.charCodeAt(i - 1))) i--;\n\n  return i;\n}\n\nfunction isFencedCode(line) {\n  if (line.next != 96 && line.next != 126\n  /* '`~' */\n  ) return -1;\n  let pos = line.pos + 1;\n\n  while (pos < line.text.length && line.text.charCodeAt(pos) == line.next) pos++;\n\n  if (pos < line.pos + 3) return -1;\n  if (line.next == 96) for (let i = pos; i < line.text.length; i++) if (line.text.charCodeAt(i) == 96) return -1;\n  return pos;\n}\n\nfunction isBlockquote(line) {\n  return line.next != 62\n  /* '>' */\n  ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;\n}\n\nfunction isHorizontalRule(line, cx, breaking) {\n  if (line.next != 42 && line.next != 45 && line.next != 95\n  /* '_-*' */\n  ) return -1;\n  let count = 1;\n\n  for (let pos = line.pos + 1; pos < line.text.length; pos++) {\n    let ch = line.text.charCodeAt(pos);\n    if (ch == line.next) count++;else if (!space(ch)) return -1;\n  } // Setext headers take precedence\n\n\n  if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length) return -1;\n  return count < 3 ? -1 : 1;\n}\n\nfunction inList(cx, type) {\n  for (let i = cx.stack.length - 1; i >= 0; i--) if (cx.stack[i].type == type) return true;\n\n  return false;\n}\n\nfunction isBulletList(line, cx, breaking) {\n  return (line.next == 45 || line.next == 43 || line.next == 42\n  /* '-+*' */\n  ) && (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) && (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;\n}\n\nfunction isOrderedList(line, cx, breaking) {\n  let pos = line.pos,\n      next = line.next;\n\n  for (;;) {\n    if (next >= 48 && next <= 57\n    /* '0-9' */\n    ) pos++;else break;\n    if (pos == line.text.length) return -1;\n    next = line.text.charCodeAt(pos);\n  }\n\n  if (pos == line.pos || pos > line.pos + 9 || next != 46 && next != 41\n  /* '.)' */\n  || pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1)) || breaking && !inList(cx, Type.OrderedList) && (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49\n  /* '1' */\n  )) return -1;\n  return pos + 1 - line.pos;\n}\n\nfunction isAtxHeading(line) {\n  if (line.next != 35\n  /* '#' */\n  ) return -1;\n  let pos = line.pos + 1;\n\n  while (pos < line.text.length && line.text.charCodeAt(pos) == 35) pos++;\n\n  if (pos < line.text.length && line.text.charCodeAt(pos) != 32) return -1;\n  let size = pos - line.pos;\n  return size > 6 ? -1 : size;\n}\n\nfunction isSetextUnderline(line) {\n  if (line.next != 45 && line.next != 61\n  /* '-=' */\n  || line.indent >= line.baseIndent + 4) return -1;\n  let pos = line.pos + 1;\n\n  while (pos < line.text.length && line.text.charCodeAt(pos) == line.next) pos++;\n\n  let end = pos;\n\n  while (pos < line.text.length && space(line.text.charCodeAt(pos))) pos++;\n\n  return pos == line.text.length ? end : -1;\n}\n\nconst EmptyLine = /^[ \\t]*$/,\n      CommentEnd = /-->/,\n      ProcessingEnd = /\\?>/;\nconst HTMLBlockStyle = [[/^<(?:script|pre|style)(?:\\s|>|$)/i, /<\\/(?:script|pre|style)>/i], [/^\\s*<!--/, CommentEnd], [/^\\s*<\\?/, ProcessingEnd], [/^\\s*<![A-Z]/, />/], [/^\\s*<!\\[CDATA\\[/, /\\]\\]>/], [/^\\s*<\\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|\\/?>|$)/i, EmptyLine], [/^\\s*(?:<\\/[a-z][\\w-]*\\s*>|<[a-z][\\w-]*(\\s+[a-z:_][\\w-.]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*>)\\s*$/i, EmptyLine]];\n\nfunction isHTMLBlock(line, _cx, breaking) {\n  if (line.next != 60\n  /* '<' */\n  ) return -1;\n  let rest = line.text.slice(line.pos);\n\n  for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++) if (HTMLBlockStyle[i][0].test(rest)) return i;\n\n  return -1;\n}\n\nfunction getListIndent(line, pos) {\n  let indentAfter = line.countIndent(pos, line.pos, line.indent);\n  let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);\n  return indented >= indentAfter + 5 ? indentAfter + 1 : indented;\n}\n\nfunction addCodeText(marks, from, to) {\n  let last = marks.length - 1;\n  if (last >= 0 && marks[last].to == from && marks[last].type == Type.CodeText) marks[last].to = to;else marks.push(elt(Type.CodeText, from, to));\n} // Rules for parsing blocks. A return value of false means the rule\n// doesn't apply here, true means it does. When true is returned and\n// `p.line` has been updated, the rule is assumed to have consumed a\n// leaf block. Otherwise, it is assumed to have opened a context.\n\n\nconst DefaultBlockParsers = {\n  LinkReference: undefined,\n\n  IndentedCode(cx, line) {\n    let base = line.baseIndent + 4;\n    if (line.indent < base) return false;\n    let start = line.findColumn(base);\n    let from = cx.lineStart + start,\n        to = cx.lineStart + line.text.length;\n    let marks = [],\n        pendingMarks = [];\n    addCodeText(marks, from, to);\n\n    while (cx.nextLine() && line.depth >= cx.stack.length) {\n      if (line.pos == line.text.length) {\n        // Empty\n        addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);\n\n        for (let m of line.markers) pendingMarks.push(m);\n      } else if (line.indent < base) {\n        break;\n      } else {\n        if (pendingMarks.length) {\n          for (let m of pendingMarks) {\n            if (m.type == Type.CodeText) addCodeText(marks, m.from, m.to);else marks.push(m);\n          }\n\n          pendingMarks = [];\n        }\n\n        addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n\n        for (let m of line.markers) marks.push(m);\n\n        to = cx.lineStart + line.text.length;\n        let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);\n        if (codeStart < to) addCodeText(marks, codeStart, to);\n      }\n    }\n\n    if (pendingMarks.length) {\n      pendingMarks = pendingMarks.filter(m => m.type != Type.CodeText);\n      if (pendingMarks.length) line.markers = pendingMarks.concat(line.markers);\n    }\n\n    cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);\n    return true;\n  },\n\n  FencedCode(cx, line) {\n    let fenceEnd = isFencedCode(line);\n    if (fenceEnd < 0) return false;\n    let from = cx.lineStart + line.pos,\n        ch = line.next,\n        len = fenceEnd - line.pos;\n    let infoFrom = line.skipSpace(fenceEnd),\n        infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);\n    let marks = [elt(Type.CodeMark, from, from + len)];\n    if (infoFrom < infoTo) marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));\n\n    for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {\n      let i = line.pos;\n      if (line.indent - line.baseIndent < 4) while (i < line.text.length && line.text.charCodeAt(i) == ch) i++;\n\n      if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {\n        for (let m of line.markers) marks.push(m);\n\n        marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));\n        cx.nextLine();\n        break;\n      } else {\n        if (!first) addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n\n        for (let m of line.markers) marks.push(m);\n\n        let textStart = cx.lineStart + line.basePos,\n            textEnd = cx.lineStart + line.text.length;\n        if (textStart < textEnd) addCodeText(marks, textStart, textEnd);\n      }\n    }\n\n    cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.FencedCode, cx.prevLineEnd() - from), from);\n    return true;\n  },\n\n  Blockquote(cx, line) {\n    let size = isBlockquote(line);\n    if (size < 0) return false;\n    cx.startContext(Type.Blockquote, line.pos);\n    cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);\n    line.moveBase(line.pos + size);\n    return null;\n  },\n\n  HorizontalRule(cx, line) {\n    if (isHorizontalRule(line, cx, false) < 0) return false;\n    let from = cx.lineStart + line.pos;\n    cx.nextLine();\n    cx.addNode(Type.HorizontalRule, from);\n    return true;\n  },\n\n  BulletList(cx, line) {\n    let size = isBulletList(line, cx, false);\n    if (size < 0) return false;\n    if (cx.block.type != Type.BulletList) cx.startContext(Type.BulletList, line.basePos, line.next);\n    let newBase = getListIndent(line, line.pos + 1);\n    cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n    cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n    line.moveBaseColumn(newBase);\n    return null;\n  },\n\n  OrderedList(cx, line) {\n    let size = isOrderedList(line, cx, false);\n    if (size < 0) return false;\n    if (cx.block.type != Type.OrderedList) cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));\n    let newBase = getListIndent(line, line.pos + size);\n    cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n    cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n    line.moveBaseColumn(newBase);\n    return null;\n  },\n\n  ATXHeading(cx, line) {\n    let size = isAtxHeading(line);\n    if (size < 0) return false;\n    let off = line.pos,\n        from = cx.lineStart + off;\n    let endOfSpace = skipSpaceBack(line.text, line.text.length, off),\n        after = endOfSpace;\n\n    while (after > off && line.text.charCodeAt(after - 1) == line.next) after--;\n\n    if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1))) after = line.text.length;\n    let buf = cx.buffer.write(Type.HeaderMark, 0, size).writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);\n    if (after < line.text.length) buf.write(Type.HeaderMark, after - off, endOfSpace - off);\n    let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);\n    cx.nextLine();\n    cx.addNode(node, from);\n    return true;\n  },\n\n  HTMLBlock(cx, line) {\n    let type = isHTMLBlock(line, cx, false);\n    if (type < 0) return false;\n    let from = cx.lineStart + line.pos,\n        end = HTMLBlockStyle[type][1];\n    let marks = [],\n        trailing = end != EmptyLine;\n\n    while (!end.test(line.text) && cx.nextLine()) {\n      if (line.depth < cx.stack.length) {\n        trailing = false;\n        break;\n      }\n\n      for (let m of line.markers) marks.push(m);\n    }\n\n    if (trailing) cx.nextLine();\n    let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;\n    let to = cx.prevLineEnd();\n    cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);\n    return true;\n  },\n\n  SetextHeading: undefined // Specifies relative precedence for block-continue function\n\n}; // This implements a state machine that incrementally parses link references. At each\n// next line, it looks ahead to see if the line continues the reference or not. If it\n// doesn't and a valid link is available ending before that line, it finishes that.\n// Similarly, on `finish` (when the leaf is terminated by external circumstances), it\n// creates a link reference if there's a valid reference up to the current point.\n\nclass LinkReferenceParser {\n  constructor(leaf) {\n    this.stage = 0\n    /* Start */\n    ;\n    this.elts = [];\n    this.pos = 0;\n    this.start = leaf.start;\n    this.advance(leaf.content);\n  }\n\n  nextLine(cx, line, leaf) {\n    if (this.stage == -1\n    /* Failed */\n    ) return false;\n    let content = leaf.content + \"\\n\" + line.scrub();\n    let finish = this.advance(content);\n    if (finish > -1 && finish < content.length) return this.complete(cx, leaf, finish);\n    return false;\n  }\n\n  finish(cx, leaf) {\n    if ((this.stage == 2\n    /* Link */\n    || this.stage == 3\n    /* Title */\n    ) && skipSpace(leaf.content, this.pos) == leaf.content.length) return this.complete(cx, leaf, leaf.content.length);\n    return false;\n  }\n\n  complete(cx, leaf, len) {\n    cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));\n    return true;\n  }\n\n  nextStage(elt) {\n    if (elt) {\n      this.pos = elt.to - this.start;\n      this.elts.push(elt);\n      this.stage++;\n      return true;\n    }\n\n    if (elt === false) this.stage = -1\n    /* Failed */\n    ;\n    return false;\n  }\n\n  advance(content) {\n    for (;;) {\n      if (this.stage == -1\n      /* Failed */\n      ) {\n        return -1;\n      } else if (this.stage == 0\n      /* Start */\n      ) {\n        if (!this.nextStage(parseLinkLabel(content, this.pos, this.start, true))) return -1;\n        if (content.charCodeAt(this.pos) != 58\n        /* ':' */\n        ) return this.stage = -1\n        /* Failed */\n        ;\n        this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));\n        this.pos++;\n      } else if (this.stage == 1\n      /* Label */\n      ) {\n        if (!this.nextStage(parseURL(content, skipSpace(content, this.pos), this.start))) return -1;\n      } else if (this.stage == 2\n      /* Link */\n      ) {\n        let skip = skipSpace(content, this.pos),\n            end = 0;\n\n        if (skip > this.pos) {\n          let title = parseLinkTitle(content, skip, this.start);\n\n          if (title) {\n            let titleEnd = lineEnd(content, title.to - this.start);\n\n            if (titleEnd > 0) {\n              this.nextStage(title);\n              end = titleEnd;\n            }\n          }\n        }\n\n        if (!end) end = lineEnd(content, this.pos);\n        return end > 0 && end < content.length ? end : -1;\n      } else {\n        // RefStage.Title\n        return lineEnd(content, this.pos);\n      }\n    }\n  }\n\n}\n\nfunction lineEnd(text, pos) {\n  for (; pos < text.length; pos++) {\n    let next = text.charCodeAt(pos);\n    if (next == 10) break;\n    if (!space(next)) return -1;\n  }\n\n  return pos;\n}\n\nclass SetextHeadingParser {\n  nextLine(cx, line, leaf) {\n    let underline = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);\n    let next = line.next;\n    if (underline < 0) return false;\n    let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline);\n    cx.nextLine();\n    cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [...cx.parser.parseInline(leaf.content, leaf.start), underlineMark]));\n    return true;\n  }\n\n  finish() {\n    return false;\n  }\n\n}\n\nconst DefaultLeafBlocks = {\n  LinkReference(_, leaf) {\n    return leaf.content.charCodeAt(0) == 91\n    /* '[' */\n    ? new LinkReferenceParser(leaf) : null;\n  },\n\n  SetextHeading() {\n    return new SetextHeadingParser();\n  }\n\n};\nconst DefaultEndLeaf = [(_, line) => isAtxHeading(line) >= 0, (_, line) => isFencedCode(line) >= 0, (_, line) => isBlockquote(line) >= 0, (p, line) => isBulletList(line, p, true) >= 0, (p, line) => isOrderedList(line, p, true) >= 0, (p, line) => isHorizontalRule(line, p, true) >= 0, (p, line) => isHTMLBlock(line, p, true) >= 0];\nconst scanLineResult = {\n  text: \"\",\n  end: 0\n}; /// Block-level parsing functions get access to this context object.\n\nclass BlockContext {\n  /// @internal\n  constructor( /// The parser configuration used.\n  parser, /// @internal\n  input, fragments, /// @internal\n  ranges) {\n    this.parser = parser;\n    this.input = input;\n    this.ranges = ranges;\n    this.line = new Line();\n    this.atEnd = false; /// @internal\n\n    this.dontInject = new Set();\n    this.stoppedAt = null; /// The range index that absoluteLineStart points into @internal\n\n    this.rangeI = 0;\n    this.to = ranges[ranges.length - 1].to;\n    this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;\n    this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);\n    this.stack = [this.block];\n    this.fragments = fragments.length ? new FragmentCursor(fragments, input) : null;\n    this.readLine();\n  }\n\n  get parsedPos() {\n    return this.absoluteLineStart;\n  }\n\n  advance() {\n    if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt) return this.finish();\n    let {\n      line\n    } = this;\n\n    for (;;) {\n      while (line.depth < this.stack.length) this.finishContext();\n\n      for (let mark of line.markers) this.addNode(mark.type, mark.from, mark.to);\n\n      if (line.pos < line.text.length) break; // Empty line\n\n      if (!this.nextLine()) return this.finish();\n    }\n\n    if (this.fragments && this.reuseFragment(line.basePos)) return null;\n\n    start: for (;;) {\n      for (let type of this.parser.blockParsers) if (type) {\n        let result = type(this, line);\n\n        if (result != false) {\n          if (result == true) return null;\n          line.forward();\n          continue start;\n        }\n      }\n\n      break;\n    }\n\n    let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));\n\n    for (let parse of this.parser.leafBlockParsers) if (parse) {\n      let parser = parse(this, leaf);\n      if (parser) leaf.parsers.push(parser);\n    }\n\n    lines: while (this.nextLine()) {\n      if (line.pos == line.text.length) break;\n\n      if (line.indent < line.baseIndent + 4) {\n        for (let stop of this.parser.endLeafBlock) if (stop(this, line, leaf)) break lines;\n      }\n\n      for (let parser of leaf.parsers) if (parser.nextLine(this, line, leaf)) return null;\n\n      leaf.content += \"\\n\" + line.scrub();\n\n      for (let m of line.markers) leaf.marks.push(m);\n    }\n\n    this.finishLeaf(leaf);\n    return null;\n  }\n\n  stopAt(pos) {\n    if (this.stoppedAt != null && this.stoppedAt < pos) throw new RangeError(\"Can't move stoppedAt forward\");\n    this.stoppedAt = pos;\n  }\n\n  reuseFragment(start) {\n    if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) || !this.fragments.matches(this.block.hash)) return false;\n    let taken = this.fragments.takeNodes(this);\n    if (!taken) return false;\n    let withoutGaps = taken,\n        end = this.absoluteLineStart + taken;\n\n    for (let i = 1; i < this.ranges.length; i++) {\n      let gapFrom = this.ranges[i - 1].to,\n          gapTo = this.ranges[i].from;\n      if (gapFrom >= this.lineStart && gapTo < end) withoutGaps -= gapTo - gapFrom;\n    }\n\n    this.lineStart += withoutGaps;\n    this.absoluteLineStart += taken;\n    this.moveRangeI();\n\n    if (this.absoluteLineStart < this.to) {\n      this.lineStart++;\n      this.absoluteLineStart++;\n      this.readLine();\n    } else {\n      this.atEnd = true;\n      this.readLine();\n    }\n\n    return true;\n  } /// The number of parent blocks surrounding the current block.\n\n\n  get depth() {\n    return this.stack.length;\n  } /// Get the type of the parent block at the given depth. When no\n  /// depth is passed, return the type of the innermost parent.\n\n\n  parentType() {\n    let depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.depth - 1;\n    return this.parser.nodeSet.types[this.stack[depth].type];\n  } /// Move to the next input line. This should only be called by\n  /// (non-composite) [block parsers](#BlockParser.parse) that consume\n  /// the line directly, or leaf block parser\n  /// [`nextLine`](#LeafBlockParser.nextLine) methods when they\n  /// consume the current line (and return true).\n\n\n  nextLine() {\n    this.lineStart += this.line.text.length;\n\n    if (this.absoluteLineEnd >= this.to) {\n      this.absoluteLineStart = this.absoluteLineEnd;\n      this.atEnd = true;\n      this.readLine();\n      return false;\n    } else {\n      this.lineStart++;\n      this.absoluteLineStart = this.absoluteLineEnd + 1;\n      this.moveRangeI();\n      this.readLine();\n      return true;\n    }\n  }\n\n  moveRangeI() {\n    while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to) {\n      this.rangeI++;\n      this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);\n    }\n  } /// @internal\n\n\n  scanLine(start) {\n    let r = scanLineResult;\n    r.end = start;\n\n    if (start >= this.to) {\n      r.text = \"\";\n    } else {\n      r.text = this.lineChunkAt(start);\n      r.end += r.text.length;\n\n      if (this.ranges.length > 1) {\n        let textOffset = this.absoluteLineStart,\n            rangeI = this.rangeI;\n\n        while (this.ranges[rangeI].to < r.end) {\n          rangeI++;\n          let nextFrom = this.ranges[rangeI].from;\n          let after = this.lineChunkAt(nextFrom);\n          r.end = nextFrom + after.length;\n          r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;\n          textOffset = r.end - r.text.length;\n        }\n      }\n    }\n\n    return r;\n  } /// @internal\n\n\n  readLine() {\n    let {\n      line\n    } = this,\n        {\n      text,\n      end\n    } = this.scanLine(this.absoluteLineStart);\n    this.absoluteLineEnd = end;\n    line.reset(text);\n\n    for (; line.depth < this.stack.length; line.depth++) {\n      let cx = this.stack[line.depth],\n          handler = this.parser.skipContextMarkup[cx.type];\n      if (!handler) throw new Error(\"Unhandled block context \" + Type[cx.type]);\n      if (!handler(cx, this, line)) break;\n      line.forward();\n    }\n  }\n\n  lineChunkAt(pos) {\n    let next = this.input.chunk(pos),\n        text;\n\n    if (!this.input.lineChunks) {\n      let eol = next.indexOf(\"\\n\");\n      text = eol < 0 ? next : next.slice(0, eol);\n    } else {\n      text = next == \"\\n\" ? \"\" : next;\n    }\n\n    return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;\n  } /// The end position of the previous line.\n\n\n  prevLineEnd() {\n    return this.atEnd ? this.lineStart : this.lineStart - 1;\n  } /// @internal\n\n\n  startContext(type, start) {\n    let value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);\n    this.stack.push(this.block);\n  } /// Start a composite block. Should only be called from [block\n  /// parser functions](#BlockParser.parse) that return null.\n\n\n  startComposite(type, start) {\n    let value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this.startContext(this.parser.getNodeType(type), start, value);\n  } /// @internal\n\n\n  addNode(block, from, to) {\n    if (typeof block == \"number\") block = new Tree(this.parser.nodeSet.types[block], none, none, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);\n    this.block.addChild(block, from - this.block.from);\n  } /// Add a block element. Can be called by [block\n  /// parsers](#BlockParser.parse).\n\n\n  addElement(elt) {\n    this.block.addChild(elt.toTree(this.parser.nodeSet), elt.from - this.block.from);\n  } /// Add a block element from a [leaf parser](#LeafBlockParser). This\n  /// makes sure any extra composite block markup (such as blockquote\n  /// markers) inside the block are also added to the syntax tree.\n\n\n  addLeafElement(leaf, elt) {\n    this.addNode(this.buffer.writeElements(injectMarks(elt.children, leaf.marks), -elt.from).finish(elt.type, elt.to - elt.from), elt.from);\n  } /// @internal\n\n\n  finishContext() {\n    let cx = this.stack.pop();\n    let top = this.stack[this.stack.length - 1];\n    top.addChild(cx.toTree(this.parser.nodeSet), cx.from - top.from);\n    this.block = top;\n  }\n\n  finish() {\n    while (this.stack.length > 1) this.finishContext();\n\n    return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));\n  }\n\n  addGaps(tree) {\n    return this.ranges.length > 1 ? injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.dontInject) : tree;\n  } /// @internal\n\n\n  finishLeaf(leaf) {\n    for (let parser of leaf.parsers) if (parser.finish(this, leaf)) return;\n\n    let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);\n    this.addNode(this.buffer.writeElements(inline, -leaf.start).finish(Type.Paragraph, leaf.content.length), leaf.start);\n  }\n\n  elt(type, from, to, children) {\n    if (typeof type == \"string\") return elt(this.parser.getNodeType(type), from, to, children);\n    return new TreeElement(type, from);\n  } /// @internal\n\n\n  get buffer() {\n    return new Buffer(this.parser.nodeSet);\n  }\n\n}\n\nfunction injectGaps(ranges, rangeI, tree, offset, dont) {\n  if (dont.has(tree.tree)) return tree.tree;\n  let rangeEnd = ranges[rangeI].to;\n  let children = [],\n      positions = [],\n      start = tree.from + offset;\n\n  function movePastNext(upto, inclusive) {\n    while (inclusive ? upto >= rangeEnd : upto > rangeEnd) {\n      let size = ranges[rangeI + 1].from - rangeEnd;\n      offset += size;\n      upto += size;\n      rangeI++;\n      rangeEnd = ranges[rangeI].to;\n    }\n  }\n\n  for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {\n    movePastNext(ch.from + offset, true);\n    let from = ch.from + offset,\n        node;\n\n    if (ch.to + offset > rangeEnd) {\n      node = injectGaps(ranges, rangeI, ch, offset, dont);\n      movePastNext(ch.to + offset, false);\n    } else {\n      node = ch.toTree();\n    }\n\n    children.push(node);\n    positions.push(from - start);\n  }\n\n  movePastNext(tree.to + offset, false);\n  return new Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : undefined);\n} /// A Markdown parser configuration.\n\n\nclass MarkdownParser extends Parser {\n  /// @internal\n  constructor( /// The parser's syntax [node\n  /// types](https://lezer.codemirror.net/docs/ref/#common.NodeSet).\n  nodeSet, /// @internal\n  blockParsers, /// @internal\n  leafBlockParsers, /// @internal\n  blockNames, /// @internal\n  endLeafBlock, /// @internal\n  skipContextMarkup, /// @internal\n  inlineParsers, /// @internal\n  inlineNames, /// @internal\n  wrappers) {\n    super();\n    this.nodeSet = nodeSet;\n    this.blockParsers = blockParsers;\n    this.leafBlockParsers = leafBlockParsers;\n    this.blockNames = blockNames;\n    this.endLeafBlock = endLeafBlock;\n    this.skipContextMarkup = skipContextMarkup;\n    this.inlineParsers = inlineParsers;\n    this.inlineNames = inlineNames;\n    this.wrappers = wrappers; /// @internal\n\n    this.nodeTypes = Object.create(null);\n\n    for (let t of nodeSet.types) this.nodeTypes[t.name] = t.id;\n  }\n\n  createParse(input, fragments, ranges) {\n    let parse = new BlockContext(this, input, fragments, ranges);\n\n    for (let w of this.wrappers) parse = w(parse, input, fragments, ranges);\n\n    return parse;\n  } /// Reconfigure the parser.\n\n\n  configure(spec) {\n    let config = resolveConfig(spec);\n    if (!config) return this;\n    let {\n      nodeSet,\n      skipContextMarkup\n    } = this;\n    let blockParsers = this.blockParsers.slice(),\n        leafBlockParsers = this.leafBlockParsers.slice(),\n        blockNames = this.blockNames.slice(),\n        inlineParsers = this.inlineParsers.slice(),\n        inlineNames = this.inlineNames.slice(),\n        endLeafBlock = this.endLeafBlock.slice(),\n        wrappers = this.wrappers;\n\n    if (nonEmpty(config.defineNodes)) {\n      skipContextMarkup = Object.assign({}, skipContextMarkup);\n      let nodeTypes = nodeSet.types.slice(),\n          styles;\n\n      for (let s of config.defineNodes) {\n        let {\n          name,\n          block,\n          composite,\n          style\n        } = typeof s == \"string\" ? {\n          name: s\n        } : s;\n        if (nodeTypes.some(t => t.name == name)) continue;\n        if (composite) skipContextMarkup[nodeTypes.length] = (bl, cx, line) => composite(cx, line, bl.value);\n        let id = nodeTypes.length;\n        let group = composite ? [\"Block\", \"BlockContext\"] : !block ? undefined : id >= Type.ATXHeading1 && id <= Type.SetextHeading2 ? [\"Block\", \"LeafBlock\", \"Heading\"] : [\"Block\", \"LeafBlock\"];\n        nodeTypes.push(NodeType.define({\n          id,\n          name,\n          props: group && [[NodeProp.group, group]]\n        }));\n\n        if (style) {\n          if (!styles) styles = {};\n          if (Array.isArray(style) || style instanceof Tag) styles[name] = style;else Object.assign(styles, style);\n        }\n      }\n\n      nodeSet = new NodeSet(nodeTypes);\n      if (styles) nodeSet = nodeSet.extend(styleTags(styles));\n    }\n\n    if (nonEmpty(config.props)) nodeSet = nodeSet.extend(...config.props);\n\n    if (nonEmpty(config.remove)) {\n      for (let rm of config.remove) {\n        let block = this.blockNames.indexOf(rm),\n            inline = this.inlineNames.indexOf(rm);\n        if (block > -1) blockParsers[block] = leafBlockParsers[block] = undefined;\n        if (inline > -1) inlineParsers[inline] = undefined;\n      }\n    }\n\n    if (nonEmpty(config.parseBlock)) {\n      for (let spec of config.parseBlock) {\n        let found = blockNames.indexOf(spec.name);\n\n        if (found > -1) {\n          blockParsers[found] = spec.parse;\n          leafBlockParsers[found] = spec.leaf;\n        } else {\n          let pos = spec.before ? findName(blockNames, spec.before) : spec.after ? findName(blockNames, spec.after) + 1 : blockNames.length - 1;\n          blockParsers.splice(pos, 0, spec.parse);\n          leafBlockParsers.splice(pos, 0, spec.leaf);\n          blockNames.splice(pos, 0, spec.name);\n        }\n\n        if (spec.endLeaf) endLeafBlock.push(spec.endLeaf);\n      }\n    }\n\n    if (nonEmpty(config.parseInline)) {\n      for (let spec of config.parseInline) {\n        let found = inlineNames.indexOf(spec.name);\n\n        if (found > -1) {\n          inlineParsers[found] = spec.parse;\n        } else {\n          let pos = spec.before ? findName(inlineNames, spec.before) : spec.after ? findName(inlineNames, spec.after) + 1 : inlineNames.length - 1;\n          inlineParsers.splice(pos, 0, spec.parse);\n          inlineNames.splice(pos, 0, spec.name);\n        }\n      }\n    }\n\n    if (config.wrap) wrappers = wrappers.concat(config.wrap);\n    return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);\n  } /// @internal\n\n\n  getNodeType(name) {\n    let found = this.nodeTypes[name];\n    if (found == null) throw new RangeError(`Unknown node type '${name}'`);\n    return found;\n  } /// Parse the given piece of inline text at the given offset,\n  /// returning an array of [`Element`](#Element) objects representing\n  /// the inline content.\n\n\n  parseInline(text, offset) {\n    let cx = new InlineContext(this, text, offset);\n\n    outer: for (let pos = offset; pos < cx.end;) {\n      let next = cx.char(pos);\n\n      for (let token of this.inlineParsers) if (token) {\n        let result = token(cx, next, pos);\n\n        if (result >= 0) {\n          pos = result;\n          continue outer;\n        }\n      }\n\n      pos++;\n    }\n\n    return cx.resolveMarkers(0);\n  }\n\n}\n\nfunction nonEmpty(a) {\n  return a != null && a.length > 0;\n}\n\nfunction resolveConfig(spec) {\n  if (!Array.isArray(spec)) return spec;\n  if (spec.length == 0) return null;\n  let conf = resolveConfig(spec[0]);\n  if (spec.length == 1) return conf;\n  let rest = resolveConfig(spec.slice(1));\n  if (!rest || !conf) return conf || rest;\n\n  let conc = (a, b) => (a || none).concat(b || none);\n\n  let wrapA = conf.wrap,\n      wrapB = rest.wrap;\n  return {\n    props: conc(conf.props, rest.props),\n    defineNodes: conc(conf.defineNodes, rest.defineNodes),\n    parseBlock: conc(conf.parseBlock, rest.parseBlock),\n    parseInline: conc(conf.parseInline, rest.parseInline),\n    remove: conc(conf.remove, rest.remove),\n    wrap: !wrapA ? wrapB : !wrapB ? wrapA : (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)\n  };\n}\n\nfunction findName(names, name) {\n  let found = names.indexOf(name);\n  if (found < 0) throw new RangeError(`Position specified relative to unknown parser ${name}`);\n  return found;\n}\n\nlet nodeTypes = [NodeType.none];\n\nfor (let i = 1, name; name = Type[i]; i++) {\n  nodeTypes[i] = NodeType.define({\n    id: i,\n    name,\n    props: i >= Type.Escape ? [] : [[NodeProp.group, i in DefaultSkipMarkup ? [\"Block\", \"BlockContext\"] : [\"Block\", \"LeafBlock\"]]]\n  });\n}\n\nconst none = [];\n\nclass Buffer {\n  constructor(nodeSet) {\n    this.nodeSet = nodeSet;\n    this.content = [];\n    this.nodes = [];\n  }\n\n  write(type, from, to) {\n    let children = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    this.content.push(type, from, to, 4 + children * 4);\n    return this;\n  }\n\n  writeElements(elts) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    for (let e of elts) e.writeTo(this, offset);\n\n    return this;\n  }\n\n  finish(type, length) {\n    return Tree.build({\n      buffer: this.content,\n      nodeSet: this.nodeSet,\n      reused: this.nodes,\n      topID: type,\n      length\n    });\n  }\n\n} /// Elements are used to compose syntax nodes during parsing.\n\n\nclass Element {\n  /// @internal\n  constructor( /// The node's\n  /// [id](https://lezer.codemirror.net/docs/ref/#common.NodeType.id).\n  type, /// The start of the node, as an offset from the start of the document.\n  from, /// The end of the node.\n  to) {\n    let children = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : none;\n    this.type = type;\n    this.from = from;\n    this.to = to;\n    this.children = children;\n  } /// @internal\n\n\n  writeTo(buf, offset) {\n    let startOff = buf.content.length;\n    buf.writeElements(this.children, offset);\n    buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);\n  } /// @internal\n\n\n  toTree(nodeSet) {\n    return new Buffer(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);\n  }\n\n}\n\nclass TreeElement {\n  constructor(tree, from) {\n    this.tree = tree;\n    this.from = from;\n  }\n\n  get to() {\n    return this.from + this.tree.length;\n  }\n\n  get type() {\n    return this.tree.type.id;\n  }\n\n  get children() {\n    return none;\n  }\n\n  writeTo(buf, offset) {\n    buf.nodes.push(this.tree);\n    buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);\n  }\n\n  toTree() {\n    return this.tree;\n  }\n\n}\n\nfunction elt(type, from, to, children) {\n  return new Element(type, from, to, children);\n}\n\nconst EmphasisUnderscore = {\n  resolve: \"Emphasis\",\n  mark: \"EmphasisMark\"\n};\nconst EmphasisAsterisk = {\n  resolve: \"Emphasis\",\n  mark: \"EmphasisMark\"\n};\nconst LinkStart = {},\n      ImageStart = {};\n\nclass InlineDelimiter {\n  constructor(type, from, to, side) {\n    this.type = type;\n    this.from = from;\n    this.to = to;\n    this.side = side;\n  }\n\n}\n\nconst Escapable = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\nlet Punctuation = /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~\\xA1\\u2010-\\u2027]/;\n\ntry {\n  Punctuation = new RegExp(\"[\\\\p{Pc}|\\\\p{Pd}|\\\\p{Pe}|\\\\p{Pf}|\\\\p{Pi}|\\\\p{Po}|\\\\p{Ps}]\", \"u\");\n} catch (_) {}\n\nconst DefaultInline = {\n  Escape(cx, next, start) {\n    if (next != 92\n    /* '\\\\' */\n    || start == cx.end - 1) return -1;\n    let escaped = cx.char(start + 1);\n\n    for (let i = 0; i < Escapable.length; i++) if (Escapable.charCodeAt(i) == escaped) return cx.append(elt(Type.Escape, start, start + 2));\n\n    return -1;\n  },\n\n  Entity(cx, next, start) {\n    if (next != 38\n    /* '&' */\n    ) return -1;\n    let m = /^(?:#\\d+|#x[a-f\\d]+|\\w+);/i.exec(cx.slice(start + 1, start + 31));\n    return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1;\n  },\n\n  InlineCode(cx, next, start) {\n    if (next != 96\n    /* '`' */\n    || start && cx.char(start - 1) == 96) return -1;\n    let pos = start + 1;\n\n    while (pos < cx.end && cx.char(pos) == 96) pos++;\n\n    let size = pos - start,\n        curSize = 0;\n\n    for (; pos < cx.end; pos++) {\n      if (cx.char(pos) == 96) {\n        curSize++;\n        if (curSize == size && cx.char(pos + 1) != 96) return cx.append(elt(Type.InlineCode, start, pos + 1, [elt(Type.CodeMark, start, start + size), elt(Type.CodeMark, pos + 1 - size, pos + 1)]));\n      } else {\n        curSize = 0;\n      }\n    }\n\n    return -1;\n  },\n\n  HTMLTag(cx, next, start) {\n    if (next != 60\n    /* '<' */\n    || start == cx.end - 1) return -1;\n    let after = cx.slice(start + 1, cx.end);\n    let url = /^(?:[a-z][-\\w+.]+:[^\\s>]+|[a-z\\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?(?:\\.[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?)*)>/i.exec(after);\n    if (url) return cx.append(elt(Type.URL, start, start + 1 + url[0].length));\n    let comment = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);\n    if (comment) return cx.append(elt(Type.Comment, start, start + 1 + comment[0].length));\n    let procInst = /^\\?[^]*?\\?>/.exec(after);\n    if (procInst) return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));\n    let m = /^(?:![A-Z][^]*?>|!\\[CDATA\\[[^]*?\\]\\]>|\\/\\s*[a-zA-Z][\\w-]*\\s*>|\\s*[a-zA-Z][\\w-]*(\\s+[a-zA-Z:_][\\w-.:]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*(\\/\\s*)?>)/.exec(after);\n    if (!m) return -1;\n    return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length));\n  },\n\n  Emphasis(cx, next, start) {\n    if (next != 95 && next != 42) return -1;\n    let pos = start + 1;\n\n    while (cx.char(pos) == next) pos++;\n\n    let before = cx.slice(start - 1, start),\n        after = cx.slice(pos, pos + 1);\n    let pBefore = Punctuation.test(before),\n        pAfter = Punctuation.test(after);\n    let sBefore = /\\s|^$/.test(before),\n        sAfter = /\\s|^$/.test(after);\n    let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);\n    let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);\n    let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);\n    let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);\n    return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1\n    /* Open */\n    : 0) | (canClose ? 2\n    /* Close */\n    : 0)));\n  },\n\n  HardBreak(cx, next, start) {\n    if (next == 92\n    /* '\\\\' */\n    && cx.char(start + 1) == 10\n    /* '\\n' */\n    ) return cx.append(elt(Type.HardBreak, start, start + 2));\n\n    if (next == 32) {\n      let pos = start + 1;\n\n      while (cx.char(pos) == 32) pos++;\n\n      if (cx.char(pos) == 10 && pos >= start + 2) return cx.append(elt(Type.HardBreak, start, pos + 1));\n    }\n\n    return -1;\n  },\n\n  Link(cx, next, start) {\n    return next == 91\n    /* '[' */\n    ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, 1\n    /* Open */\n    )) : -1;\n  },\n\n  Image(cx, next, start) {\n    return next == 33\n    /* '!' */\n    && cx.char(start + 1) == 91\n    /* '[' */\n    ? cx.append(new InlineDelimiter(ImageStart, start, start + 2, 1\n    /* Open */\n    )) : -1;\n  },\n\n  LinkEnd(cx, next, start) {\n    if (next != 93\n    /* ']' */\n    ) return -1; // Scanning back to the next link/image start marker\n\n    for (let i = cx.parts.length - 1; i >= 0; i--) {\n      let part = cx.parts[i];\n\n      if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {\n        // If this one has been set invalid (because it would produce\n        // a nested link) or there's no valid link here ignore both.\n        if (!part.side || cx.skipSpace(part.to) == start && !/[(\\[]/.test(cx.slice(start + 1, start + 2))) {\n          cx.parts[i] = null;\n          return -1;\n        } // Finish the content and replace the entire range in\n        // this.parts with the link/image node.\n\n\n        let content = cx.takeContent(i);\n        let link = cx.parts[i] = finishLink(cx, content, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1); // Set any open-link markers before this link to invalid.\n\n        if (part.type == LinkStart) for (let j = 0; j < i; j++) {\n          let p = cx.parts[j];\n          if (p instanceof InlineDelimiter && p.type == LinkStart) p.side = 0;\n        }\n        return link.to;\n      }\n    }\n\n    return -1;\n  }\n\n};\n\nfunction finishLink(cx, content, type, start, startPos) {\n  let {\n    text\n  } = cx,\n      next = cx.char(startPos),\n      endPos = startPos;\n  content.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));\n  content.push(elt(Type.LinkMark, startPos - 1, startPos));\n\n  if (next == 40\n  /* '(' */\n  ) {\n    let pos = cx.skipSpace(startPos + 1);\n    let dest = parseURL(text, pos - cx.offset, cx.offset),\n        title;\n\n    if (dest) {\n      pos = cx.skipSpace(dest.to);\n      title = parseLinkTitle(text, pos - cx.offset, cx.offset);\n      if (title) pos = cx.skipSpace(title.to);\n    }\n\n    if (cx.char(pos) == 41\n    /* ')' */\n    ) {\n      content.push(elt(Type.LinkMark, startPos, startPos + 1));\n      endPos = pos + 1;\n      if (dest) content.push(dest);\n      if (title) content.push(title);\n      content.push(elt(Type.LinkMark, pos, endPos));\n    }\n  } else if (next == 91\n  /* '[' */\n  ) {\n    let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);\n\n    if (label) {\n      content.push(label);\n      endPos = label.to;\n    }\n  }\n\n  return elt(type, start, endPos, content);\n} // These return `null` when falling off the end of the input, `false`\n// when parsing fails otherwise (for use in the incremental link\n// reference parser).\n\n\nfunction parseURL(text, start, offset) {\n  let next = text.charCodeAt(start);\n\n  if (next == 60\n  /* '<' */\n  ) {\n    for (let pos = start + 1; pos < text.length; pos++) {\n      let ch = text.charCodeAt(pos);\n      if (ch == 62\n      /* '>' */\n      ) return elt(Type.URL, start + offset, pos + 1 + offset);\n      if (ch == 60 || ch == 10\n      /* '<\\n' */\n      ) return false;\n    }\n\n    return null;\n  } else {\n    let depth = 0,\n        pos = start;\n\n    for (let escaped = false; pos < text.length; pos++) {\n      let ch = text.charCodeAt(pos);\n\n      if (space(ch)) {\n        break;\n      } else if (escaped) {\n        escaped = false;\n      } else if (ch == 40\n      /* '(' */\n      ) {\n        depth++;\n      } else if (ch == 41\n      /* ')' */\n      ) {\n        if (!depth) break;\n        depth--;\n      } else if (ch == 92\n      /* '\\\\' */\n      ) {\n        escaped = true;\n      }\n    }\n\n    return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text.length ? null : false;\n  }\n}\n\nfunction parseLinkTitle(text, start, offset) {\n  let next = text.charCodeAt(start);\n  if (next != 39 && next != 34 && next != 40\n  /* '\"\\'(' */\n  ) return false;\n  let end = next == 40 ? 41 : next;\n\n  for (let pos = start + 1, escaped = false; pos < text.length; pos++) {\n    let ch = text.charCodeAt(pos);\n    if (escaped) escaped = false;else if (ch == end) return elt(Type.LinkTitle, start + offset, pos + 1 + offset);else if (ch == 92\n    /* '\\\\' */\n    ) escaped = true;\n  }\n\n  return null;\n}\n\nfunction parseLinkLabel(text, start, offset, requireNonWS) {\n  for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {\n    let ch = text.charCodeAt(pos);\n    if (escaped) escaped = false;else if (ch == 93\n    /* ']' */\n    ) return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);else {\n      if (requireNonWS && !space(ch)) requireNonWS = false;\n      if (ch == 91\n      /* '[' */\n      ) return false;else if (ch == 92\n      /* '\\\\' */\n      ) escaped = true;\n    }\n  }\n\n  return null;\n} /// Inline parsing functions get access to this context, and use it to\n/// read the content and emit syntax nodes.\n\n\nclass InlineContext {\n  /// @internal\n  constructor( /// The parser that is being used.\n  parser, /// The text of this inline section.\n  text, /// The starting offset of the section in the document.\n  offset) {\n    this.parser = parser;\n    this.text = text;\n    this.offset = offset; /// @internal\n\n    this.parts = [];\n  } /// Get the character code at the given (document-relative)\n  /// position.\n\n\n  char(pos) {\n    return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset);\n  } /// The position of the end of this inline section.\n\n\n  get end() {\n    return this.offset + this.text.length;\n  } /// Get a substring of this inline section. Again uses\n  /// document-relative positions.\n\n\n  slice(from, to) {\n    return this.text.slice(from - this.offset, to - this.offset);\n  } /// @internal\n\n\n  append(elt) {\n    this.parts.push(elt);\n    return elt.to;\n  } /// Add a [delimiter](#DelimiterType) at this given position. `open`\n  /// and `close` indicate whether this delimiter is opening, closing,\n  /// or both. Returns the end of the delimiter, for convenient\n  /// returning from [parse functions](#InlineParser.parse).\n\n\n  addDelimiter(type, from, to, open, close) {\n    return this.append(new InlineDelimiter(type, from, to, (open ? 1\n    /* Open */\n    : 0) | (close ? 2\n    /* Close */\n    : 0)));\n  } /// Add an inline element. Returns the end of the element.\n\n\n  addElement(elt) {\n    return this.append(elt);\n  } /// @internal\n\n\n  resolveMarkers(from) {\n    for (let i = from; i < this.parts.length; i++) {\n      let close = this.parts[i];\n      if (!(close instanceof InlineDelimiter && close.type.resolve && close.side & 2\n      /* Close */\n      )) continue;\n      let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;\n      let closeSize = close.to - close.from;\n      let open,\n          j = i - 1;\n\n      for (; j >= from; j--) {\n        let part = this.parts[j];\n        if (!(part instanceof InlineDelimiter && part.side & 1\n        /* Open */\n        && part.type == close.type) || emp && (close.side & 1\n        /* Open */\n        || part.side & 2\n        /* Close */\n        ) && (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3)) continue;\n        open = part;\n        break;\n      }\n\n      if (!open) continue;\n      let type = close.type.resolve,\n          content = [];\n      let start = open.from,\n          end = close.to;\n\n      if (emp) {\n        let size = Math.min(2, open.to - open.from, closeSize);\n        start = open.to - size;\n        end = close.from + size;\n        type = size == 1 ? \"Emphasis\" : \"StrongEmphasis\";\n      }\n\n      if (open.type.mark) content.push(this.elt(open.type.mark, start, open.to));\n\n      for (let k = j + 1; k < i; k++) {\n        if (this.parts[k] instanceof Element) content.push(this.parts[k]);\n        this.parts[k] = null;\n      }\n\n      if (close.type.mark) content.push(this.elt(close.type.mark, close.from, end));\n      let element = this.elt(type, start, end, content);\n      this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;\n      let keep = this.parts[i] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;\n      if (keep) this.parts.splice(i, 0, element);else this.parts[i] = element;\n    }\n\n    let result = [];\n\n    for (let i = from; i < this.parts.length; i++) {\n      let part = this.parts[i];\n      if (part instanceof Element) result.push(part);\n    }\n\n    return result;\n  } /// Find an opening delimiter of the given type. Returns `null` if\n  /// no delimiter is found, or an index that can be passed to\n  /// [`takeContent`](#InlineContext.takeContent) otherwise.\n\n\n  findOpeningDelimiter(type) {\n    for (let i = this.parts.length - 1; i >= 0; i--) {\n      let part = this.parts[i];\n      if (part instanceof InlineDelimiter && part.type == type) return i;\n    }\n\n    return null;\n  } /// Remove all inline elements and delimiters starting from the\n  /// given index (which you should get from\n  /// [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),\n  /// resolve delimiters inside of them, and return them as an array\n  /// of elements.\n\n\n  takeContent(startIndex) {\n    let content = this.resolveMarkers(startIndex);\n    this.parts.length = startIndex;\n    return content;\n  } /// Skip space after the given (document) position, returning either\n  /// the position of the next non-space character or the end of the\n  /// section.\n\n\n  skipSpace(from) {\n    return skipSpace(this.text, from - this.offset) + this.offset;\n  }\n\n  elt(type, from, to, children) {\n    if (typeof type == \"string\") return elt(this.parser.getNodeType(type), from, to, children);\n    return new TreeElement(type, from);\n  }\n\n}\n\nfunction injectMarks(elements, marks) {\n  if (!marks.length) return elements;\n  if (!elements.length) return marks;\n  let elts = elements.slice(),\n      eI = 0;\n\n  for (let mark of marks) {\n    while (eI < elts.length && elts[eI].to < mark.to) eI++;\n\n    if (eI < elts.length && elts[eI].from < mark.from) {\n      let e = elts[eI];\n      if (e instanceof Element) elts[eI] = new Element(e.type, e.from, e.to, injectMarks(e.children, [mark]));\n    } else {\n      elts.splice(eI++, 0, mark);\n    }\n  }\n\n  return elts;\n} // These are blocks that can span blank lines, and should thus only be\n// reused if their next sibling is also being reused.\n\n\nconst NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];\n\nclass FragmentCursor {\n  constructor(fragments, input) {\n    this.fragments = fragments;\n    this.input = input; // Index into fragment array\n\n    this.i = 0; // Active fragment\n\n    this.fragment = null;\n    this.fragmentEnd = -1; // Cursor into the current fragment, if any. When `moveTo` returns\n    // true, this points at the first block after `pos`.\n\n    this.cursor = null;\n    if (fragments.length) this.fragment = fragments[this.i++];\n  }\n\n  nextFragment() {\n    this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;\n    this.cursor = null;\n    this.fragmentEnd = -1;\n  }\n\n  moveTo(pos, lineStart) {\n    while (this.fragment && this.fragment.to <= pos) this.nextFragment();\n\n    if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0)) return false;\n\n    if (this.fragmentEnd < 0) {\n      let end = this.fragment.to;\n\n      while (end > 0 && this.input.read(end - 1, end) != \"\\n\") end--;\n\n      this.fragmentEnd = end ? end - 1 : 0;\n    }\n\n    let c = this.cursor;\n\n    if (!c) {\n      c = this.cursor = this.fragment.tree.cursor();\n      c.firstChild();\n    }\n\n    let rPos = pos + this.fragment.offset;\n\n    while (c.to <= rPos) if (!c.parent()) return false;\n\n    for (;;) {\n      if (c.from >= rPos) return this.fragment.from <= lineStart;\n      if (!c.childAfter(rPos)) return false;\n    }\n  }\n\n  matches(hash) {\n    let tree = this.cursor.tree;\n    return tree && tree.prop(NodeProp.contextHash) == hash;\n  }\n\n  takeNodes(cx) {\n    let cur = this.cursor,\n        off = this.fragment.offset,\n        fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);\n    let start = cx.absoluteLineStart,\n        end = start,\n        blockI = cx.block.children.length;\n    let prevEnd = end,\n        prevI = blockI;\n\n    for (;;) {\n      if (cur.to - off > fragEnd) {\n        if (cur.type.isAnonymous && cur.firstChild()) continue;\n        break;\n      }\n\n      cx.dontInject.add(cur.tree);\n      cx.addNode(cur.tree, cur.from - off); // Taken content must always end in a block, because incremental\n      // parsing happens on block boundaries. Never stop directly\n      // after an indented code block, since those can continue after\n      // any number of blank lines.\n\n      if (cur.type.is(\"Block\")) {\n        if (NotLast.indexOf(cur.type.id) < 0) {\n          end = cur.to - off;\n          blockI = cx.block.children.length;\n        } else {\n          end = prevEnd;\n          blockI = prevI;\n          prevEnd = cur.to - off;\n          prevI = cx.block.children.length;\n        }\n      }\n\n      if (!cur.nextSibling()) break;\n    }\n\n    while (cx.block.children.length > blockI) {\n      cx.block.children.pop();\n      cx.block.positions.pop();\n    }\n\n    return end - start;\n  }\n\n}\n\nconst markdownHighlighting = styleTags({\n  \"Blockquote/...\": tags.quote,\n  HorizontalRule: tags.contentSeparator,\n  \"ATXHeading1/... SetextHeading1/...\": tags.heading1,\n  \"ATXHeading2/... SetextHeading2/...\": tags.heading2,\n  \"ATXHeading3/...\": tags.heading3,\n  \"ATXHeading4/...\": tags.heading4,\n  \"ATXHeading5/...\": tags.heading5,\n  \"ATXHeading6/...\": tags.heading6,\n  \"Comment CommentBlock\": tags.comment,\n  Escape: tags.escape,\n  Entity: tags.character,\n  \"Emphasis/...\": tags.emphasis,\n  \"StrongEmphasis/...\": tags.strong,\n  \"Link/... Image/...\": tags.link,\n  \"OrderedList/... BulletList/...\": tags.list,\n  \"BlockQuote/...\": tags.quote,\n  \"InlineCode CodeText\": tags.monospace,\n  URL: tags.url,\n  \"HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark\": tags.processingInstruction,\n  \"CodeInfo LinkLabel\": tags.labelName,\n  LinkTitle: tags.string,\n  Paragraph: tags.content\n}); /// The default CommonMark parser.\n\nconst parser = new MarkdownParser(new NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map(n => DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map(n => DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map(n => DefaultInline[n]), Object.keys(DefaultInline), []);\n\nfunction leftOverSpace(node, from, to) {\n  let ranges = [];\n\n  for (let n = node.firstChild, pos = from;; n = n.nextSibling) {\n    let nextPos = n ? n.from : to;\n    if (nextPos > pos) ranges.push({\n      from: pos,\n      to: nextPos\n    });\n    if (!n) break;\n    pos = n.to;\n  }\n\n  return ranges;\n} /// Create a Markdown extension to enable nested parsing on code\n/// blocks and/or embedded HTML.\n\n\nfunction parseCode(config) {\n  let {\n    codeParser,\n    htmlParser\n  } = config;\n  let wrap = parseMixed((node, input) => {\n    let id = node.type.id;\n\n    if (codeParser && (id == Type.CodeBlock || id == Type.FencedCode)) {\n      let info = \"\";\n\n      if (id == Type.FencedCode) {\n        let infoNode = node.node.getChild(Type.CodeInfo);\n        if (infoNode) info = input.read(infoNode.from, infoNode.to);\n      }\n\n      let parser = codeParser(info);\n      if (parser) return {\n        parser,\n        overlay: node => node.type.id == Type.CodeText\n      };\n    } else if (htmlParser && (id == Type.HTMLBlock || id == Type.HTMLTag)) {\n      return {\n        parser: htmlParser,\n        overlay: leftOverSpace(node.node, node.from, node.to)\n      };\n    }\n\n    return null;\n  });\n  return {\n    wrap\n  };\n}\n\nconst StrikethroughDelim = {\n  resolve: \"Strikethrough\",\n  mark: \"StrikethroughMark\"\n}; /// An extension that implements\n/// [GFM-style](https://github.github.com/gfm/#strikethrough-extension-)\n/// Strikethrough syntax using `~~` delimiters.\n\nconst Strikethrough = {\n  defineNodes: [{\n    name: \"Strikethrough\",\n    style: {\n      \"Strikethrough/...\": tags.strikethrough\n    }\n  }, {\n    name: \"StrikethroughMark\",\n    style: tags.processingInstruction\n  }],\n  parseInline: [{\n    name: \"Strikethrough\",\n\n    parse(cx, next, pos) {\n      if (next != 126\n      /* '~' */\n      || cx.char(pos + 1) != 126) return -1;\n      return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, true, true);\n    },\n\n    after: \"Emphasis\"\n  }]\n};\n\nfunction parseRow(cx, line) {\n  let startI = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let elts = arguments.length > 3 ? arguments[3] : undefined;\n  let offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  let count = 0,\n      first = true,\n      cellStart = -1,\n      cellEnd = -1,\n      esc = false;\n\n  let parseCell = () => {\n    elts.push(cx.elt(\"TableCell\", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));\n  };\n\n  for (let i = startI; i < line.length; i++) {\n    let next = line.charCodeAt(i);\n\n    if (next == 124\n    /* '|' */\n    && !esc) {\n      if (!first || cellStart > -1) count++;\n      first = false;\n\n      if (elts) {\n        if (cellStart > -1) parseCell();\n        elts.push(cx.elt(\"TableDelimiter\", i + offset, i + offset + 1));\n      }\n\n      cellStart = cellEnd = -1;\n    } else if (esc || next != 32 && next != 9) {\n      if (cellStart < 0) cellStart = i;\n      cellEnd = i + 1;\n    }\n\n    esc = !esc && next == 92;\n  }\n\n  if (cellStart > -1) {\n    count++;\n    if (elts) parseCell();\n  }\n\n  return count;\n}\n\nfunction hasPipe(str, start) {\n  for (let i = start; i < str.length; i++) {\n    let next = str.charCodeAt(i);\n    if (next == 124\n    /* '|' */\n    ) return true;\n    if (next == 92\n    /* '\\\\' */\n    ) i++;\n  }\n\n  return false;\n}\n\nconst delimiterLine = /^\\|?(\\s*:?-+:?\\s*\\|)+(\\s*:?-+:?\\s*)?$/;\n\nclass TableParser {\n  constructor() {\n    // Null means we haven't seen the second line yet, false means this\n    // isn't a table, and an array means this is a table and we've\n    // parsed the given rows so far.\n    this.rows = null;\n  }\n\n  nextLine(cx, line, leaf) {\n    if (this.rows == null) {\n      // Second line\n      this.rows = false;\n      let lineText;\n\n      if ((line.next == 45 || line.next == 58 || line.next == 124\n      /* '-:|' */\n      ) && delimiterLine.test(lineText = line.text.slice(line.pos))) {\n        let firstRow = [],\n            firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);\n        if (firstCount == parseRow(cx, lineText, line.pos)) this.rows = [cx.elt(\"TableHeader\", leaf.start, leaf.start + leaf.content.length, firstRow), cx.elt(\"TableDelimiter\", cx.lineStart + line.pos, cx.lineStart + line.text.length)];\n      }\n    } else if (this.rows) {\n      // Line after the second\n      let content = [];\n      parseRow(cx, line.text, line.pos, content, cx.lineStart);\n      this.rows.push(cx.elt(\"TableRow\", cx.lineStart + line.pos, cx.lineStart + line.text.length, content));\n    }\n\n    return false;\n  }\n\n  finish(cx, leaf) {\n    if (!this.rows) return false;\n    cx.addLeafElement(leaf, cx.elt(\"Table\", leaf.start, leaf.start + leaf.content.length, this.rows));\n    return true;\n  }\n\n} /// This extension provides\n/// [GFM-style](https://github.github.com/gfm/#tables-extension-)\n/// tables, using syntax like this:\n///\n/// ```\n/// | head 1 | head 2 |\n/// | ---    | ---    |\n/// | cell 1 | cell 2 |\n/// ```\n\n\nconst Table = {\n  defineNodes: [{\n    name: \"Table\",\n    block: true\n  }, {\n    name: \"TableHeader\",\n    style: {\n      \"TableHeader/...\": tags.heading\n    }\n  }, \"TableRow\", {\n    name: \"TableCell\",\n    style: tags.content\n  }, {\n    name: \"TableDelimiter\",\n    style: tags.processingInstruction\n  }],\n  parseBlock: [{\n    name: \"Table\",\n\n    leaf(_, leaf) {\n      return hasPipe(leaf.content, 0) ? new TableParser() : null;\n    },\n\n    endLeaf(cx, line, leaf) {\n      if (leaf.parsers.some(p => p instanceof TableParser) || !hasPipe(line.text, line.basePos)) return false;\n      let next = cx.scanLine(cx.absoluteLineEnd + 1).text;\n      return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);\n    },\n\n    before: \"SetextHeading\"\n  }]\n};\n\nclass TaskParser {\n  nextLine() {\n    return false;\n  }\n\n  finish(cx, leaf) {\n    cx.addLeafElement(leaf, cx.elt(\"Task\", leaf.start, leaf.start + leaf.content.length, [cx.elt(\"TaskMarker\", leaf.start, leaf.start + 3), ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)]));\n    return true;\n  }\n\n} /// Extension providing\n/// [GFM-style](https://github.github.com/gfm/#task-list-items-extension-)\n/// task list items, where list items can be prefixed with `[ ]` or\n/// `[x]` to add a checkbox.\n\n\nconst TaskList = {\n  defineNodes: [{\n    name: \"Task\",\n    block: true,\n    style: tags.list\n  }, {\n    name: \"TaskMarker\",\n    style: tags.atom\n  }],\n  parseBlock: [{\n    name: \"TaskList\",\n\n    leaf(cx, leaf) {\n      return /^\\[[ xX]\\]/.test(leaf.content) && cx.parentType().name == \"ListItem\" ? new TaskParser() : null;\n    },\n\n    after: \"SetextHeading\"\n  }]\n}; /// Extension bundle containing [`Table`](#Table),\n/// [`TaskList`](#TaskList) and [`Strikethrough`](#Strikethrough).\n\nconst GFM = [Table, TaskList, Strikethrough];\n\nfunction parseSubSuper(ch, node, mark) {\n  return (cx, next, pos) => {\n    if (next != ch || cx.char(pos + 1) == ch) return -1;\n    let elts = [cx.elt(mark, pos, pos + 1)];\n\n    for (let i = pos + 1; i < cx.end; i++) {\n      let next = cx.char(i);\n      if (next == ch) return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));\n      if (next == 92\n      /* '\\\\' */\n      ) elts.push(cx.elt(\"Escape\", i, i++ + 2));\n      if (space(next)) break;\n    }\n\n    return -1;\n  };\n} /// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// superscript using `^` markers.\n\n\nconst Superscript = {\n  defineNodes: [{\n    name: \"Superscript\",\n    style: tags.special(tags.content)\n  }, {\n    name: \"SuperscriptMark\",\n    style: tags.processingInstruction\n  }],\n  parseInline: [{\n    name: \"Superscript\",\n    parse: parseSubSuper(94\n    /* '^' */\n    , \"Superscript\", \"SuperscriptMark\")\n  }]\n}; /// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// subscript using `~` markers.\n\nconst Subscript = {\n  defineNodes: [{\n    name: \"Subscript\",\n    style: tags.special(tags.content)\n  }, {\n    name: \"SubscriptMark\",\n    style: tags.processingInstruction\n  }],\n  parseInline: [{\n    name: \"Subscript\",\n    parse: parseSubSuper(126\n    /* '~' */\n    , \"Subscript\", \"SubscriptMark\")\n  }]\n}; /// Extension that parses two colons with only letters, underscores,\n/// and numbers between them as `Emoji` nodes.\n\nconst Emoji = {\n  defineNodes: [{\n    name: \"Emoji\",\n    style: tags.character\n  }],\n  parseInline: [{\n    name: \"Emoji\",\n\n    parse(cx, next, pos) {\n      let match;\n      if (next != 58\n      /* ':' */\n      || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end)))) return -1;\n      return cx.addElement(cx.elt(\"Emoji\", pos, pos + 1 + match[0].length));\n    }\n\n  }]\n};\nexport { BlockContext, Element, Emoji, GFM, InlineContext, LeafBlock, Line, MarkdownParser, Strikethrough, Subscript, Superscript, Table, TaskList, parseCode, parser };","map":{"version":3,"names":["NodeType","NodeProp","NodeSet","Tree","Parser","parseMixed","styleTags","tags","Tag","CompositeBlock","constructor","type","value","from","hash","end","children","positions","hashProp","contextHash","create","parentHash","addChild","child","pos","prop","length","push","toTree","nodeSet","last","Math","max","tree","types","balance","makeTree","none","Type","LeafBlock","start","content","marks","parsers","Line","text","baseIndent","basePos","depth","markers","indent","next","forward","forwardInner","newPos","skipSpace","countIndent","charCodeAt","reset","pop","moveBase","to","moveBaseColumn","findColumn","addMarker","elt","i","goal","scrub","result","slice","skipForList","bl","cx","line","block","stack","size","OrderedList","isOrderedList","isBulletList","BulletList","isHorizontalRule","DefaultSkipMarkup","Blockquote","QuoteMark","lineStart","space","ListItem","_cx","Document","ch","skipSpaceBack","isFencedCode","isBlockquote","breaking","count","isSetextUnderline","inList","isAtxHeading","EmptyLine","CommentEnd","ProcessingEnd","HTMLBlockStyle","isHTMLBlock","rest","e","test","getListIndent","indentAfter","indented","addCodeText","CodeText","DefaultBlockParsers","LinkReference","undefined","IndentedCode","base","pendingMarks","nextLine","m","codeStart","filter","concat","addNode","buffer","writeElements","finish","CodeBlock","FencedCode","fenceEnd","len","infoFrom","infoTo","CodeMark","CodeInfo","first","textStart","textEnd","prevLineEnd","startContext","HorizontalRule","newBase","ListMark","ATXHeading","off","endOfSpace","after","buf","write","HeaderMark","parser","parseInline","node","ATXHeading1","HTMLBlock","trailing","nodeType","CommentBlock","ProcessingInstructionBlock","SetextHeading","LinkReferenceParser","leaf","stage","elts","advance","complete","addLeafElement","nextStage","parseLinkLabel","LinkMark","parseURL","skip","title","parseLinkTitle","titleEnd","lineEnd","SetextHeadingParser","underline","underlineMark","SetextHeading1","SetextHeading2","DefaultLeafBlocks","_","DefaultEndLeaf","p","scanLineResult","BlockContext","input","fragments","ranges","atEnd","dontInject","Set","stoppedAt","rangeI","absoluteLineStart","absoluteLineEnd","FragmentCursor","readLine","parsedPos","finishContext","mark","reuseFragment","blockParsers","parse","leafBlockParsers","lines","stop","endLeafBlock","finishLeaf","stopAt","RangeError","moveTo","matches","taken","takeNodes","withoutGaps","gapFrom","gapTo","moveRangeI","parentType","scanLine","r","lineChunkAt","textOffset","nextFrom","handler","skipContextMarkup","Error","chunk","lineChunks","eol","indexOf","startComposite","getNodeType","addElement","injectMarks","top","addGaps","injectGaps","topNode","inline","Paragraph","TreeElement","Buffer","offset","dont","has","rangeEnd","movePastNext","upto","inclusive","firstChild","nextSibling","propValues","MarkdownParser","blockNames","inlineParsers","inlineNames","wrappers","nodeTypes","Object","t","name","id","createParse","w","configure","spec","config","resolveConfig","nonEmpty","defineNodes","assign","styles","s","composite","style","some","group","define","props","Array","isArray","extend","remove","rm","parseBlock","found","before","findName","splice","endLeaf","wrap","InlineContext","outer","char","token","resolveMarkers","a","conf","conc","b","wrapA","wrapB","inner","names","Escape","nodes","writeTo","build","reused","topID","Element","startOff","EmphasisUnderscore","resolve","EmphasisAsterisk","LinkStart","ImageStart","InlineDelimiter","side","Escapable","Punctuation","RegExp","DefaultInline","escaped","append","Entity","exec","InlineCode","curSize","HTMLTag","url","URL","comment","Comment","procInst","ProcessingInstruction","Emphasis","pBefore","pAfter","sBefore","sAfter","leftFlanking","rightFlanking","canOpen","canClose","HardBreak","Link","Image","LinkEnd","parts","part","takeContent","link","finishLink","j","startPos","endPos","unshift","dest","label","LinkTitle","requireNonWS","min","LinkLabel","addDelimiter","open","close","emp","closeSize","k","element","keep","findOpeningDelimiter","startIndex","elements","eI","NotLast","fragment","fragmentEnd","cursor","nextFragment","read","c","rPos","parent","childAfter","cur","fragEnd","openEnd","blockI","prevEnd","prevI","isAnonymous","add","is","markdownHighlighting","quote","contentSeparator","heading1","heading2","heading3","heading4","heading5","heading6","escape","character","emphasis","strong","list","monospace","processingInstruction","labelName","string","keys","map","n","leftOverSpace","nextPos","parseCode","codeParser","htmlParser","info","infoNode","getChild","overlay","StrikethroughDelim","Strikethrough","strikethrough","parseRow","startI","cellStart","cellEnd","esc","parseCell","hasPipe","str","delimiterLine","TableParser","rows","lineText","firstRow","firstCount","Table","heading","TaskParser","TaskList","atom","GFM","parseSubSuper","Superscript","special","Subscript","Emoji","match"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/@lezer/markdown/dist/index.js"],"sourcesContent":["import { NodeType, NodeProp, NodeSet, Tree, Parser, parseMixed } from '@lezer/common';\nimport { styleTags, tags, Tag } from '@lezer/highlight';\n\nclass CompositeBlock {\n    constructor(type, \n    // Used for indentation in list items, markup character in lists\n    value, from, hash, end, children, positions) {\n        this.type = type;\n        this.value = value;\n        this.from = from;\n        this.hash = hash;\n        this.end = end;\n        this.children = children;\n        this.positions = positions;\n        this.hashProp = [[NodeProp.contextHash, hash]];\n    }\n    static create(type, value, from, parentHash, end) {\n        let hash = (parentHash + (parentHash << 8) + type + (value << 4)) | 0;\n        return new CompositeBlock(type, value, from, hash, end, [], []);\n    }\n    addChild(child, pos) {\n        if (child.prop(NodeProp.contextHash) != this.hash)\n            child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);\n        this.children.push(child);\n        this.positions.push(pos);\n    }\n    toTree(nodeSet, end = this.end) {\n        let last = this.children.length - 1;\n        if (last >= 0)\n            end = Math.max(end, this.positions[last] + this.children[last].length + this.from);\n        let tree = new Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({\n            makeTree: (children, positions, length) => new Tree(NodeType.none, children, positions, length, this.hashProp)\n        });\n        return tree;\n    }\n}\nvar Type;\n(function (Type) {\n    Type[Type[\"Document\"] = 1] = \"Document\";\n    Type[Type[\"CodeBlock\"] = 2] = \"CodeBlock\";\n    Type[Type[\"FencedCode\"] = 3] = \"FencedCode\";\n    Type[Type[\"Blockquote\"] = 4] = \"Blockquote\";\n    Type[Type[\"HorizontalRule\"] = 5] = \"HorizontalRule\";\n    Type[Type[\"BulletList\"] = 6] = \"BulletList\";\n    Type[Type[\"OrderedList\"] = 7] = \"OrderedList\";\n    Type[Type[\"ListItem\"] = 8] = \"ListItem\";\n    Type[Type[\"ATXHeading1\"] = 9] = \"ATXHeading1\";\n    Type[Type[\"ATXHeading2\"] = 10] = \"ATXHeading2\";\n    Type[Type[\"ATXHeading3\"] = 11] = \"ATXHeading3\";\n    Type[Type[\"ATXHeading4\"] = 12] = \"ATXHeading4\";\n    Type[Type[\"ATXHeading5\"] = 13] = \"ATXHeading5\";\n    Type[Type[\"ATXHeading6\"] = 14] = \"ATXHeading6\";\n    Type[Type[\"SetextHeading1\"] = 15] = \"SetextHeading1\";\n    Type[Type[\"SetextHeading2\"] = 16] = \"SetextHeading2\";\n    Type[Type[\"HTMLBlock\"] = 17] = \"HTMLBlock\";\n    Type[Type[\"LinkReference\"] = 18] = \"LinkReference\";\n    Type[Type[\"Paragraph\"] = 19] = \"Paragraph\";\n    Type[Type[\"CommentBlock\"] = 20] = \"CommentBlock\";\n    Type[Type[\"ProcessingInstructionBlock\"] = 21] = \"ProcessingInstructionBlock\";\n    // Inline\n    Type[Type[\"Escape\"] = 22] = \"Escape\";\n    Type[Type[\"Entity\"] = 23] = \"Entity\";\n    Type[Type[\"HardBreak\"] = 24] = \"HardBreak\";\n    Type[Type[\"Emphasis\"] = 25] = \"Emphasis\";\n    Type[Type[\"StrongEmphasis\"] = 26] = \"StrongEmphasis\";\n    Type[Type[\"Link\"] = 27] = \"Link\";\n    Type[Type[\"Image\"] = 28] = \"Image\";\n    Type[Type[\"InlineCode\"] = 29] = \"InlineCode\";\n    Type[Type[\"HTMLTag\"] = 30] = \"HTMLTag\";\n    Type[Type[\"Comment\"] = 31] = \"Comment\";\n    Type[Type[\"ProcessingInstruction\"] = 32] = \"ProcessingInstruction\";\n    Type[Type[\"URL\"] = 33] = \"URL\";\n    // Smaller tokens\n    Type[Type[\"HeaderMark\"] = 34] = \"HeaderMark\";\n    Type[Type[\"QuoteMark\"] = 35] = \"QuoteMark\";\n    Type[Type[\"ListMark\"] = 36] = \"ListMark\";\n    Type[Type[\"LinkMark\"] = 37] = \"LinkMark\";\n    Type[Type[\"EmphasisMark\"] = 38] = \"EmphasisMark\";\n    Type[Type[\"CodeMark\"] = 39] = \"CodeMark\";\n    Type[Type[\"CodeText\"] = 40] = \"CodeText\";\n    Type[Type[\"CodeInfo\"] = 41] = \"CodeInfo\";\n    Type[Type[\"LinkTitle\"] = 42] = \"LinkTitle\";\n    Type[Type[\"LinkLabel\"] = 43] = \"LinkLabel\";\n})(Type || (Type = {}));\n/// Data structure used to accumulate a block's content during [leaf\n/// block parsing](#BlockParser.leaf).\nclass LeafBlock {\n    /// @internal\n    constructor(\n    /// The start position of the block.\n    start, \n    /// The block's text content.\n    content) {\n        this.start = start;\n        this.content = content;\n        /// @internal\n        this.marks = [];\n        /// The block parsers active for this block.\n        this.parsers = [];\n    }\n}\n/// Data structure used during block-level per-line parsing.\nclass Line {\n    constructor() {\n        /// The line's full text.\n        this.text = \"\";\n        /// The base indent provided by the composite contexts (that have\n        /// been handled so far).\n        this.baseIndent = 0;\n        /// The string position corresponding to the base indent.\n        this.basePos = 0;\n        /// The number of contexts handled @internal\n        this.depth = 0;\n        /// Any markers (i.e. block quote markers) parsed for the contexts. @internal\n        this.markers = [];\n        /// The position of the next non-whitespace character beyond any\n        /// list, blockquote, or other composite block markers.\n        this.pos = 0;\n        /// The column of the next non-whitespace character.\n        this.indent = 0;\n        /// The character code of the character after `pos`.\n        this.next = -1;\n    }\n    /// @internal\n    forward() {\n        if (this.basePos > this.pos)\n            this.forwardInner();\n    }\n    /// @internal\n    forwardInner() {\n        let newPos = this.skipSpace(this.basePos);\n        this.indent = this.countIndent(newPos, this.pos, this.indent);\n        this.pos = newPos;\n        this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);\n    }\n    /// Skip whitespace after the given position, return the position of\n    /// the next non-space character or the end of the line if there's\n    /// only space after `from`.\n    skipSpace(from) { return skipSpace(this.text, from); }\n    /// @internal\n    reset(text) {\n        this.text = text;\n        this.baseIndent = this.basePos = this.pos = this.indent = 0;\n        this.forwardInner();\n        this.depth = 1;\n        while (this.markers.length)\n            this.markers.pop();\n    }\n    /// Move the line's base position forward to the given position.\n    /// This should only be called by composite [block\n    /// parsers](#BlockParser.parse) or [markup skipping\n    /// functions](#NodeSpec.composite).\n    moveBase(to) {\n        this.basePos = to;\n        this.baseIndent = this.countIndent(to, this.pos, this.indent);\n    }\n    /// Move the line's base position forward to the given _column_.\n    moveBaseColumn(indent) {\n        this.baseIndent = indent;\n        this.basePos = this.findColumn(indent);\n    }\n    /// Store a composite-block-level marker. Should be called from\n    /// [markup skipping functions](#NodeSpec.composite) when they\n    /// consume any non-whitespace characters.\n    addMarker(elt) {\n        this.markers.push(elt);\n    }\n    /// Find the column position at `to`, optionally starting at a given\n    /// position and column.\n    countIndent(to, from = 0, indent = 0) {\n        for (let i = from; i < to; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return indent;\n    }\n    /// Find the position corresponding to the given column.\n    findColumn(goal) {\n        let i = 0;\n        for (let indent = 0; i < this.text.length && indent < goal; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return i;\n    }\n    /// @internal\n    scrub() {\n        if (!this.baseIndent)\n            return this.text;\n        let result = \"\";\n        for (let i = 0; i < this.basePos; i++)\n            result += \" \";\n        return result + this.text.slice(this.basePos);\n    }\n}\nfunction skipForList(bl, cx, line) {\n    if (line.pos == line.text.length ||\n        (bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent))\n        return true;\n    if (line.indent >= line.baseIndent + 4)\n        return false;\n    let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);\n    return size > 0 &&\n        (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) &&\n        line.text.charCodeAt(line.pos + size - 1) == bl.value;\n}\nconst DefaultSkipMarkup = {\n    [Type.Blockquote](bl, cx, line) {\n        if (line.next != 62 /* '>' */)\n            return false;\n        line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));\n        line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));\n        bl.end = cx.lineStart + line.text.length;\n        return true;\n    },\n    [Type.ListItem](bl, _cx, line) {\n        if (line.indent < line.baseIndent + bl.value && line.next > -1)\n            return false;\n        line.moveBaseColumn(line.baseIndent + bl.value);\n        return true;\n    },\n    [Type.OrderedList]: skipForList,\n    [Type.BulletList]: skipForList,\n    [Type.Document]() { return true; }\n};\nfunction space(ch) { return ch == 32 || ch == 9 || ch == 10 || ch == 13; }\nfunction skipSpace(line, i = 0) {\n    while (i < line.length && space(line.charCodeAt(i)))\n        i++;\n    return i;\n}\nfunction skipSpaceBack(line, i, to) {\n    while (i > to && space(line.charCodeAt(i - 1)))\n        i--;\n    return i;\n}\nfunction isFencedCode(line) {\n    if (line.next != 96 && line.next != 126 /* '`~' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    if (pos < line.pos + 3)\n        return -1;\n    if (line.next == 96)\n        for (let i = pos; i < line.text.length; i++)\n            if (line.text.charCodeAt(i) == 96)\n                return -1;\n    return pos;\n}\nfunction isBlockquote(line) {\n    return line.next != 62 /* '>' */ ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;\n}\nfunction isHorizontalRule(line, cx, breaking) {\n    if (line.next != 42 && line.next != 45 && line.next != 95 /* '_-*' */)\n        return -1;\n    let count = 1;\n    for (let pos = line.pos + 1; pos < line.text.length; pos++) {\n        let ch = line.text.charCodeAt(pos);\n        if (ch == line.next)\n            count++;\n        else if (!space(ch))\n            return -1;\n    }\n    // Setext headers take precedence\n    if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length)\n        return -1;\n    return count < 3 ? -1 : 1;\n}\nfunction inList(cx, type) {\n    for (let i = cx.stack.length - 1; i >= 0; i--)\n        if (cx.stack[i].type == type)\n            return true;\n    return false;\n}\nfunction isBulletList(line, cx, breaking) {\n    return (line.next == 45 || line.next == 43 || line.next == 42 /* '-+*' */) &&\n        (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) &&\n        (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;\n}\nfunction isOrderedList(line, cx, breaking) {\n    let pos = line.pos, next = line.next;\n    for (;;) {\n        if (next >= 48 && next <= 57 /* '0-9' */)\n            pos++;\n        else\n            break;\n        if (pos == line.text.length)\n            return -1;\n        next = line.text.charCodeAt(pos);\n    }\n    if (pos == line.pos || pos > line.pos + 9 ||\n        (next != 46 && next != 41 /* '.)' */) ||\n        (pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1))) ||\n        breaking && !inList(cx, Type.OrderedList) &&\n            (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49 /* '1' */))\n        return -1;\n    return pos + 1 - line.pos;\n}\nfunction isAtxHeading(line) {\n    if (line.next != 35 /* '#' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == 35)\n        pos++;\n    if (pos < line.text.length && line.text.charCodeAt(pos) != 32)\n        return -1;\n    let size = pos - line.pos;\n    return size > 6 ? -1 : size;\n}\nfunction isSetextUnderline(line) {\n    if (line.next != 45 && line.next != 61 /* '-=' */ || line.indent >= line.baseIndent + 4)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    let end = pos;\n    while (pos < line.text.length && space(line.text.charCodeAt(pos)))\n        pos++;\n    return pos == line.text.length ? end : -1;\n}\nconst EmptyLine = /^[ \\t]*$/, CommentEnd = /-->/, ProcessingEnd = /\\?>/;\nconst HTMLBlockStyle = [\n    [/^<(?:script|pre|style)(?:\\s|>|$)/i, /<\\/(?:script|pre|style)>/i],\n    [/^\\s*<!--/, CommentEnd],\n    [/^\\s*<\\?/, ProcessingEnd],\n    [/^\\s*<![A-Z]/, />/],\n    [/^\\s*<!\\[CDATA\\[/, /\\]\\]>/],\n    [/^\\s*<\\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|\\/?>|$)/i, EmptyLine],\n    [/^\\s*(?:<\\/[a-z][\\w-]*\\s*>|<[a-z][\\w-]*(\\s+[a-z:_][\\w-.]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*>)\\s*$/i, EmptyLine]\n];\nfunction isHTMLBlock(line, _cx, breaking) {\n    if (line.next != 60 /* '<' */)\n        return -1;\n    let rest = line.text.slice(line.pos);\n    for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++)\n        if (HTMLBlockStyle[i][0].test(rest))\n            return i;\n    return -1;\n}\nfunction getListIndent(line, pos) {\n    let indentAfter = line.countIndent(pos, line.pos, line.indent);\n    let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);\n    return indented >= indentAfter + 5 ? indentAfter + 1 : indented;\n}\nfunction addCodeText(marks, from, to) {\n    let last = marks.length - 1;\n    if (last >= 0 && marks[last].to == from && marks[last].type == Type.CodeText)\n        marks[last].to = to;\n    else\n        marks.push(elt(Type.CodeText, from, to));\n}\n// Rules for parsing blocks. A return value of false means the rule\n// doesn't apply here, true means it does. When true is returned and\n// `p.line` has been updated, the rule is assumed to have consumed a\n// leaf block. Otherwise, it is assumed to have opened a context.\nconst DefaultBlockParsers = {\n    LinkReference: undefined,\n    IndentedCode(cx, line) {\n        let base = line.baseIndent + 4;\n        if (line.indent < base)\n            return false;\n        let start = line.findColumn(base);\n        let from = cx.lineStart + start, to = cx.lineStart + line.text.length;\n        let marks = [], pendingMarks = [];\n        addCodeText(marks, from, to);\n        while (cx.nextLine() && line.depth >= cx.stack.length) {\n            if (line.pos == line.text.length) { // Empty\n                addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    pendingMarks.push(m);\n            }\n            else if (line.indent < base) {\n                break;\n            }\n            else {\n                if (pendingMarks.length) {\n                    for (let m of pendingMarks) {\n                        if (m.type == Type.CodeText)\n                            addCodeText(marks, m.from, m.to);\n                        else\n                            marks.push(m);\n                    }\n                    pendingMarks = [];\n                }\n                addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                to = cx.lineStart + line.text.length;\n                let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);\n                if (codeStart < to)\n                    addCodeText(marks, codeStart, to);\n            }\n        }\n        if (pendingMarks.length) {\n            pendingMarks = pendingMarks.filter(m => m.type != Type.CodeText);\n            if (pendingMarks.length)\n                line.markers = pendingMarks.concat(line.markers);\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);\n        return true;\n    },\n    FencedCode(cx, line) {\n        let fenceEnd = isFencedCode(line);\n        if (fenceEnd < 0)\n            return false;\n        let from = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;\n        let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);\n        let marks = [elt(Type.CodeMark, from, from + len)];\n        if (infoFrom < infoTo)\n            marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));\n        for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {\n            let i = line.pos;\n            if (line.indent - line.baseIndent < 4)\n                while (i < line.text.length && line.text.charCodeAt(i) == ch)\n                    i++;\n            if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {\n                for (let m of line.markers)\n                    marks.push(m);\n                marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));\n                cx.nextLine();\n                break;\n            }\n            else {\n                if (!first)\n                    addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;\n                if (textStart < textEnd)\n                    addCodeText(marks, textStart, textEnd);\n            }\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from)\n            .finish(Type.FencedCode, cx.prevLineEnd() - from), from);\n        return true;\n    },\n    Blockquote(cx, line) {\n        let size = isBlockquote(line);\n        if (size < 0)\n            return false;\n        cx.startContext(Type.Blockquote, line.pos);\n        cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);\n        line.moveBase(line.pos + size);\n        return null;\n    },\n    HorizontalRule(cx, line) {\n        if (isHorizontalRule(line, cx, false) < 0)\n            return false;\n        let from = cx.lineStart + line.pos;\n        cx.nextLine();\n        cx.addNode(Type.HorizontalRule, from);\n        return true;\n    },\n    BulletList(cx, line) {\n        let size = isBulletList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.BulletList)\n            cx.startContext(Type.BulletList, line.basePos, line.next);\n        let newBase = getListIndent(line, line.pos + 1);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    OrderedList(cx, line) {\n        let size = isOrderedList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.OrderedList)\n            cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));\n        let newBase = getListIndent(line, line.pos + size);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    ATXHeading(cx, line) {\n        let size = isAtxHeading(line);\n        if (size < 0)\n            return false;\n        let off = line.pos, from = cx.lineStart + off;\n        let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;\n        while (after > off && line.text.charCodeAt(after - 1) == line.next)\n            after--;\n        if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1)))\n            after = line.text.length;\n        let buf = cx.buffer\n            .write(Type.HeaderMark, 0, size)\n            .writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);\n        if (after < line.text.length)\n            buf.write(Type.HeaderMark, after - off, endOfSpace - off);\n        let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);\n        cx.nextLine();\n        cx.addNode(node, from);\n        return true;\n    },\n    HTMLBlock(cx, line) {\n        let type = isHTMLBlock(line, cx, false);\n        if (type < 0)\n            return false;\n        let from = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];\n        let marks = [], trailing = end != EmptyLine;\n        while (!end.test(line.text) && cx.nextLine()) {\n            if (line.depth < cx.stack.length) {\n                trailing = false;\n                break;\n            }\n            for (let m of line.markers)\n                marks.push(m);\n        }\n        if (trailing)\n            cx.nextLine();\n        let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;\n        let to = cx.prevLineEnd();\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);\n        return true;\n    },\n    SetextHeading: undefined // Specifies relative precedence for block-continue function\n};\n// This implements a state machine that incrementally parses link references. At each\n// next line, it looks ahead to see if the line continues the reference or not. If it\n// doesn't and a valid link is available ending before that line, it finishes that.\n// Similarly, on `finish` (when the leaf is terminated by external circumstances), it\n// creates a link reference if there's a valid reference up to the current point.\nclass LinkReferenceParser {\n    constructor(leaf) {\n        this.stage = 0 /* Start */;\n        this.elts = [];\n        this.pos = 0;\n        this.start = leaf.start;\n        this.advance(leaf.content);\n    }\n    nextLine(cx, line, leaf) {\n        if (this.stage == -1 /* Failed */)\n            return false;\n        let content = leaf.content + \"\\n\" + line.scrub();\n        let finish = this.advance(content);\n        if (finish > -1 && finish < content.length)\n            return this.complete(cx, leaf, finish);\n        return false;\n    }\n    finish(cx, leaf) {\n        if ((this.stage == 2 /* Link */ || this.stage == 3 /* Title */) && skipSpace(leaf.content, this.pos) == leaf.content.length)\n            return this.complete(cx, leaf, leaf.content.length);\n        return false;\n    }\n    complete(cx, leaf, len) {\n        cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));\n        return true;\n    }\n    nextStage(elt) {\n        if (elt) {\n            this.pos = elt.to - this.start;\n            this.elts.push(elt);\n            this.stage++;\n            return true;\n        }\n        if (elt === false)\n            this.stage = -1 /* Failed */;\n        return false;\n    }\n    advance(content) {\n        for (;;) {\n            if (this.stage == -1 /* Failed */) {\n                return -1;\n            }\n            else if (this.stage == 0 /* Start */) {\n                if (!this.nextStage(parseLinkLabel(content, this.pos, this.start, true)))\n                    return -1;\n                if (content.charCodeAt(this.pos) != 58 /* ':' */)\n                    return this.stage = -1 /* Failed */;\n                this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));\n                this.pos++;\n            }\n            else if (this.stage == 1 /* Label */) {\n                if (!this.nextStage(parseURL(content, skipSpace(content, this.pos), this.start)))\n                    return -1;\n            }\n            else if (this.stage == 2 /* Link */) {\n                let skip = skipSpace(content, this.pos), end = 0;\n                if (skip > this.pos) {\n                    let title = parseLinkTitle(content, skip, this.start);\n                    if (title) {\n                        let titleEnd = lineEnd(content, title.to - this.start);\n                        if (titleEnd > 0) {\n                            this.nextStage(title);\n                            end = titleEnd;\n                        }\n                    }\n                }\n                if (!end)\n                    end = lineEnd(content, this.pos);\n                return end > 0 && end < content.length ? end : -1;\n            }\n            else { // RefStage.Title\n                return lineEnd(content, this.pos);\n            }\n        }\n    }\n}\nfunction lineEnd(text, pos) {\n    for (; pos < text.length; pos++) {\n        let next = text.charCodeAt(pos);\n        if (next == 10)\n            break;\n        if (!space(next))\n            return -1;\n    }\n    return pos;\n}\nclass SetextHeadingParser {\n    nextLine(cx, line, leaf) {\n        let underline = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);\n        let next = line.next;\n        if (underline < 0)\n            return false;\n        let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline);\n        cx.nextLine();\n        cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [\n            ...cx.parser.parseInline(leaf.content, leaf.start),\n            underlineMark\n        ]));\n        return true;\n    }\n    finish() {\n        return false;\n    }\n}\nconst DefaultLeafBlocks = {\n    LinkReference(_, leaf) { return leaf.content.charCodeAt(0) == 91 /* '[' */ ? new LinkReferenceParser(leaf) : null; },\n    SetextHeading() { return new SetextHeadingParser; }\n};\nconst DefaultEndLeaf = [\n    (_, line) => isAtxHeading(line) >= 0,\n    (_, line) => isFencedCode(line) >= 0,\n    (_, line) => isBlockquote(line) >= 0,\n    (p, line) => isBulletList(line, p, true) >= 0,\n    (p, line) => isOrderedList(line, p, true) >= 0,\n    (p, line) => isHorizontalRule(line, p, true) >= 0,\n    (p, line) => isHTMLBlock(line, p, true) >= 0\n];\nconst scanLineResult = { text: \"\", end: 0 };\n/// Block-level parsing functions get access to this context object.\nclass BlockContext {\n    /// @internal\n    constructor(\n    /// The parser configuration used.\n    parser, \n    /// @internal\n    input, fragments, \n    /// @internal\n    ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.line = new Line();\n        this.atEnd = false;\n        /// @internal\n        this.dontInject = new Set;\n        this.stoppedAt = null;\n        /// The range index that absoluteLineStart points into @internal\n        this.rangeI = 0;\n        this.to = ranges[ranges.length - 1].to;\n        this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;\n        this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);\n        this.stack = [this.block];\n        this.fragments = fragments.length ? new FragmentCursor(fragments, input) : null;\n        this.readLine();\n    }\n    get parsedPos() {\n        return this.absoluteLineStart;\n    }\n    advance() {\n        if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)\n            return this.finish();\n        let { line } = this;\n        for (;;) {\n            while (line.depth < this.stack.length)\n                this.finishContext();\n            for (let mark of line.markers)\n                this.addNode(mark.type, mark.from, mark.to);\n            if (line.pos < line.text.length)\n                break;\n            // Empty line\n            if (!this.nextLine())\n                return this.finish();\n        }\n        if (this.fragments && this.reuseFragment(line.basePos))\n            return null;\n        start: for (;;) {\n            for (let type of this.parser.blockParsers)\n                if (type) {\n                    let result = type(this, line);\n                    if (result != false) {\n                        if (result == true)\n                            return null;\n                        line.forward();\n                        continue start;\n                    }\n                }\n            break;\n        }\n        let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));\n        for (let parse of this.parser.leafBlockParsers)\n            if (parse) {\n                let parser = parse(this, leaf);\n                if (parser)\n                    leaf.parsers.push(parser);\n            }\n        lines: while (this.nextLine()) {\n            if (line.pos == line.text.length)\n                break;\n            if (line.indent < line.baseIndent + 4) {\n                for (let stop of this.parser.endLeafBlock)\n                    if (stop(this, line, leaf))\n                        break lines;\n            }\n            for (let parser of leaf.parsers)\n                if (parser.nextLine(this, line, leaf))\n                    return null;\n            leaf.content += \"\\n\" + line.scrub();\n            for (let m of line.markers)\n                leaf.marks.push(m);\n        }\n        this.finishLeaf(leaf);\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    reuseFragment(start) {\n        if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) ||\n            !this.fragments.matches(this.block.hash))\n            return false;\n        let taken = this.fragments.takeNodes(this);\n        if (!taken)\n            return false;\n        let withoutGaps = taken, end = this.absoluteLineStart + taken;\n        for (let i = 1; i < this.ranges.length; i++) {\n            let gapFrom = this.ranges[i - 1].to, gapTo = this.ranges[i].from;\n            if (gapFrom >= this.lineStart && gapTo < end)\n                withoutGaps -= gapTo - gapFrom;\n        }\n        this.lineStart += withoutGaps;\n        this.absoluteLineStart += taken;\n        this.moveRangeI();\n        if (this.absoluteLineStart < this.to) {\n            this.lineStart++;\n            this.absoluteLineStart++;\n            this.readLine();\n        }\n        else {\n            this.atEnd = true;\n            this.readLine();\n        }\n        return true;\n    }\n    /// The number of parent blocks surrounding the current block.\n    get depth() {\n        return this.stack.length;\n    }\n    /// Get the type of the parent block at the given depth. When no\n    /// depth is passed, return the type of the innermost parent.\n    parentType(depth = this.depth - 1) {\n        return this.parser.nodeSet.types[this.stack[depth].type];\n    }\n    /// Move to the next input line. This should only be called by\n    /// (non-composite) [block parsers](#BlockParser.parse) that consume\n    /// the line directly, or leaf block parser\n    /// [`nextLine`](#LeafBlockParser.nextLine) methods when they\n    /// consume the current line (and return true).\n    nextLine() {\n        this.lineStart += this.line.text.length;\n        if (this.absoluteLineEnd >= this.to) {\n            this.absoluteLineStart = this.absoluteLineEnd;\n            this.atEnd = true;\n            this.readLine();\n            return false;\n        }\n        else {\n            this.lineStart++;\n            this.absoluteLineStart = this.absoluteLineEnd + 1;\n            this.moveRangeI();\n            this.readLine();\n            return true;\n        }\n    }\n    moveRangeI() {\n        while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to) {\n            this.rangeI++;\n            this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);\n        }\n    }\n    /// @internal\n    scanLine(start) {\n        let r = scanLineResult;\n        r.end = start;\n        if (start >= this.to) {\n            r.text = \"\";\n        }\n        else {\n            r.text = this.lineChunkAt(start);\n            r.end += r.text.length;\n            if (this.ranges.length > 1) {\n                let textOffset = this.absoluteLineStart, rangeI = this.rangeI;\n                while (this.ranges[rangeI].to < r.end) {\n                    rangeI++;\n                    let nextFrom = this.ranges[rangeI].from;\n                    let after = this.lineChunkAt(nextFrom);\n                    r.end = nextFrom + after.length;\n                    r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;\n                    textOffset = r.end - r.text.length;\n                }\n            }\n        }\n        return r;\n    }\n    /// @internal\n    readLine() {\n        let { line } = this, { text, end } = this.scanLine(this.absoluteLineStart);\n        this.absoluteLineEnd = end;\n        line.reset(text);\n        for (; line.depth < this.stack.length; line.depth++) {\n            let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];\n            if (!handler)\n                throw new Error(\"Unhandled block context \" + Type[cx.type]);\n            if (!handler(cx, this, line))\n                break;\n            line.forward();\n        }\n    }\n    lineChunkAt(pos) {\n        let next = this.input.chunk(pos), text;\n        if (!this.input.lineChunks) {\n            let eol = next.indexOf(\"\\n\");\n            text = eol < 0 ? next : next.slice(0, eol);\n        }\n        else {\n            text = next == \"\\n\" ? \"\" : next;\n        }\n        return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;\n    }\n    /// The end position of the previous line.\n    prevLineEnd() { return this.atEnd ? this.lineStart : this.lineStart - 1; }\n    /// @internal\n    startContext(type, start, value = 0) {\n        this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);\n        this.stack.push(this.block);\n    }\n    /// Start a composite block. Should only be called from [block\n    /// parser functions](#BlockParser.parse) that return null.\n    startComposite(type, start, value = 0) {\n        this.startContext(this.parser.getNodeType(type), start, value);\n    }\n    /// @internal\n    addNode(block, from, to) {\n        if (typeof block == \"number\")\n            block = new Tree(this.parser.nodeSet.types[block], none, none, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);\n        this.block.addChild(block, from - this.block.from);\n    }\n    /// Add a block element. Can be called by [block\n    /// parsers](#BlockParser.parse).\n    addElement(elt) {\n        this.block.addChild(elt.toTree(this.parser.nodeSet), elt.from - this.block.from);\n    }\n    /// Add a block element from a [leaf parser](#LeafBlockParser). This\n    /// makes sure any extra composite block markup (such as blockquote\n    /// markers) inside the block are also added to the syntax tree.\n    addLeafElement(leaf, elt) {\n        this.addNode(this.buffer\n            .writeElements(injectMarks(elt.children, leaf.marks), -elt.from)\n            .finish(elt.type, elt.to - elt.from), elt.from);\n    }\n    /// @internal\n    finishContext() {\n        let cx = this.stack.pop();\n        let top = this.stack[this.stack.length - 1];\n        top.addChild(cx.toTree(this.parser.nodeSet), cx.from - top.from);\n        this.block = top;\n    }\n    finish() {\n        while (this.stack.length > 1)\n            this.finishContext();\n        return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));\n    }\n    addGaps(tree) {\n        return this.ranges.length > 1 ? injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.dontInject) : tree;\n    }\n    /// @internal\n    finishLeaf(leaf) {\n        for (let parser of leaf.parsers)\n            if (parser.finish(this, leaf))\n                return;\n        let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);\n        this.addNode(this.buffer\n            .writeElements(inline, -leaf.start)\n            .finish(Type.Paragraph, leaf.content.length), leaf.start);\n    }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n    /// @internal\n    get buffer() { return new Buffer(this.parser.nodeSet); }\n}\nfunction injectGaps(ranges, rangeI, tree, offset, dont) {\n    if (dont.has(tree.tree))\n        return tree.tree;\n    let rangeEnd = ranges[rangeI].to;\n    let children = [], positions = [], start = tree.from + offset;\n    function movePastNext(upto, inclusive) {\n        while (inclusive ? upto >= rangeEnd : upto > rangeEnd) {\n            let size = ranges[rangeI + 1].from - rangeEnd;\n            offset += size;\n            upto += size;\n            rangeI++;\n            rangeEnd = ranges[rangeI].to;\n        }\n    }\n    for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {\n        movePastNext(ch.from + offset, true);\n        let from = ch.from + offset, node;\n        if (ch.to + offset > rangeEnd) {\n            node = injectGaps(ranges, rangeI, ch, offset, dont);\n            movePastNext(ch.to + offset, false);\n        }\n        else {\n            node = ch.toTree();\n        }\n        children.push(node);\n        positions.push(from - start);\n    }\n    movePastNext(tree.to + offset, false);\n    return new Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : undefined);\n}\n/// A Markdown parser configuration.\nclass MarkdownParser extends Parser {\n    /// @internal\n    constructor(\n    /// The parser's syntax [node\n    /// types](https://lezer.codemirror.net/docs/ref/#common.NodeSet).\n    nodeSet, \n    /// @internal\n    blockParsers, \n    /// @internal\n    leafBlockParsers, \n    /// @internal\n    blockNames, \n    /// @internal\n    endLeafBlock, \n    /// @internal\n    skipContextMarkup, \n    /// @internal\n    inlineParsers, \n    /// @internal\n    inlineNames, \n    /// @internal\n    wrappers) {\n        super();\n        this.nodeSet = nodeSet;\n        this.blockParsers = blockParsers;\n        this.leafBlockParsers = leafBlockParsers;\n        this.blockNames = blockNames;\n        this.endLeafBlock = endLeafBlock;\n        this.skipContextMarkup = skipContextMarkup;\n        this.inlineParsers = inlineParsers;\n        this.inlineNames = inlineNames;\n        this.wrappers = wrappers;\n        /// @internal\n        this.nodeTypes = Object.create(null);\n        for (let t of nodeSet.types)\n            this.nodeTypes[t.name] = t.id;\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new BlockContext(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /// Reconfigure the parser.\n    configure(spec) {\n        let config = resolveConfig(spec);\n        if (!config)\n            return this;\n        let { nodeSet, skipContextMarkup } = this;\n        let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;\n        if (nonEmpty(config.defineNodes)) {\n            skipContextMarkup = Object.assign({}, skipContextMarkup);\n            let nodeTypes = nodeSet.types.slice(), styles;\n            for (let s of config.defineNodes) {\n                let { name, block, composite, style } = typeof s == \"string\" ? { name: s } : s;\n                if (nodeTypes.some(t => t.name == name))\n                    continue;\n                if (composite)\n                    skipContextMarkup[nodeTypes.length] =\n                        (bl, cx, line) => composite(cx, line, bl.value);\n                let id = nodeTypes.length;\n                let group = composite ? [\"Block\", \"BlockContext\"] : !block ? undefined\n                    : id >= Type.ATXHeading1 && id <= Type.SetextHeading2 ? [\"Block\", \"LeafBlock\", \"Heading\"] : [\"Block\", \"LeafBlock\"];\n                nodeTypes.push(NodeType.define({\n                    id,\n                    name,\n                    props: group && [[NodeProp.group, group]]\n                }));\n                if (style) {\n                    if (!styles)\n                        styles = {};\n                    if (Array.isArray(style) || style instanceof Tag)\n                        styles[name] = style;\n                    else\n                        Object.assign(styles, style);\n                }\n            }\n            nodeSet = new NodeSet(nodeTypes);\n            if (styles)\n                nodeSet = nodeSet.extend(styleTags(styles));\n        }\n        if (nonEmpty(config.props))\n            nodeSet = nodeSet.extend(...config.props);\n        if (nonEmpty(config.remove)) {\n            for (let rm of config.remove) {\n                let block = this.blockNames.indexOf(rm), inline = this.inlineNames.indexOf(rm);\n                if (block > -1)\n                    blockParsers[block] = leafBlockParsers[block] = undefined;\n                if (inline > -1)\n                    inlineParsers[inline] = undefined;\n            }\n        }\n        if (nonEmpty(config.parseBlock)) {\n            for (let spec of config.parseBlock) {\n                let found = blockNames.indexOf(spec.name);\n                if (found > -1) {\n                    blockParsers[found] = spec.parse;\n                    leafBlockParsers[found] = spec.leaf;\n                }\n                else {\n                    let pos = spec.before ? findName(blockNames, spec.before)\n                        : spec.after ? findName(blockNames, spec.after) + 1 : blockNames.length - 1;\n                    blockParsers.splice(pos, 0, spec.parse);\n                    leafBlockParsers.splice(pos, 0, spec.leaf);\n                    blockNames.splice(pos, 0, spec.name);\n                }\n                if (spec.endLeaf)\n                    endLeafBlock.push(spec.endLeaf);\n            }\n        }\n        if (nonEmpty(config.parseInline)) {\n            for (let spec of config.parseInline) {\n                let found = inlineNames.indexOf(spec.name);\n                if (found > -1) {\n                    inlineParsers[found] = spec.parse;\n                }\n                else {\n                    let pos = spec.before ? findName(inlineNames, spec.before)\n                        : spec.after ? findName(inlineNames, spec.after) + 1 : inlineNames.length - 1;\n                    inlineParsers.splice(pos, 0, spec.parse);\n                    inlineNames.splice(pos, 0, spec.name);\n                }\n            }\n        }\n        if (config.wrap)\n            wrappers = wrappers.concat(config.wrap);\n        return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);\n    }\n    /// @internal\n    getNodeType(name) {\n        let found = this.nodeTypes[name];\n        if (found == null)\n            throw new RangeError(`Unknown node type '${name}'`);\n        return found;\n    }\n    /// Parse the given piece of inline text at the given offset,\n    /// returning an array of [`Element`](#Element) objects representing\n    /// the inline content.\n    parseInline(text, offset) {\n        let cx = new InlineContext(this, text, offset);\n        outer: for (let pos = offset; pos < cx.end;) {\n            let next = cx.char(pos);\n            for (let token of this.inlineParsers)\n                if (token) {\n                    let result = token(cx, next, pos);\n                    if (result >= 0) {\n                        pos = result;\n                        continue outer;\n                    }\n                }\n            pos++;\n        }\n        return cx.resolveMarkers(0);\n    }\n}\nfunction nonEmpty(a) {\n    return a != null && a.length > 0;\n}\nfunction resolveConfig(spec) {\n    if (!Array.isArray(spec))\n        return spec;\n    if (spec.length == 0)\n        return null;\n    let conf = resolveConfig(spec[0]);\n    if (spec.length == 1)\n        return conf;\n    let rest = resolveConfig(spec.slice(1));\n    if (!rest || !conf)\n        return conf || rest;\n    let conc = (a, b) => (a || none).concat(b || none);\n    let wrapA = conf.wrap, wrapB = rest.wrap;\n    return {\n        props: conc(conf.props, rest.props),\n        defineNodes: conc(conf.defineNodes, rest.defineNodes),\n        parseBlock: conc(conf.parseBlock, rest.parseBlock),\n        parseInline: conc(conf.parseInline, rest.parseInline),\n        remove: conc(conf.remove, rest.remove),\n        wrap: !wrapA ? wrapB : !wrapB ? wrapA :\n            (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)\n    };\n}\nfunction findName(names, name) {\n    let found = names.indexOf(name);\n    if (found < 0)\n        throw new RangeError(`Position specified relative to unknown parser ${name}`);\n    return found;\n}\nlet nodeTypes = [NodeType.none];\nfor (let i = 1, name; name = Type[i]; i++) {\n    nodeTypes[i] = NodeType.define({\n        id: i,\n        name,\n        props: i >= Type.Escape ? [] : [[NodeProp.group, i in DefaultSkipMarkup ? [\"Block\", \"BlockContext\"] : [\"Block\", \"LeafBlock\"]]]\n    });\n}\nconst none = [];\nclass Buffer {\n    constructor(nodeSet) {\n        this.nodeSet = nodeSet;\n        this.content = [];\n        this.nodes = [];\n    }\n    write(type, from, to, children = 0) {\n        this.content.push(type, from, to, 4 + children * 4);\n        return this;\n    }\n    writeElements(elts, offset = 0) {\n        for (let e of elts)\n            e.writeTo(this, offset);\n        return this;\n    }\n    finish(type, length) {\n        return Tree.build({\n            buffer: this.content,\n            nodeSet: this.nodeSet,\n            reused: this.nodes,\n            topID: type,\n            length\n        });\n    }\n}\n/// Elements are used to compose syntax nodes during parsing.\nclass Element {\n    /// @internal\n    constructor(\n    /// The node's\n    /// [id](https://lezer.codemirror.net/docs/ref/#common.NodeType.id).\n    type, \n    /// The start of the node, as an offset from the start of the document.\n    from, \n    /// The end of the node.\n    to, \n    /// The node's child nodes @internal\n    children = none) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.children = children;\n    }\n    /// @internal\n    writeTo(buf, offset) {\n        let startOff = buf.content.length;\n        buf.writeElements(this.children, offset);\n        buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);\n    }\n    /// @internal\n    toTree(nodeSet) {\n        return new Buffer(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);\n    }\n}\nclass TreeElement {\n    constructor(tree, from) {\n        this.tree = tree;\n        this.from = from;\n    }\n    get to() { return this.from + this.tree.length; }\n    get type() { return this.tree.type.id; }\n    get children() { return none; }\n    writeTo(buf, offset) {\n        buf.nodes.push(this.tree);\n        buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);\n    }\n    toTree() { return this.tree; }\n}\nfunction elt(type, from, to, children) {\n    return new Element(type, from, to, children);\n}\nconst EmphasisUnderscore = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst EmphasisAsterisk = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst LinkStart = {}, ImageStart = {};\nclass InlineDelimiter {\n    constructor(type, from, to, side) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.side = side;\n    }\n}\nconst Escapable = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\nlet Punctuation = /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~\\xA1\\u2010-\\u2027]/;\ntry {\n    Punctuation = new RegExp(\"[\\\\p{Pc}|\\\\p{Pd}|\\\\p{Pe}|\\\\p{Pf}|\\\\p{Pi}|\\\\p{Po}|\\\\p{Ps}]\", \"u\");\n}\ncatch (_) { }\nconst DefaultInline = {\n    Escape(cx, next, start) {\n        if (next != 92 /* '\\\\' */ || start == cx.end - 1)\n            return -1;\n        let escaped = cx.char(start + 1);\n        for (let i = 0; i < Escapable.length; i++)\n            if (Escapable.charCodeAt(i) == escaped)\n                return cx.append(elt(Type.Escape, start, start + 2));\n        return -1;\n    },\n    Entity(cx, next, start) {\n        if (next != 38 /* '&' */)\n            return -1;\n        let m = /^(?:#\\d+|#x[a-f\\d]+|\\w+);/i.exec(cx.slice(start + 1, start + 31));\n        return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1;\n    },\n    InlineCode(cx, next, start) {\n        if (next != 96 /* '`' */ || start && cx.char(start - 1) == 96)\n            return -1;\n        let pos = start + 1;\n        while (pos < cx.end && cx.char(pos) == 96)\n            pos++;\n        let size = pos - start, curSize = 0;\n        for (; pos < cx.end; pos++) {\n            if (cx.char(pos) == 96) {\n                curSize++;\n                if (curSize == size && cx.char(pos + 1) != 96)\n                    return cx.append(elt(Type.InlineCode, start, pos + 1, [\n                        elt(Type.CodeMark, start, start + size),\n                        elt(Type.CodeMark, pos + 1 - size, pos + 1)\n                    ]));\n            }\n            else {\n                curSize = 0;\n            }\n        }\n        return -1;\n    },\n    HTMLTag(cx, next, start) {\n        if (next != 60 /* '<' */ || start == cx.end - 1)\n            return -1;\n        let after = cx.slice(start + 1, cx.end);\n        let url = /^(?:[a-z][-\\w+.]+:[^\\s>]+|[a-z\\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?(?:\\.[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?)*)>/i.exec(after);\n        if (url)\n            return cx.append(elt(Type.URL, start, start + 1 + url[0].length));\n        let comment = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);\n        if (comment)\n            return cx.append(elt(Type.Comment, start, start + 1 + comment[0].length));\n        let procInst = /^\\?[^]*?\\?>/.exec(after);\n        if (procInst)\n            return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));\n        let m = /^(?:![A-Z][^]*?>|!\\[CDATA\\[[^]*?\\]\\]>|\\/\\s*[a-zA-Z][\\w-]*\\s*>|\\s*[a-zA-Z][\\w-]*(\\s+[a-zA-Z:_][\\w-.:]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*(\\/\\s*)?>)/.exec(after);\n        if (!m)\n            return -1;\n        return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length));\n    },\n    Emphasis(cx, next, start) {\n        if (next != 95 && next != 42)\n            return -1;\n        let pos = start + 1;\n        while (cx.char(pos) == next)\n            pos++;\n        let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);\n        let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n        let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n        let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);\n        let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);\n        let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);\n        let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);\n        return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 /* Open */ : 0) | (canClose ? 2 /* Close */ : 0)));\n    },\n    HardBreak(cx, next, start) {\n        if (next == 92 /* '\\\\' */ && cx.char(start + 1) == 10 /* '\\n' */)\n            return cx.append(elt(Type.HardBreak, start, start + 2));\n        if (next == 32) {\n            let pos = start + 1;\n            while (cx.char(pos) == 32)\n                pos++;\n            if (cx.char(pos) == 10 && pos >= start + 2)\n                return cx.append(elt(Type.HardBreak, start, pos + 1));\n        }\n        return -1;\n    },\n    Link(cx, next, start) {\n        return next == 91 /* '[' */ ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, 1 /* Open */)) : -1;\n    },\n    Image(cx, next, start) {\n        return next == 33 /* '!' */ && cx.char(start + 1) == 91 /* '[' */\n            ? cx.append(new InlineDelimiter(ImageStart, start, start + 2, 1 /* Open */)) : -1;\n    },\n    LinkEnd(cx, next, start) {\n        if (next != 93 /* ']' */)\n            return -1;\n        // Scanning back to the next link/image start marker\n        for (let i = cx.parts.length - 1; i >= 0; i--) {\n            let part = cx.parts[i];\n            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {\n                // If this one has been set invalid (because it would produce\n                // a nested link) or there's no valid link here ignore both.\n                if (!part.side || cx.skipSpace(part.to) == start && !/[(\\[]/.test(cx.slice(start + 1, start + 2))) {\n                    cx.parts[i] = null;\n                    return -1;\n                }\n                // Finish the content and replace the entire range in\n                // this.parts with the link/image node.\n                let content = cx.takeContent(i);\n                let link = cx.parts[i] = finishLink(cx, content, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);\n                // Set any open-link markers before this link to invalid.\n                if (part.type == LinkStart)\n                    for (let j = 0; j < i; j++) {\n                        let p = cx.parts[j];\n                        if (p instanceof InlineDelimiter && p.type == LinkStart)\n                            p.side = 0;\n                    }\n                return link.to;\n            }\n        }\n        return -1;\n    }\n};\nfunction finishLink(cx, content, type, start, startPos) {\n    let { text } = cx, next = cx.char(startPos), endPos = startPos;\n    content.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));\n    content.push(elt(Type.LinkMark, startPos - 1, startPos));\n    if (next == 40 /* '(' */) {\n        let pos = cx.skipSpace(startPos + 1);\n        let dest = parseURL(text, pos - cx.offset, cx.offset), title;\n        if (dest) {\n            pos = cx.skipSpace(dest.to);\n            title = parseLinkTitle(text, pos - cx.offset, cx.offset);\n            if (title)\n                pos = cx.skipSpace(title.to);\n        }\n        if (cx.char(pos) == 41 /* ')' */) {\n            content.push(elt(Type.LinkMark, startPos, startPos + 1));\n            endPos = pos + 1;\n            if (dest)\n                content.push(dest);\n            if (title)\n                content.push(title);\n            content.push(elt(Type.LinkMark, pos, endPos));\n        }\n    }\n    else if (next == 91 /* '[' */) {\n        let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);\n        if (label) {\n            content.push(label);\n            endPos = label.to;\n        }\n    }\n    return elt(type, start, endPos, content);\n}\n// These return `null` when falling off the end of the input, `false`\n// when parsing fails otherwise (for use in the incremental link\n// reference parser).\nfunction parseURL(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next == 60 /* '<' */) {\n        for (let pos = start + 1; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (ch == 62 /* '>' */)\n                return elt(Type.URL, start + offset, pos + 1 + offset);\n            if (ch == 60 || ch == 10 /* '<\\n' */)\n                return false;\n        }\n        return null;\n    }\n    else {\n        let depth = 0, pos = start;\n        for (let escaped = false; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (space(ch)) {\n                break;\n            }\n            else if (escaped) {\n                escaped = false;\n            }\n            else if (ch == 40 /* '(' */) {\n                depth++;\n            }\n            else if (ch == 41 /* ')' */) {\n                if (!depth)\n                    break;\n                depth--;\n            }\n            else if (ch == 92 /* '\\\\' */) {\n                escaped = true;\n            }\n        }\n        return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text.length ? null : false;\n    }\n}\nfunction parseLinkTitle(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next != 39 && next != 34 && next != 40 /* '\"\\'(' */)\n        return false;\n    let end = next == 40 ? 41 : next;\n    for (let pos = start + 1, escaped = false; pos < text.length; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == end)\n            return elt(Type.LinkTitle, start + offset, pos + 1 + offset);\n        else if (ch == 92 /* '\\\\' */)\n            escaped = true;\n    }\n    return null;\n}\nfunction parseLinkLabel(text, start, offset, requireNonWS) {\n    for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == 93 /* ']' */)\n            return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);\n        else {\n            if (requireNonWS && !space(ch))\n                requireNonWS = false;\n            if (ch == 91 /* '[' */)\n                return false;\n            else if (ch == 92 /* '\\\\' */)\n                escaped = true;\n        }\n    }\n    return null;\n}\n/// Inline parsing functions get access to this context, and use it to\n/// read the content and emit syntax nodes.\nclass InlineContext {\n    /// @internal\n    constructor(\n    /// The parser that is being used.\n    parser, \n    /// The text of this inline section.\n    text, \n    /// The starting offset of the section in the document.\n    offset) {\n        this.parser = parser;\n        this.text = text;\n        this.offset = offset;\n        /// @internal\n        this.parts = [];\n    }\n    /// Get the character code at the given (document-relative)\n    /// position.\n    char(pos) { return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset); }\n    /// The position of the end of this inline section.\n    get end() { return this.offset + this.text.length; }\n    /// Get a substring of this inline section. Again uses\n    /// document-relative positions.\n    slice(from, to) { return this.text.slice(from - this.offset, to - this.offset); }\n    /// @internal\n    append(elt) {\n        this.parts.push(elt);\n        return elt.to;\n    }\n    /// Add a [delimiter](#DelimiterType) at this given position. `open`\n    /// and `close` indicate whether this delimiter is opening, closing,\n    /// or both. Returns the end of the delimiter, for convenient\n    /// returning from [parse functions](#InlineParser.parse).\n    addDelimiter(type, from, to, open, close) {\n        return this.append(new InlineDelimiter(type, from, to, (open ? 1 /* Open */ : 0) | (close ? 2 /* Close */ : 0)));\n    }\n    /// Add an inline element. Returns the end of the element.\n    addElement(elt) {\n        return this.append(elt);\n    }\n    /// @internal\n    resolveMarkers(from) {\n        for (let i = from; i < this.parts.length; i++) {\n            let close = this.parts[i];\n            if (!(close instanceof InlineDelimiter && close.type.resolve && (close.side & 2 /* Close */)))\n                continue;\n            let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;\n            let closeSize = close.to - close.from;\n            let open, j = i - 1;\n            for (; j >= from; j--) {\n                let part = this.parts[j];\n                if (!(part instanceof InlineDelimiter && (part.side & 1 /* Open */) && part.type == close.type) ||\n                    emp && ((close.side & 1 /* Open */) || (part.side & 2 /* Close */)) &&\n                        (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))\n                    continue;\n                open = part;\n                break;\n            }\n            if (!open)\n                continue;\n            let type = close.type.resolve, content = [];\n            let start = open.from, end = close.to;\n            if (emp) {\n                let size = Math.min(2, open.to - open.from, closeSize);\n                start = open.to - size;\n                end = close.from + size;\n                type = size == 1 ? \"Emphasis\" : \"StrongEmphasis\";\n            }\n            if (open.type.mark)\n                content.push(this.elt(open.type.mark, start, open.to));\n            for (let k = j + 1; k < i; k++) {\n                if (this.parts[k] instanceof Element)\n                    content.push(this.parts[k]);\n                this.parts[k] = null;\n            }\n            if (close.type.mark)\n                content.push(this.elt(close.type.mark, close.from, end));\n            let element = this.elt(type, start, end, content);\n            this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;\n            let keep = this.parts[i] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;\n            if (keep)\n                this.parts.splice(i, 0, element);\n            else\n                this.parts[i] = element;\n        }\n        let result = [];\n        for (let i = from; i < this.parts.length; i++) {\n            let part = this.parts[i];\n            if (part instanceof Element)\n                result.push(part);\n        }\n        return result;\n    }\n    /// Find an opening delimiter of the given type. Returns `null` if\n    /// no delimiter is found, or an index that can be passed to\n    /// [`takeContent`](#InlineContext.takeContent) otherwise.\n    findOpeningDelimiter(type) {\n        for (let i = this.parts.length - 1; i >= 0; i--) {\n            let part = this.parts[i];\n            if (part instanceof InlineDelimiter && part.type == type)\n                return i;\n        }\n        return null;\n    }\n    /// Remove all inline elements and delimiters starting from the\n    /// given index (which you should get from\n    /// [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),\n    /// resolve delimiters inside of them, and return them as an array\n    /// of elements.\n    takeContent(startIndex) {\n        let content = this.resolveMarkers(startIndex);\n        this.parts.length = startIndex;\n        return content;\n    }\n    /// Skip space after the given (document) position, returning either\n    /// the position of the next non-space character or the end of the\n    /// section.\n    skipSpace(from) { return skipSpace(this.text, from - this.offset) + this.offset; }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n}\nfunction injectMarks(elements, marks) {\n    if (!marks.length)\n        return elements;\n    if (!elements.length)\n        return marks;\n    let elts = elements.slice(), eI = 0;\n    for (let mark of marks) {\n        while (eI < elts.length && elts[eI].to < mark.to)\n            eI++;\n        if (eI < elts.length && elts[eI].from < mark.from) {\n            let e = elts[eI];\n            if (e instanceof Element)\n                elts[eI] = new Element(e.type, e.from, e.to, injectMarks(e.children, [mark]));\n        }\n        else {\n            elts.splice(eI++, 0, mark);\n        }\n    }\n    return elts;\n}\n// These are blocks that can span blank lines, and should thus only be\n// reused if their next sibling is also being reused.\nconst NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];\nclass FragmentCursor {\n    constructor(fragments, input) {\n        this.fragments = fragments;\n        this.input = input;\n        // Index into fragment array\n        this.i = 0;\n        // Active fragment\n        this.fragment = null;\n        this.fragmentEnd = -1;\n        // Cursor into the current fragment, if any. When `moveTo` returns\n        // true, this points at the first block after `pos`.\n        this.cursor = null;\n        if (fragments.length)\n            this.fragment = fragments[this.i++];\n    }\n    nextFragment() {\n        this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;\n        this.cursor = null;\n        this.fragmentEnd = -1;\n    }\n    moveTo(pos, lineStart) {\n        while (this.fragment && this.fragment.to <= pos)\n            this.nextFragment();\n        if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))\n            return false;\n        if (this.fragmentEnd < 0) {\n            let end = this.fragment.to;\n            while (end > 0 && this.input.read(end - 1, end) != \"\\n\")\n                end--;\n            this.fragmentEnd = end ? end - 1 : 0;\n        }\n        let c = this.cursor;\n        if (!c) {\n            c = this.cursor = this.fragment.tree.cursor();\n            c.firstChild();\n        }\n        let rPos = pos + this.fragment.offset;\n        while (c.to <= rPos)\n            if (!c.parent())\n                return false;\n        for (;;) {\n            if (c.from >= rPos)\n                return this.fragment.from <= lineStart;\n            if (!c.childAfter(rPos))\n                return false;\n        }\n    }\n    matches(hash) {\n        let tree = this.cursor.tree;\n        return tree && tree.prop(NodeProp.contextHash) == hash;\n    }\n    takeNodes(cx) {\n        let cur = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);\n        let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;\n        let prevEnd = end, prevI = blockI;\n        for (;;) {\n            if (cur.to - off > fragEnd) {\n                if (cur.type.isAnonymous && cur.firstChild())\n                    continue;\n                break;\n            }\n            cx.dontInject.add(cur.tree);\n            cx.addNode(cur.tree, cur.from - off);\n            // Taken content must always end in a block, because incremental\n            // parsing happens on block boundaries. Never stop directly\n            // after an indented code block, since those can continue after\n            // any number of blank lines.\n            if (cur.type.is(\"Block\")) {\n                if (NotLast.indexOf(cur.type.id) < 0) {\n                    end = cur.to - off;\n                    blockI = cx.block.children.length;\n                }\n                else {\n                    end = prevEnd;\n                    blockI = prevI;\n                    prevEnd = cur.to - off;\n                    prevI = cx.block.children.length;\n                }\n            }\n            if (!cur.nextSibling())\n                break;\n        }\n        while (cx.block.children.length > blockI) {\n            cx.block.children.pop();\n            cx.block.positions.pop();\n        }\n        return end - start;\n    }\n}\nconst markdownHighlighting = styleTags({\n    \"Blockquote/...\": tags.quote,\n    HorizontalRule: tags.contentSeparator,\n    \"ATXHeading1/... SetextHeading1/...\": tags.heading1,\n    \"ATXHeading2/... SetextHeading2/...\": tags.heading2,\n    \"ATXHeading3/...\": tags.heading3,\n    \"ATXHeading4/...\": tags.heading4,\n    \"ATXHeading5/...\": tags.heading5,\n    \"ATXHeading6/...\": tags.heading6,\n    \"Comment CommentBlock\": tags.comment,\n    Escape: tags.escape,\n    Entity: tags.character,\n    \"Emphasis/...\": tags.emphasis,\n    \"StrongEmphasis/...\": tags.strong,\n    \"Link/... Image/...\": tags.link,\n    \"OrderedList/... BulletList/...\": tags.list,\n    \"BlockQuote/...\": tags.quote,\n    \"InlineCode CodeText\": tags.monospace,\n    URL: tags.url,\n    \"HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark\": tags.processingInstruction,\n    \"CodeInfo LinkLabel\": tags.labelName,\n    LinkTitle: tags.string,\n    Paragraph: tags.content\n});\n/// The default CommonMark parser.\nconst parser = new MarkdownParser(new NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map(n => DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map(n => DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map(n => DefaultInline[n]), Object.keys(DefaultInline), []);\n\nfunction leftOverSpace(node, from, to) {\n    let ranges = [];\n    for (let n = node.firstChild, pos = from;; n = n.nextSibling) {\n        let nextPos = n ? n.from : to;\n        if (nextPos > pos)\n            ranges.push({ from: pos, to: nextPos });\n        if (!n)\n            break;\n        pos = n.to;\n    }\n    return ranges;\n}\n/// Create a Markdown extension to enable nested parsing on code\n/// blocks and/or embedded HTML.\nfunction parseCode(config) {\n    let { codeParser, htmlParser } = config;\n    let wrap = parseMixed((node, input) => {\n        let id = node.type.id;\n        if (codeParser && (id == Type.CodeBlock || id == Type.FencedCode)) {\n            let info = \"\";\n            if (id == Type.FencedCode) {\n                let infoNode = node.node.getChild(Type.CodeInfo);\n                if (infoNode)\n                    info = input.read(infoNode.from, infoNode.to);\n            }\n            let parser = codeParser(info);\n            if (parser)\n                return { parser, overlay: node => node.type.id == Type.CodeText };\n        }\n        else if (htmlParser && (id == Type.HTMLBlock || id == Type.HTMLTag)) {\n            return { parser: htmlParser, overlay: leftOverSpace(node.node, node.from, node.to) };\n        }\n        return null;\n    });\n    return { wrap };\n}\n\nconst StrikethroughDelim = { resolve: \"Strikethrough\", mark: \"StrikethroughMark\" };\n/// An extension that implements\n/// [GFM-style](https://github.github.com/gfm/#strikethrough-extension-)\n/// Strikethrough syntax using `~~` delimiters.\nconst Strikethrough = {\n    defineNodes: [{\n            name: \"Strikethrough\",\n            style: { \"Strikethrough/...\": tags.strikethrough }\n        }, {\n            name: \"StrikethroughMark\",\n            style: tags.processingInstruction\n        }],\n    parseInline: [{\n            name: \"Strikethrough\",\n            parse(cx, next, pos) {\n                if (next != 126 /* '~' */ || cx.char(pos + 1) != 126)\n                    return -1;\n                return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, true, true);\n            },\n            after: \"Emphasis\"\n        }]\n};\nfunction parseRow(cx, line, startI = 0, elts, offset = 0) {\n    let count = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;\n    let parseCell = () => {\n        elts.push(cx.elt(\"TableCell\", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));\n    };\n    for (let i = startI; i < line.length; i++) {\n        let next = line.charCodeAt(i);\n        if (next == 124 /* '|' */ && !esc) {\n            if (!first || cellStart > -1)\n                count++;\n            first = false;\n            if (elts) {\n                if (cellStart > -1)\n                    parseCell();\n                elts.push(cx.elt(\"TableDelimiter\", i + offset, i + offset + 1));\n            }\n            cellStart = cellEnd = -1;\n        }\n        else if (esc || next != 32 && next != 9) {\n            if (cellStart < 0)\n                cellStart = i;\n            cellEnd = i + 1;\n        }\n        esc = !esc && next == 92;\n    }\n    if (cellStart > -1) {\n        count++;\n        if (elts)\n            parseCell();\n    }\n    return count;\n}\nfunction hasPipe(str, start) {\n    for (let i = start; i < str.length; i++) {\n        let next = str.charCodeAt(i);\n        if (next == 124 /* '|' */)\n            return true;\n        if (next == 92 /* '\\\\' */)\n            i++;\n    }\n    return false;\n}\nconst delimiterLine = /^\\|?(\\s*:?-+:?\\s*\\|)+(\\s*:?-+:?\\s*)?$/;\nclass TableParser {\n    constructor() {\n        // Null means we haven't seen the second line yet, false means this\n        // isn't a table, and an array means this is a table and we've\n        // parsed the given rows so far.\n        this.rows = null;\n    }\n    nextLine(cx, line, leaf) {\n        if (this.rows == null) { // Second line\n            this.rows = false;\n            let lineText;\n            if ((line.next == 45 || line.next == 58 || line.next == 124 /* '-:|' */) &&\n                delimiterLine.test(lineText = line.text.slice(line.pos))) {\n                let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);\n                if (firstCount == parseRow(cx, lineText, line.pos))\n                    this.rows = [cx.elt(\"TableHeader\", leaf.start, leaf.start + leaf.content.length, firstRow),\n                        cx.elt(\"TableDelimiter\", cx.lineStart + line.pos, cx.lineStart + line.text.length)];\n            }\n        }\n        else if (this.rows) { // Line after the second\n            let content = [];\n            parseRow(cx, line.text, line.pos, content, cx.lineStart);\n            this.rows.push(cx.elt(\"TableRow\", cx.lineStart + line.pos, cx.lineStart + line.text.length, content));\n        }\n        return false;\n    }\n    finish(cx, leaf) {\n        if (!this.rows)\n            return false;\n        cx.addLeafElement(leaf, cx.elt(\"Table\", leaf.start, leaf.start + leaf.content.length, this.rows));\n        return true;\n    }\n}\n/// This extension provides\n/// [GFM-style](https://github.github.com/gfm/#tables-extension-)\n/// tables, using syntax like this:\n///\n/// ```\n/// | head 1 | head 2 |\n/// | ---    | ---    |\n/// | cell 1 | cell 2 |\n/// ```\nconst Table = {\n    defineNodes: [\n        { name: \"Table\", block: true },\n        { name: \"TableHeader\", style: { \"TableHeader/...\": tags.heading } },\n        \"TableRow\",\n        { name: \"TableCell\", style: tags.content },\n        { name: \"TableDelimiter\", style: tags.processingInstruction },\n    ],\n    parseBlock: [{\n            name: \"Table\",\n            leaf(_, leaf) { return hasPipe(leaf.content, 0) ? new TableParser : null; },\n            endLeaf(cx, line, leaf) {\n                if (leaf.parsers.some(p => p instanceof TableParser) || !hasPipe(line.text, line.basePos))\n                    return false;\n                let next = cx.scanLine(cx.absoluteLineEnd + 1).text;\n                return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);\n            },\n            before: \"SetextHeading\"\n        }]\n};\nclass TaskParser {\n    nextLine() { return false; }\n    finish(cx, leaf) {\n        cx.addLeafElement(leaf, cx.elt(\"Task\", leaf.start, leaf.start + leaf.content.length, [\n            cx.elt(\"TaskMarker\", leaf.start, leaf.start + 3),\n            ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)\n        ]));\n        return true;\n    }\n}\n/// Extension providing\n/// [GFM-style](https://github.github.com/gfm/#task-list-items-extension-)\n/// task list items, where list items can be prefixed with `[ ]` or\n/// `[x]` to add a checkbox.\nconst TaskList = {\n    defineNodes: [\n        { name: \"Task\", block: true, style: tags.list },\n        { name: \"TaskMarker\", style: tags.atom }\n    ],\n    parseBlock: [{\n            name: \"TaskList\",\n            leaf(cx, leaf) {\n                return /^\\[[ xX]\\]/.test(leaf.content) && cx.parentType().name == \"ListItem\" ? new TaskParser : null;\n            },\n            after: \"SetextHeading\"\n        }]\n};\n/// Extension bundle containing [`Table`](#Table),\n/// [`TaskList`](#TaskList) and [`Strikethrough`](#Strikethrough).\nconst GFM = [Table, TaskList, Strikethrough];\nfunction parseSubSuper(ch, node, mark) {\n    return (cx, next, pos) => {\n        if (next != ch || cx.char(pos + 1) == ch)\n            return -1;\n        let elts = [cx.elt(mark, pos, pos + 1)];\n        for (let i = pos + 1; i < cx.end; i++) {\n            let next = cx.char(i);\n            if (next == ch)\n                return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));\n            if (next == 92 /* '\\\\' */)\n                elts.push(cx.elt(\"Escape\", i, i++ + 2));\n            if (space(next))\n                break;\n        }\n        return -1;\n    };\n}\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// superscript using `^` markers.\nconst Superscript = {\n    defineNodes: [\n        { name: \"Superscript\", style: tags.special(tags.content) },\n        { name: \"SuperscriptMark\", style: tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Superscript\",\n            parse: parseSubSuper(94 /* '^' */, \"Superscript\", \"SuperscriptMark\")\n        }]\n};\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// subscript using `~` markers.\nconst Subscript = {\n    defineNodes: [\n        { name: \"Subscript\", style: tags.special(tags.content) },\n        { name: \"SubscriptMark\", style: tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Subscript\",\n            parse: parseSubSuper(126 /* '~' */, \"Subscript\", \"SubscriptMark\")\n        }]\n};\n/// Extension that parses two colons with only letters, underscores,\n/// and numbers between them as `Emoji` nodes.\nconst Emoji = {\n    defineNodes: [{ name: \"Emoji\", style: tags.character }],\n    parseInline: [{\n            name: \"Emoji\",\n            parse(cx, next, pos) {\n                let match;\n                if (next != 58 /* ':' */ || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))\n                    return -1;\n                return cx.addElement(cx.elt(\"Emoji\", pos, pos + 1 + match[0].length));\n            }\n        }]\n};\n\nexport { BlockContext, Element, Emoji, GFM, InlineContext, LeafBlock, Line, MarkdownParser, Strikethrough, Subscript, Superscript, Table, TaskList, parseCode, parser };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}