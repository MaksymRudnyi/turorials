{"ast":null,"code":"var BUILTIN = \"builtin\",\n    COMMENT = \"comment\",\n    STRING = \"string\",\n    SYMBOL = \"symbol\",\n    ATOM = \"atom\",\n    NUMBER = \"number\",\n    BRACKET = \"bracket\";\nvar INDENT_WORD_SKIP = 2;\n\nfunction makeKeywords(str) {\n  var obj = {},\n      words = str.split(\" \");\n\n  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n\n  return obj;\n}\n\nvar keywords = makeKeywords(\"λ case-lambda call/cc class cond-expand define-class define-values exit-handler field import inherit init-field interface let*-values let-values let/ec mixin opt-lambda override protect provide public rename require require-for-syntax syntax syntax-case syntax-error unit/sig unless when with-syntax and begin call-with-current-continuation call-with-input-file call-with-output-file case cond define define-syntax define-macro defmacro delay do dynamic-wind else for-each if lambda let let* let-syntax letrec letrec-syntax map or syntax-rules abs acos angle append apply asin assoc assq assv atan boolean? caar cadr call-with-input-file call-with-output-file call-with-values car cdddar cddddr cdr ceiling char->integer char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>? char-downcase char-lower-case? char-numeric? char-ready? char-upcase char-upper-case? char-whitespace? char<=? char<? char=? char>=? char>? char? close-input-port close-output-port complex? cons cos current-input-port current-output-port denominator display eof-object? eq? equal? eqv? eval even? exact->inexact exact? exp expt #f floor force gcd imag-part inexact->exact inexact? input-port? integer->char integer? interaction-environment lcm length list list->string list->vector list-ref list-tail list? load log magnitude make-polar make-rectangular make-string make-vector max member memq memv min modulo negative? newline not null-environment null? number->string number? numerator odd? open-input-file open-output-file output-port? pair? peek-char port? positive? procedure? quasiquote quote quotient rational? rationalize read read-char real-part real? remainder reverse round scheme-report-environment set! set-car! set-cdr! sin sqrt string string->list string->number string->symbol string-append string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>? string-copy string-fill! string-length string-ref string-set! string<=? string<? string=? string>=? string>? string? substring symbol->string symbol? #t tan transcript-off transcript-on truncate values vector vector->list vector-fill! vector-length vector-ref vector-set! with-input-from-file with-output-to-file write write-char zero?\");\nvar indentKeys = makeKeywords(\"define let letrec let* lambda define-macro defmacro let-syntax letrec-syntax let-values let*-values define-syntax syntax-rules define-values when unless\");\n\nfunction stateStack(indent, type, prev) {\n  // represents a state stack object\n  this.indent = indent;\n  this.type = type;\n  this.prev = prev;\n}\n\nfunction pushStack(state, indent, type) {\n  state.indentStack = new stateStack(indent, type, state.indentStack);\n}\n\nfunction popStack(state) {\n  state.indentStack = state.indentStack.prev;\n}\n\nvar binaryMatcher = new RegExp(/^(?:[-+]i|[-+][01]+#*(?:\\/[01]+#*)?i|[-+]?[01]+#*(?:\\/[01]+#*)?@[-+]?[01]+#*(?:\\/[01]+#*)?|[-+]?[01]+#*(?:\\/[01]+#*)?[-+](?:[01]+#*(?:\\/[01]+#*)?)?i|[-+]?[01]+#*(?:\\/[01]+#*)?)(?=[()\\s;\"]|$)/i);\nvar octalMatcher = new RegExp(/^(?:[-+]i|[-+][0-7]+#*(?:\\/[0-7]+#*)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?@[-+]?[0-7]+#*(?:\\/[0-7]+#*)?|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?[-+](?:[0-7]+#*(?:\\/[0-7]+#*)?)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?)(?=[()\\s;\"]|$)/i);\nvar hexMatcher = new RegExp(/^(?:[-+]i|[-+][\\da-f]+#*(?:\\/[\\da-f]+#*)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?@[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?[-+](?:[\\da-f]+#*(?:\\/[\\da-f]+#*)?)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?)(?=[()\\s;\"]|$)/i);\nvar decimalMatcher = new RegExp(/^(?:[-+]i|[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)i|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)@[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)?i|(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*))(?=[()\\s;\"]|$)/i);\n\nfunction isBinaryNumber(stream) {\n  return stream.match(binaryMatcher);\n}\n\nfunction isOctalNumber(stream) {\n  return stream.match(octalMatcher);\n}\n\nfunction isDecimalNumber(stream, backup) {\n  if (backup === true) {\n    stream.backUp(1);\n  }\n\n  return stream.match(decimalMatcher);\n}\n\nfunction isHexNumber(stream) {\n  return stream.match(hexMatcher);\n}\n\nfunction processEscapedSequence(stream, options) {\n  var next,\n      escaped = false;\n\n  while ((next = stream.next()) != null) {\n    if (next == options.token && !escaped) {\n      options.state.mode = false;\n      break;\n    }\n\n    escaped = !escaped && next == \"\\\\\";\n  }\n}\n\nexport const scheme = {\n  startState: function () {\n    return {\n      indentStack: null,\n      indentation: 0,\n      mode: false,\n      sExprComment: false,\n      sExprQuote: false\n    };\n  },\n  token: function (stream, state) {\n    if (state.indentStack == null && stream.sol()) {\n      // update indentation, but only if indentStack is empty\n      state.indentation = stream.indentation();\n    } // skip spaces\n\n\n    if (stream.eatSpace()) {\n      return null;\n    }\n\n    var returnType = null;\n\n    switch (state.mode) {\n      case \"string\":\n        // multi-line string parsing mode\n        processEscapedSequence(stream, {\n          token: \"\\\"\",\n          state: state\n        });\n        returnType = STRING; // continue on in scheme-string mode\n\n        break;\n\n      case \"symbol\":\n        // escape symbol\n        processEscapedSequence(stream, {\n          token: \"|\",\n          state: state\n        });\n        returnType = SYMBOL; // continue on in scheme-symbol mode\n\n        break;\n\n      case \"comment\":\n        // comment parsing mode\n        var next,\n            maybeEnd = false;\n\n        while ((next = stream.next()) != null) {\n          if (next == \"#\" && maybeEnd) {\n            state.mode = false;\n            break;\n          }\n\n          maybeEnd = next == \"|\";\n        }\n\n        returnType = COMMENT;\n        break;\n\n      case \"s-expr-comment\":\n        // s-expr commenting mode\n        state.mode = false;\n\n        if (stream.peek() == \"(\" || stream.peek() == \"[\") {\n          // actually start scheme s-expr commenting mode\n          state.sExprComment = 0;\n        } else {\n          // if not we just comment the entire of the next token\n          stream.eatWhile(/[^\\s\\(\\)\\[\\]]/); // eat symbol atom\n\n          returnType = COMMENT;\n          break;\n        }\n\n      default:\n        // default parsing mode\n        var ch = stream.next();\n\n        if (ch == \"\\\"\") {\n          state.mode = \"string\";\n          returnType = STRING;\n        } else if (ch == \"'\") {\n          if (stream.peek() == \"(\" || stream.peek() == \"[\") {\n            if (typeof state.sExprQuote != \"number\") {\n              state.sExprQuote = 0;\n            } // else already in a quoted expression\n\n\n            returnType = ATOM;\n          } else {\n            stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n            returnType = ATOM;\n          }\n        } else if (ch == '|') {\n          state.mode = \"symbol\";\n          returnType = SYMBOL;\n        } else if (ch == '#') {\n          if (stream.eat(\"|\")) {\n            // Multi-line comment\n            state.mode = \"comment\"; // toggle to comment mode\n\n            returnType = COMMENT;\n          } else if (stream.eat(/[tf]/i)) {\n            // #t/#f (atom)\n            returnType = ATOM;\n          } else if (stream.eat(';')) {\n            // S-Expr comment\n            state.mode = \"s-expr-comment\";\n            returnType = COMMENT;\n          } else {\n            var numTest = null,\n                hasExactness = false,\n                hasRadix = true;\n\n            if (stream.eat(/[ei]/i)) {\n              hasExactness = true;\n            } else {\n              stream.backUp(1); // must be radix specifier\n            }\n\n            if (stream.match(/^#b/i)) {\n              numTest = isBinaryNumber;\n            } else if (stream.match(/^#o/i)) {\n              numTest = isOctalNumber;\n            } else if (stream.match(/^#x/i)) {\n              numTest = isHexNumber;\n            } else if (stream.match(/^#d/i)) {\n              numTest = isDecimalNumber;\n            } else if (stream.match(/^[-+0-9.]/, false)) {\n              hasRadix = false;\n              numTest = isDecimalNumber; // re-consume the initial # if all matches failed\n            } else if (!hasExactness) {\n              stream.eat('#');\n            }\n\n            if (numTest != null) {\n              if (hasRadix && !hasExactness) {\n                // consume optional exactness after radix\n                stream.match(/^#[ei]/i);\n              }\n\n              if (numTest(stream)) returnType = NUMBER;\n            }\n          }\n        } else if (/^[-+0-9.]/.test(ch) && isDecimalNumber(stream, true)) {\n          // match non-prefixed number, must be decimal\n          returnType = NUMBER;\n        } else if (ch == \";\") {\n          // comment\n          stream.skipToEnd(); // rest of the line is a comment\n\n          returnType = COMMENT;\n        } else if (ch == \"(\" || ch == \"[\") {\n          var keyWord = '';\n          var indentTemp = stream.column(),\n              letter;\n          /**\n             Either\n             (indent-word ..\n             (non-indent-word ..\n             (;something else, bracket, etc.\n          */\n\n          while ((letter = stream.eat(/[^\\s\\(\\[\\;\\)\\]]/)) != null) {\n            keyWord += letter;\n          }\n\n          if (keyWord.length > 0 && indentKeys.propertyIsEnumerable(keyWord)) {\n            // indent-word\n            pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);\n          } else {\n            // non-indent word\n            // we continue eating the spaces\n            stream.eatSpace();\n\n            if (stream.eol() || stream.peek() == \";\") {\n              // nothing significant after\n              // we restart indentation 1 space after\n              pushStack(state, indentTemp + 1, ch);\n            } else {\n              pushStack(state, indentTemp + stream.current().length, ch); // else we match\n            }\n          }\n\n          stream.backUp(stream.current().length - 1); // undo all the eating\n\n          if (typeof state.sExprComment == \"number\") state.sExprComment++;\n          if (typeof state.sExprQuote == \"number\") state.sExprQuote++;\n          returnType = BRACKET;\n        } else if (ch == \")\" || ch == \"]\") {\n          returnType = BRACKET;\n\n          if (state.indentStack != null && state.indentStack.type == (ch == \")\" ? \"(\" : \"[\")) {\n            popStack(state);\n\n            if (typeof state.sExprComment == \"number\") {\n              if (--state.sExprComment == 0) {\n                returnType = COMMENT; // final closing bracket\n\n                state.sExprComment = false; // turn off s-expr commenting mode\n              }\n            }\n\n            if (typeof state.sExprQuote == \"number\") {\n              if (--state.sExprQuote == 0) {\n                returnType = ATOM; // final closing bracket\n\n                state.sExprQuote = false; // turn off s-expr quote mode\n              }\n            }\n          }\n        } else {\n          stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n\n          if (keywords && keywords.propertyIsEnumerable(stream.current())) {\n            returnType = BUILTIN;\n          } else returnType = \"variable\";\n        }\n\n    }\n\n    return typeof state.sExprComment == \"number\" ? COMMENT : typeof state.sExprQuote == \"number\" ? ATOM : returnType;\n  },\n  indent: function (state) {\n    if (state.indentStack == null) return state.indentation;\n    return state.indentStack.indent;\n  },\n  languageData: {\n    closeBrackets: {\n      brackets: [\"(\", \"[\", \"{\", '\"']\n    },\n    commentTokens: {\n      line: \";;\"\n    }\n  }\n};","map":{"version":3,"names":["BUILTIN","COMMENT","STRING","SYMBOL","ATOM","NUMBER","BRACKET","INDENT_WORD_SKIP","makeKeywords","str","obj","words","split","i","length","keywords","indentKeys","stateStack","indent","type","prev","pushStack","state","indentStack","popStack","binaryMatcher","RegExp","octalMatcher","hexMatcher","decimalMatcher","isBinaryNumber","stream","match","isOctalNumber","isDecimalNumber","backup","backUp","isHexNumber","processEscapedSequence","options","next","escaped","token","mode","scheme","startState","indentation","sExprComment","sExprQuote","sol","eatSpace","returnType","maybeEnd","peek","eatWhile","ch","eat","numTest","hasExactness","hasRadix","test","skipToEnd","keyWord","indentTemp","column","letter","propertyIsEnumerable","eol","current","languageData","closeBrackets","brackets","commentTokens","line"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/@codemirror/legacy-modes/mode/scheme.js"],"sourcesContent":["var BUILTIN = \"builtin\", COMMENT = \"comment\", STRING = \"string\",\n    SYMBOL = \"symbol\", ATOM = \"atom\", NUMBER = \"number\", BRACKET = \"bracket\";\nvar INDENT_WORD_SKIP = 2;\n\nfunction makeKeywords(str) {\n  var obj = {}, words = str.split(\" \");\n  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n  return obj;\n}\n\nvar keywords = makeKeywords(\"λ case-lambda call/cc class cond-expand define-class define-values exit-handler field import inherit init-field interface let*-values let-values let/ec mixin opt-lambda override protect provide public rename require require-for-syntax syntax syntax-case syntax-error unit/sig unless when with-syntax and begin call-with-current-continuation call-with-input-file call-with-output-file case cond define define-syntax define-macro defmacro delay do dynamic-wind else for-each if lambda let let* let-syntax letrec letrec-syntax map or syntax-rules abs acos angle append apply asin assoc assq assv atan boolean? caar cadr call-with-input-file call-with-output-file call-with-values car cdddar cddddr cdr ceiling char->integer char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>? char-downcase char-lower-case? char-numeric? char-ready? char-upcase char-upper-case? char-whitespace? char<=? char<? char=? char>=? char>? char? close-input-port close-output-port complex? cons cos current-input-port current-output-port denominator display eof-object? eq? equal? eqv? eval even? exact->inexact exact? exp expt #f floor force gcd imag-part inexact->exact inexact? input-port? integer->char integer? interaction-environment lcm length list list->string list->vector list-ref list-tail list? load log magnitude make-polar make-rectangular make-string make-vector max member memq memv min modulo negative? newline not null-environment null? number->string number? numerator odd? open-input-file open-output-file output-port? pair? peek-char port? positive? procedure? quasiquote quote quotient rational? rationalize read read-char real-part real? remainder reverse round scheme-report-environment set! set-car! set-cdr! sin sqrt string string->list string->number string->symbol string-append string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>? string-copy string-fill! string-length string-ref string-set! string<=? string<? string=? string>=? string>? string? substring symbol->string symbol? #t tan transcript-off transcript-on truncate values vector vector->list vector-fill! vector-length vector-ref vector-set! with-input-from-file with-output-to-file write write-char zero?\");\nvar indentKeys = makeKeywords(\"define let letrec let* lambda define-macro defmacro let-syntax letrec-syntax let-values let*-values define-syntax syntax-rules define-values when unless\");\n\nfunction stateStack(indent, type, prev) { // represents a state stack object\n  this.indent = indent;\n  this.type = type;\n  this.prev = prev;\n}\n\nfunction pushStack(state, indent, type) {\n  state.indentStack = new stateStack(indent, type, state.indentStack);\n}\n\nfunction popStack(state) {\n  state.indentStack = state.indentStack.prev;\n}\n\nvar binaryMatcher = new RegExp(/^(?:[-+]i|[-+][01]+#*(?:\\/[01]+#*)?i|[-+]?[01]+#*(?:\\/[01]+#*)?@[-+]?[01]+#*(?:\\/[01]+#*)?|[-+]?[01]+#*(?:\\/[01]+#*)?[-+](?:[01]+#*(?:\\/[01]+#*)?)?i|[-+]?[01]+#*(?:\\/[01]+#*)?)(?=[()\\s;\"]|$)/i);\nvar octalMatcher = new RegExp(/^(?:[-+]i|[-+][0-7]+#*(?:\\/[0-7]+#*)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?@[-+]?[0-7]+#*(?:\\/[0-7]+#*)?|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?[-+](?:[0-7]+#*(?:\\/[0-7]+#*)?)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?)(?=[()\\s;\"]|$)/i);\nvar hexMatcher = new RegExp(/^(?:[-+]i|[-+][\\da-f]+#*(?:\\/[\\da-f]+#*)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?@[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?[-+](?:[\\da-f]+#*(?:\\/[\\da-f]+#*)?)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?)(?=[()\\s;\"]|$)/i);\nvar decimalMatcher = new RegExp(/^(?:[-+]i|[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)i|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)@[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)?i|(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*))(?=[()\\s;\"]|$)/i);\n\nfunction isBinaryNumber (stream) {\n  return stream.match(binaryMatcher);\n}\n\nfunction isOctalNumber (stream) {\n  return stream.match(octalMatcher);\n}\n\nfunction isDecimalNumber (stream, backup) {\n  if (backup === true) {\n    stream.backUp(1);\n  }\n  return stream.match(decimalMatcher);\n}\n\nfunction isHexNumber (stream) {\n  return stream.match(hexMatcher);\n}\n\nfunction processEscapedSequence(stream, options) {\n  var next, escaped = false;\n  while ((next = stream.next()) != null) {\n    if (next == options.token && !escaped) {\n      options.state.mode = false;\n      break;\n    }\n    escaped = !escaped && next == \"\\\\\";\n  }\n}\n\nexport const scheme = {\n  startState: function () {\n    return {\n      indentStack: null,\n      indentation: 0,\n      mode: false,\n      sExprComment: false,\n      sExprQuote: false\n    };\n  },\n\n  token: function (stream, state) {\n    if (state.indentStack == null && stream.sol()) {\n      // update indentation, but only if indentStack is empty\n      state.indentation = stream.indentation();\n    }\n\n    // skip spaces\n    if (stream.eatSpace()) {\n      return null;\n    }\n    var returnType = null;\n\n    switch(state.mode){\n    case \"string\": // multi-line string parsing mode\n      processEscapedSequence(stream, {\n        token: \"\\\"\",\n        state: state\n      });\n      returnType = STRING; // continue on in scheme-string mode\n      break;\n    case \"symbol\": // escape symbol\n      processEscapedSequence(stream, {\n        token: \"|\",\n        state: state\n      });\n      returnType = SYMBOL; // continue on in scheme-symbol mode\n      break;\n    case \"comment\": // comment parsing mode\n      var next, maybeEnd = false;\n      while ((next = stream.next()) != null) {\n        if (next == \"#\" && maybeEnd) {\n\n          state.mode = false;\n          break;\n        }\n        maybeEnd = (next == \"|\");\n      }\n      returnType = COMMENT;\n      break;\n    case \"s-expr-comment\": // s-expr commenting mode\n      state.mode = false;\n      if(stream.peek() == \"(\" || stream.peek() == \"[\"){\n        // actually start scheme s-expr commenting mode\n        state.sExprComment = 0;\n      }else{\n        // if not we just comment the entire of the next token\n        stream.eatWhile(/[^\\s\\(\\)\\[\\]]/); // eat symbol atom\n        returnType = COMMENT;\n        break;\n      }\n    default: // default parsing mode\n      var ch = stream.next();\n\n      if (ch == \"\\\"\") {\n        state.mode = \"string\";\n        returnType = STRING;\n\n      } else if (ch == \"'\") {\n        if (stream.peek() == \"(\" || stream.peek() == \"[\"){\n          if (typeof state.sExprQuote != \"number\") {\n            state.sExprQuote = 0;\n          } // else already in a quoted expression\n          returnType = ATOM;\n        } else {\n          stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n          returnType = ATOM;\n        }\n      } else if (ch == '|') {\n        state.mode = \"symbol\";\n        returnType = SYMBOL;\n      } else if (ch == '#') {\n        if (stream.eat(\"|\")) {                    // Multi-line comment\n          state.mode = \"comment\"; // toggle to comment mode\n          returnType = COMMENT;\n        } else if (stream.eat(/[tf]/i)) {            // #t/#f (atom)\n          returnType = ATOM;\n        } else if (stream.eat(';')) {                // S-Expr comment\n          state.mode = \"s-expr-comment\";\n          returnType = COMMENT;\n        } else {\n          var numTest = null, hasExactness = false, hasRadix = true;\n          if (stream.eat(/[ei]/i)) {\n            hasExactness = true;\n          } else {\n            stream.backUp(1);       // must be radix specifier\n          }\n          if (stream.match(/^#b/i)) {\n            numTest = isBinaryNumber;\n          } else if (stream.match(/^#o/i)) {\n            numTest = isOctalNumber;\n          } else if (stream.match(/^#x/i)) {\n            numTest = isHexNumber;\n          } else if (stream.match(/^#d/i)) {\n            numTest = isDecimalNumber;\n          } else if (stream.match(/^[-+0-9.]/, false)) {\n            hasRadix = false;\n            numTest = isDecimalNumber;\n            // re-consume the initial # if all matches failed\n          } else if (!hasExactness) {\n            stream.eat('#');\n          }\n          if (numTest != null) {\n            if (hasRadix && !hasExactness) {\n              // consume optional exactness after radix\n              stream.match(/^#[ei]/i);\n            }\n            if (numTest(stream))\n              returnType = NUMBER;\n          }\n        }\n      } else if (/^[-+0-9.]/.test(ch) && isDecimalNumber(stream, true)) { // match non-prefixed number, must be decimal\n        returnType = NUMBER;\n      } else if (ch == \";\") { // comment\n        stream.skipToEnd(); // rest of the line is a comment\n        returnType = COMMENT;\n      } else if (ch == \"(\" || ch == \"[\") {\n        var keyWord = ''; var indentTemp = stream.column(), letter;\n        /**\n           Either\n           (indent-word ..\n           (non-indent-word ..\n           (;something else, bracket, etc.\n        */\n\n        while ((letter = stream.eat(/[^\\s\\(\\[\\;\\)\\]]/)) != null) {\n          keyWord += letter;\n        }\n\n        if (keyWord.length > 0 && indentKeys.propertyIsEnumerable(keyWord)) { // indent-word\n\n          pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);\n        } else { // non-indent word\n          // we continue eating the spaces\n          stream.eatSpace();\n          if (stream.eol() || stream.peek() == \";\") {\n            // nothing significant after\n            // we restart indentation 1 space after\n            pushStack(state, indentTemp + 1, ch);\n          } else {\n            pushStack(state, indentTemp + stream.current().length, ch); // else we match\n          }\n        }\n        stream.backUp(stream.current().length - 1); // undo all the eating\n\n        if(typeof state.sExprComment == \"number\") state.sExprComment++;\n        if(typeof state.sExprQuote == \"number\") state.sExprQuote++;\n\n        returnType = BRACKET;\n      } else if (ch == \")\" || ch == \"]\") {\n        returnType = BRACKET;\n        if (state.indentStack != null && state.indentStack.type == (ch == \")\" ? \"(\" : \"[\")) {\n          popStack(state);\n\n          if(typeof state.sExprComment == \"number\"){\n            if(--state.sExprComment == 0){\n              returnType = COMMENT; // final closing bracket\n              state.sExprComment = false; // turn off s-expr commenting mode\n            }\n          }\n          if(typeof state.sExprQuote == \"number\"){\n            if(--state.sExprQuote == 0){\n              returnType = ATOM; // final closing bracket\n              state.sExprQuote = false; // turn off s-expr quote mode\n            }\n          }\n        }\n      } else {\n        stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n\n        if (keywords && keywords.propertyIsEnumerable(stream.current())) {\n          returnType = BUILTIN;\n        } else returnType = \"variable\";\n      }\n    }\n    return (typeof state.sExprComment == \"number\") ? COMMENT : ((typeof state.sExprQuote == \"number\") ? ATOM : returnType);\n  },\n\n  indent: function (state) {\n    if (state.indentStack == null) return state.indentation;\n    return state.indentStack.indent;\n  },\n\n  languageData: {\n    closeBrackets: {brackets: [\"(\", \"[\", \"{\", '\"']},\n    commentTokens: {line: \";;\"}\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}