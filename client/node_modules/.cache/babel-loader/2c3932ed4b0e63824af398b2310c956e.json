{"ast":null,"code":"var EventEmitter = require('events').EventEmitter,\n    inherits = require('util').inherits;\n\nvar StreamSearch = require('streamsearch');\n\nvar B_DCRLF = new Buffer('\\r\\n\\r\\n'),\n    RE_CRLF = /\\r\\n/g,\n    RE_HDR = /^([^:]+):[ \\t]?([\\x00-\\xFF]+)?$/,\n    MAX_HEADER_PAIRS = 2000,\n    // from node's http.js\nMAX_HEADER_SIZE = 80 * 1024; // from node's http_parser\n\nfunction HeaderParser(cfg) {\n  EventEmitter.call(this);\n  var self = this;\n  this.nread = 0;\n  this.maxed = false;\n  this.npairs = 0;\n  this.maxHeaderPairs = cfg && typeof cfg.maxHeaderPairs === 'number' ? cfg.maxHeaderPairs : MAX_HEADER_PAIRS;\n  this.buffer = '';\n  this.header = {};\n  this.finished = false;\n  this.ss = new StreamSearch(B_DCRLF);\n  this.ss.on('info', function (isMatch, data, start, end) {\n    if (data && !self.maxed) {\n      if (self.nread + (end - start) > MAX_HEADER_SIZE) {\n        end = MAX_HEADER_SIZE - self.nread;\n        self.nread = MAX_HEADER_SIZE;\n      } else self.nread += end - start;\n\n      if (self.nread === MAX_HEADER_SIZE) self.maxed = true;\n      self.buffer += data.toString('binary', start, end);\n    }\n\n    if (isMatch) self._finish();\n  });\n}\n\ninherits(HeaderParser, EventEmitter);\n\nHeaderParser.prototype.push = function (data) {\n  var r = this.ss.push(data);\n  if (this.finished) return r;\n};\n\nHeaderParser.prototype.reset = function () {\n  this.finished = false;\n  this.buffer = '';\n  this.header = {};\n  this.ss.reset();\n};\n\nHeaderParser.prototype._finish = function () {\n  if (this.buffer) this._parseHeader();\n  this.ss.matches = this.ss.maxMatches;\n  var header = this.header;\n  this.header = {};\n  this.buffer = '';\n  this.finished = true;\n  this.nread = this.npairs = 0;\n  this.maxed = false;\n  this.emit('header', header);\n};\n\nHeaderParser.prototype._parseHeader = function () {\n  if (this.npairs === this.maxHeaderPairs) return;\n  var lines = this.buffer.split(RE_CRLF),\n      len = lines.length,\n      m,\n      h,\n      modded = false;\n\n  for (var i = 0; i < len; ++i) {\n    if (lines[i].length === 0) continue;\n\n    if (lines[i][0] === '\\t' || lines[i][0] === ' ') {\n      // folded header content\n      // RFC2822 says to just remove the CRLF and not the whitespace following\n      // it, so we follow the RFC and include the leading whitespace ...\n      this.header[h][this.header[h].length - 1] += lines[i];\n    } else {\n      m = RE_HDR.exec(lines[i]);\n\n      if (m) {\n        h = m[1].toLowerCase();\n\n        if (m[2]) {\n          if (this.header[h] === undefined) this.header[h] = [m[2]];else this.header[h].push(m[2]);\n        } else this.header[h] = [''];\n\n        if (++this.npairs === this.maxHeaderPairs) break;\n      } else {\n        this.buffer = lines[i];\n        modded = true;\n        break;\n      }\n    }\n  }\n\n  if (!modded) this.buffer = '';\n};\n\nmodule.exports = HeaderParser;","map":{"version":3,"names":["EventEmitter","require","inherits","StreamSearch","B_DCRLF","Buffer","RE_CRLF","RE_HDR","MAX_HEADER_PAIRS","MAX_HEADER_SIZE","HeaderParser","cfg","call","self","nread","maxed","npairs","maxHeaderPairs","buffer","header","finished","ss","on","isMatch","data","start","end","toString","_finish","prototype","push","r","reset","_parseHeader","matches","maxMatches","emit","lines","split","len","length","m","h","modded","i","exec","toLowerCase","undefined","module","exports"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/server/node_modules/dicer/lib/HeaderParser.js"],"sourcesContent":["var EventEmitter = require('events').EventEmitter,\n    inherits = require('util').inherits;\n\nvar StreamSearch = require('streamsearch');\n\nvar B_DCRLF = new Buffer('\\r\\n\\r\\n'),\n    RE_CRLF = /\\r\\n/g,\n    RE_HDR = /^([^:]+):[ \\t]?([\\x00-\\xFF]+)?$/,\n    MAX_HEADER_PAIRS = 2000, // from node's http.js\n    MAX_HEADER_SIZE = 80 * 1024; // from node's http_parser\n\nfunction HeaderParser(cfg) {\n  EventEmitter.call(this);\n\n  var self = this;\n  this.nread = 0;\n  this.maxed = false;\n  this.npairs = 0;\n  this.maxHeaderPairs = (cfg && typeof cfg.maxHeaderPairs === 'number'\n                         ? cfg.maxHeaderPairs\n                         : MAX_HEADER_PAIRS);\n  this.buffer = '';\n  this.header = {};\n  this.finished = false;\n  this.ss = new StreamSearch(B_DCRLF);\n  this.ss.on('info', function(isMatch, data, start, end) {\n    if (data && !self.maxed) {\n      if (self.nread + (end - start) > MAX_HEADER_SIZE) {\n        end = (MAX_HEADER_SIZE - self.nread);\n        self.nread = MAX_HEADER_SIZE;\n      } else\n        self.nread += (end - start);\n\n      if (self.nread === MAX_HEADER_SIZE)\n        self.maxed = true;\n\n      self.buffer += data.toString('binary', start, end);\n    }\n    if (isMatch)\n      self._finish();\n  });\n}\ninherits(HeaderParser, EventEmitter);\n\nHeaderParser.prototype.push = function(data) {\n  var r = this.ss.push(data);\n  if (this.finished)\n    return r;\n};\n\nHeaderParser.prototype.reset = function() {\n  this.finished = false;\n  this.buffer = '';\n  this.header = {};\n  this.ss.reset();\n};\n\nHeaderParser.prototype._finish = function() {\n  if (this.buffer)\n    this._parseHeader();\n  this.ss.matches = this.ss.maxMatches;\n  var header = this.header;\n  this.header = {};\n  this.buffer = '';\n  this.finished = true;\n  this.nread = this.npairs = 0;\n  this.maxed = false;\n  this.emit('header', header);\n};\n\nHeaderParser.prototype._parseHeader = function() {\n  if (this.npairs === this.maxHeaderPairs)\n    return;\n\n  var lines = this.buffer.split(RE_CRLF), len = lines.length, m, h,\n      modded = false;\n\n  for (var i = 0; i < len; ++i) {\n    if (lines[i].length === 0)\n      continue;\n    if (lines[i][0] === '\\t' || lines[i][0] === ' ') {\n      // folded header content\n      // RFC2822 says to just remove the CRLF and not the whitespace following\n      // it, so we follow the RFC and include the leading whitespace ...\n      this.header[h][this.header[h].length - 1] += lines[i];\n    } else {\n      m = RE_HDR.exec(lines[i]);\n      if (m) {\n        h = m[1].toLowerCase();\n        if (m[2]) {\n          if (this.header[h] === undefined)\n            this.header[h] = [m[2]];\n          else\n            this.header[h].push(m[2]);\n        } else\n          this.header[h] = [''];\n        if (++this.npairs === this.maxHeaderPairs)\n          break;\n      } else {\n        this.buffer = lines[i];\n        modded = true;\n        break;\n      }\n    }\n  }\n  if (!modded)\n    this.buffer = '';\n};\n\nmodule.exports = HeaderParser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}