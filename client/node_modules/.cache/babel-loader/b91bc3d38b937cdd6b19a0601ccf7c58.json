{"ast":null,"code":"/**\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\nimport { characterEntitiesLegacy } from 'character-entities-legacy';\nimport { characterReferenceInvalid } from 'character-reference-invalid';\nimport { isDecimal } from 'is-decimal';\nimport { isHexadecimal } from 'is-hexadecimal';\nimport { isAlphanumerical } from 'is-alphanumerical';\nimport { decodeNamedCharacterReference } from 'decode-named-character-reference';\nconst fromCharCode = String.fromCharCode; // Warning messages.\n\nconst messages = ['',\n/* 1: Non terminated (named) */\n'Named character references must be terminated by a semicolon',\n/* 2: Non terminated (numeric) */\n'Numeric character references must be terminated by a semicolon',\n/* 3: Empty (named) */\n'Named character references cannot be empty',\n/* 4: Empty (numeric) */\n'Numeric character references cannot be empty',\n/* 5: Unknown (named) */\n'Named character references must be known',\n/* 6: Disallowed (numeric) */\n'Numeric character references cannot be disallowed',\n/* 7: Prohibited (numeric) */\n'Numeric character references cannot be outside the permissible Unicode range'];\n/**\n * Parse HTML character references.\n *\n * @param {string} value\n * @param {import('../index.js').Options} [options={}]\n */\n\nexport function parseEntities(value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const additional = typeof options.additional === 'string' ? options.additional.charCodeAt(0) : options.additional;\n  /** @type {string[]} */\n\n  const result = [];\n  let index = 0;\n  let lines = -1;\n  let queue = '';\n  /** @type {Point|undefined} */\n\n  let point;\n  /** @type {number[]|undefined} */\n\n  let indent;\n\n  if (options.position) {\n    if ('start' in options.position || 'indent' in options.position) {\n      indent = options.position.indent;\n      point = options.position.start;\n    } else {\n      point = options.position;\n    }\n  }\n\n  let line = (point ? point.line : 0) || 1;\n  let column = (point ? point.column : 0) || 1; // Cache the current point.\n\n  let previous = now();\n  /** @type {number|undefined} */\n\n  let character; // Ensure the algorithm walks over the first character (inclusive).\n\n  index--;\n\n  while (++index <= value.length) {\n    // If the previous character was a newline.\n    if (character === 10\n    /* `\\n` */\n    ) {\n      column = (indent ? indent[lines] : 0) || 1;\n    }\n\n    character = value.charCodeAt(index);\n\n    if (character === 38\n    /* `&` */\n    ) {\n      const following = value.charCodeAt(index + 1); // The behavior depends on the identity of the next character.\n\n      if (following === 9\n      /* `\\t` */\n      || following === 10\n      /* `\\n` */\n      || following === 12\n      /* `\\f` */\n      || following === 32\n      /* ` ` */\n      || following === 38\n      /* `&` */\n      || following === 60\n      /* `<` */\n      || Number.isNaN(following) || additional && following === additional) {\n        // Not a character reference.\n        // No characters are consumed, and nothing is returned.\n        // This is not an error, either.\n        queue += fromCharCode(character);\n        column++;\n        continue;\n      }\n\n      const start = index + 1;\n      let begin = start;\n      let end = start;\n      /** @type {string} */\n\n      let type;\n\n      if (following === 35\n      /* `#` */\n      ) {\n        // Numerical reference.\n        end = ++begin; // The behavior further depends on the next character.\n\n        const following = value.charCodeAt(end);\n\n        if (following === 88\n        /* `X` */\n        || following === 120\n        /* `x` */\n        ) {\n          // ASCII hexadecimal digits.\n          type = 'hexadecimal';\n          end = ++begin;\n        } else {\n          // ASCII decimal digits.\n          type = 'decimal';\n        }\n      } else {\n        // Named reference.\n        type = 'named';\n      }\n\n      let characterReferenceCharacters = '';\n      let characterReference = '';\n      let characters = ''; // Each type of character reference accepts different characters.\n      // This test is used to detect whether a reference has ended (as the semicolon\n      // is not strictly needed).\n\n      const test = type === 'named' ? isAlphanumerical : type === 'decimal' ? isDecimal : isHexadecimal;\n      end--;\n\n      while (++end <= value.length) {\n        const following = value.charCodeAt(end);\n\n        if (!test(following)) {\n          break;\n        }\n\n        characters += fromCharCode(following); // Check if we can match a legacy named reference.\n        // If so, we cache that as the last viable named reference.\n        // This ensures we do not need to walk backwards later.\n\n        if (type === 'named' && characterEntitiesLegacy.includes(characters)) {\n          characterReferenceCharacters = characters; // @ts-expect-error: always able to decode.\n\n          characterReference = decodeNamedCharacterReference(characters);\n        }\n      }\n\n      let terminated = value.charCodeAt(end) === 59;\n      /* `;` */\n\n      if (terminated) {\n        end++;\n        const namedReference = type === 'named' ? decodeNamedCharacterReference(characters) : false;\n\n        if (namedReference) {\n          characterReferenceCharacters = characters;\n          characterReference = namedReference;\n        }\n      }\n\n      let diff = 1 + end - start;\n      let reference = '';\n\n      if (!terminated && options.nonTerminated === false) {// Empty.\n      } else if (!characters) {\n        // An empty (possible) reference is valid, unless it’s numeric (thus an\n        // ampersand followed by an octothorp).\n        if (type !== 'named') {\n          warning(4\n          /* Empty (numeric) */\n          , diff);\n        }\n      } else if (type === 'named') {\n        // An ampersand followed by anything unknown, and not terminated, is\n        // invalid.\n        if (terminated && !characterReference) {\n          warning(5\n          /* Unknown (named) */\n          , 1);\n        } else {\n          // If there’s something after an named reference which is not known,\n          // cap the reference.\n          if (characterReferenceCharacters !== characters) {\n            end = begin + characterReferenceCharacters.length;\n            diff = 1 + end - begin;\n            terminated = false;\n          } // If the reference is not terminated, warn.\n\n\n          if (!terminated) {\n            const reason = characterReferenceCharacters ? 1\n            /* Non terminated (named) */\n            : 3;\n            /* Empty (named) */\n\n            if (options.attribute) {\n              const following = value.charCodeAt(end);\n\n              if (following === 61\n              /* `=` */\n              ) {\n                warning(reason, diff);\n                characterReference = '';\n              } else if (isAlphanumerical(following)) {\n                characterReference = '';\n              } else {\n                warning(reason, diff);\n              }\n            } else {\n              warning(reason, diff);\n            }\n          }\n        }\n\n        reference = characterReference;\n      } else {\n        if (!terminated) {\n          // All nonterminated numeric references are not rendered, and emit a\n          // warning.\n          warning(2\n          /* Non terminated (numeric) */\n          , diff);\n        } // When terminated and numerical, parse as either hexadecimal or\n        // decimal.\n\n\n        let referenceCode = Number.parseInt(characters, type === 'hexadecimal' ? 16 : 10); // Emit a warning when the parsed number is prohibited, and replace with\n        // replacement character.\n\n        if (prohibited(referenceCode)) {\n          warning(7\n          /* Prohibited (numeric) */\n          , diff);\n          reference = fromCharCode(65533\n          /* `�` */\n          );\n        } else if (referenceCode in characterReferenceInvalid) {\n          // Emit a warning when the parsed number is disallowed, and replace by\n          // an alternative.\n          warning(6\n          /* Disallowed (numeric) */\n          , diff);\n          reference = characterReferenceInvalid[referenceCode];\n        } else {\n          // Parse the number.\n          let output = ''; // Emit a warning when the parsed number should not be used.\n\n          if (disallowed(referenceCode)) {\n            warning(6\n            /* Disallowed (numeric) */\n            , diff);\n          } // Serialize the number.\n\n\n          if (referenceCode > 0xffff) {\n            referenceCode -= 0x10000;\n            output += fromCharCode(referenceCode >>> (10 & 0x3ff) | 0xd800);\n            referenceCode = 0xdc00 | referenceCode & 0x3ff;\n          }\n\n          reference = output + fromCharCode(referenceCode);\n        }\n      } // Found it!\n      // First eat the queued characters as normal text, then eat a reference.\n\n\n      if (reference) {\n        flush();\n        previous = now();\n        index = end - 1;\n        column += end - start + 1;\n        result.push(reference);\n        const next = now();\n        next.offset++;\n\n        if (options.reference) {\n          options.reference.call(options.referenceContext, reference, {\n            start: previous,\n            end: next\n          }, value.slice(start - 1, end));\n        }\n\n        previous = next;\n      } else {\n        // If we could not find a reference, queue the checked characters (as\n        // normal characters), and move the pointer to their end.\n        // This is possible because we can be certain neither newlines nor\n        // ampersands are included.\n        characters = value.slice(start - 1, end);\n        queue += characters;\n        column += characters.length;\n        index = end - 1;\n      }\n    } else {\n      // Handle anything other than an ampersand, including newlines and EOF.\n      if (character === 10\n      /* `\\n` */\n      ) {\n        line++;\n        lines++;\n        column = 0;\n      }\n\n      if (Number.isNaN(character)) {\n        flush();\n      } else {\n        queue += fromCharCode(character);\n        column++;\n      }\n    }\n  } // Return the reduced nodes.\n\n\n  return result.join(''); // Get current position.\n\n  function now() {\n    return {\n      line,\n      column,\n      offset: index + ((point ? point.offset : 0) || 0)\n    };\n  }\n  /**\n   * Handle the warning.\n   *\n   * @param {1|2|3|4|5|6|7} code\n   * @param {number} offset\n   */\n\n\n  function warning(code, offset) {\n    /** @type {ReturnType<now>} */\n    let position;\n\n    if (options.warning) {\n      position = now();\n      position.column += offset;\n      position.offset += offset;\n      options.warning.call(options.warningContext, messages[code], position, code);\n    }\n  }\n  /**\n   * Flush `queue` (normal text).\n   * Macro invoked before each reference and at the end of `value`.\n   * Does nothing when `queue` is empty.\n   */\n\n\n  function flush() {\n    if (queue) {\n      result.push(queue);\n\n      if (options.text) {\n        options.text.call(options.textContext, queue, {\n          start: previous,\n          end: now()\n        });\n      }\n\n      queue = '';\n    }\n  }\n}\n/**\n * Check if `character` is outside the permissible unicode range.\n *\n * @param {number} code\n * @returns {boolean}\n */\n\nfunction prohibited(code) {\n  return code >= 0xd800 && code <= 0xdfff || code > 0x10ffff;\n}\n/**\n * Check if `character` is disallowed.\n *\n * @param {number} code\n * @returns {boolean}\n */\n\n\nfunction disallowed(code) {\n  return code >= 0x0001 && code <= 0x0008 || code === 0x000b || code >= 0x000d && code <= 0x001f || code >= 0x007f && code <= 0x009f || code >= 0xfdd0 && code <= 0xfdef || (code & 0xffff) === 0xffff || (code & 0xffff) === 0xfffe;\n}","map":{"version":3,"names":["characterEntitiesLegacy","characterReferenceInvalid","isDecimal","isHexadecimal","isAlphanumerical","decodeNamedCharacterReference","fromCharCode","String","messages","parseEntities","value","options","additional","charCodeAt","result","index","lines","queue","point","indent","position","start","line","column","previous","now","character","length","following","Number","isNaN","begin","end","type","characterReferenceCharacters","characterReference","characters","test","includes","terminated","namedReference","diff","reference","nonTerminated","warning","reason","attribute","referenceCode","parseInt","prohibited","output","disallowed","flush","push","next","offset","call","referenceContext","slice","join","code","warningContext","text","textContext"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/parse-entities/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\nimport {characterEntitiesLegacy} from 'character-entities-legacy'\nimport {characterReferenceInvalid} from 'character-reference-invalid'\nimport {isDecimal} from 'is-decimal'\nimport {isHexadecimal} from 'is-hexadecimal'\nimport {isAlphanumerical} from 'is-alphanumerical'\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\n\nconst fromCharCode = String.fromCharCode\n\n// Warning messages.\nconst messages = [\n  '',\n  /* 1: Non terminated (named) */\n  'Named character references must be terminated by a semicolon',\n  /* 2: Non terminated (numeric) */\n  'Numeric character references must be terminated by a semicolon',\n  /* 3: Empty (named) */\n  'Named character references cannot be empty',\n  /* 4: Empty (numeric) */\n  'Numeric character references cannot be empty',\n  /* 5: Unknown (named) */\n  'Named character references must be known',\n  /* 6: Disallowed (numeric) */\n  'Numeric character references cannot be disallowed',\n  /* 7: Prohibited (numeric) */\n  'Numeric character references cannot be outside the permissible Unicode range'\n]\n\n/**\n * Parse HTML character references.\n *\n * @param {string} value\n * @param {import('../index.js').Options} [options={}]\n */\nexport function parseEntities(value, options = {}) {\n  const additional =\n    typeof options.additional === 'string'\n      ? options.additional.charCodeAt(0)\n      : options.additional\n  /** @type {string[]} */\n  const result = []\n  let index = 0\n  let lines = -1\n  let queue = ''\n  /** @type {Point|undefined} */\n  let point\n  /** @type {number[]|undefined} */\n  let indent\n\n  if (options.position) {\n    if ('start' in options.position || 'indent' in options.position) {\n      indent = options.position.indent\n      point = options.position.start\n    } else {\n      point = options.position\n    }\n  }\n\n  let line = (point ? point.line : 0) || 1\n  let column = (point ? point.column : 0) || 1\n\n  // Cache the current point.\n  let previous = now()\n  /** @type {number|undefined} */\n  let character\n\n  // Ensure the algorithm walks over the first character (inclusive).\n  index--\n\n  while (++index <= value.length) {\n    // If the previous character was a newline.\n    if (character === 10 /* `\\n` */) {\n      column = (indent ? indent[lines] : 0) || 1\n    }\n\n    character = value.charCodeAt(index)\n\n    if (character === 38 /* `&` */) {\n      const following = value.charCodeAt(index + 1)\n\n      // The behavior depends on the identity of the next character.\n      if (\n        following === 9 /* `\\t` */ ||\n        following === 10 /* `\\n` */ ||\n        following === 12 /* `\\f` */ ||\n        following === 32 /* ` ` */ ||\n        following === 38 /* `&` */ ||\n        following === 60 /* `<` */ ||\n        Number.isNaN(following) ||\n        (additional && following === additional)\n      ) {\n        // Not a character reference.\n        // No characters are consumed, and nothing is returned.\n        // This is not an error, either.\n        queue += fromCharCode(character)\n        column++\n        continue\n      }\n\n      const start = index + 1\n      let begin = start\n      let end = start\n      /** @type {string} */\n      let type\n\n      if (following === 35 /* `#` */) {\n        // Numerical reference.\n        end = ++begin\n\n        // The behavior further depends on the next character.\n        const following = value.charCodeAt(end)\n\n        if (following === 88 /* `X` */ || following === 120 /* `x` */) {\n          // ASCII hexadecimal digits.\n          type = 'hexadecimal'\n          end = ++begin\n        } else {\n          // ASCII decimal digits.\n          type = 'decimal'\n        }\n      } else {\n        // Named reference.\n        type = 'named'\n      }\n\n      let characterReferenceCharacters = ''\n      let characterReference = ''\n      let characters = ''\n      // Each type of character reference accepts different characters.\n      // This test is used to detect whether a reference has ended (as the semicolon\n      // is not strictly needed).\n      const test =\n        type === 'named'\n          ? isAlphanumerical\n          : type === 'decimal'\n          ? isDecimal\n          : isHexadecimal\n\n      end--\n\n      while (++end <= value.length) {\n        const following = value.charCodeAt(end)\n\n        if (!test(following)) {\n          break\n        }\n\n        characters += fromCharCode(following)\n\n        // Check if we can match a legacy named reference.\n        // If so, we cache that as the last viable named reference.\n        // This ensures we do not need to walk backwards later.\n        if (type === 'named' && characterEntitiesLegacy.includes(characters)) {\n          characterReferenceCharacters = characters\n          // @ts-expect-error: always able to decode.\n          characterReference = decodeNamedCharacterReference(characters)\n        }\n      }\n\n      let terminated = value.charCodeAt(end) === 59 /* `;` */\n\n      if (terminated) {\n        end++\n\n        const namedReference =\n          type === 'named' ? decodeNamedCharacterReference(characters) : false\n\n        if (namedReference) {\n          characterReferenceCharacters = characters\n          characterReference = namedReference\n        }\n      }\n\n      let diff = 1 + end - start\n      let reference = ''\n\n      if (!terminated && options.nonTerminated === false) {\n        // Empty.\n      } else if (!characters) {\n        // An empty (possible) reference is valid, unless it’s numeric (thus an\n        // ampersand followed by an octothorp).\n        if (type !== 'named') {\n          warning(4 /* Empty (numeric) */, diff)\n        }\n      } else if (type === 'named') {\n        // An ampersand followed by anything unknown, and not terminated, is\n        // invalid.\n        if (terminated && !characterReference) {\n          warning(5 /* Unknown (named) */, 1)\n        } else {\n          // If there’s something after an named reference which is not known,\n          // cap the reference.\n          if (characterReferenceCharacters !== characters) {\n            end = begin + characterReferenceCharacters.length\n            diff = 1 + end - begin\n            terminated = false\n          }\n\n          // If the reference is not terminated, warn.\n          if (!terminated) {\n            const reason = characterReferenceCharacters\n              ? 1 /* Non terminated (named) */\n              : 3 /* Empty (named) */\n\n            if (options.attribute) {\n              const following = value.charCodeAt(end)\n\n              if (following === 61 /* `=` */) {\n                warning(reason, diff)\n                characterReference = ''\n              } else if (isAlphanumerical(following)) {\n                characterReference = ''\n              } else {\n                warning(reason, diff)\n              }\n            } else {\n              warning(reason, diff)\n            }\n          }\n        }\n\n        reference = characterReference\n      } else {\n        if (!terminated) {\n          // All nonterminated numeric references are not rendered, and emit a\n          // warning.\n          warning(2 /* Non terminated (numeric) */, diff)\n        }\n\n        // When terminated and numerical, parse as either hexadecimal or\n        // decimal.\n        let referenceCode = Number.parseInt(\n          characters,\n          type === 'hexadecimal' ? 16 : 10\n        )\n\n        // Emit a warning when the parsed number is prohibited, and replace with\n        // replacement character.\n        if (prohibited(referenceCode)) {\n          warning(7 /* Prohibited (numeric) */, diff)\n          reference = fromCharCode(65533 /* `�` */)\n        } else if (referenceCode in characterReferenceInvalid) {\n          // Emit a warning when the parsed number is disallowed, and replace by\n          // an alternative.\n          warning(6 /* Disallowed (numeric) */, diff)\n          reference = characterReferenceInvalid[referenceCode]\n        } else {\n          // Parse the number.\n          let output = ''\n\n          // Emit a warning when the parsed number should not be used.\n          if (disallowed(referenceCode)) {\n            warning(6 /* Disallowed (numeric) */, diff)\n          }\n\n          // Serialize the number.\n          if (referenceCode > 0xffff) {\n            referenceCode -= 0x10000\n            output += fromCharCode((referenceCode >>> (10 & 0x3ff)) | 0xd800)\n            referenceCode = 0xdc00 | (referenceCode & 0x3ff)\n          }\n\n          reference = output + fromCharCode(referenceCode)\n        }\n      }\n\n      // Found it!\n      // First eat the queued characters as normal text, then eat a reference.\n      if (reference) {\n        flush()\n\n        previous = now()\n        index = end - 1\n        column += end - start + 1\n        result.push(reference)\n        const next = now()\n        next.offset++\n\n        if (options.reference) {\n          options.reference.call(\n            options.referenceContext,\n            reference,\n            {start: previous, end: next},\n            value.slice(start - 1, end)\n          )\n        }\n\n        previous = next\n      } else {\n        // If we could not find a reference, queue the checked characters (as\n        // normal characters), and move the pointer to their end.\n        // This is possible because we can be certain neither newlines nor\n        // ampersands are included.\n        characters = value.slice(start - 1, end)\n        queue += characters\n        column += characters.length\n        index = end - 1\n      }\n    } else {\n      // Handle anything other than an ampersand, including newlines and EOF.\n      if (character === 10 /* `\\n` */) {\n        line++\n        lines++\n        column = 0\n      }\n\n      if (Number.isNaN(character)) {\n        flush()\n      } else {\n        queue += fromCharCode(character)\n        column++\n      }\n    }\n  }\n\n  // Return the reduced nodes.\n  return result.join('')\n\n  // Get current position.\n  function now() {\n    return {\n      line,\n      column,\n      offset: index + ((point ? point.offset : 0) || 0)\n    }\n  }\n\n  /**\n   * Handle the warning.\n   *\n   * @param {1|2|3|4|5|6|7} code\n   * @param {number} offset\n   */\n  function warning(code, offset) {\n    /** @type {ReturnType<now>} */\n    let position\n\n    if (options.warning) {\n      position = now()\n      position.column += offset\n      position.offset += offset\n\n      options.warning.call(\n        options.warningContext,\n        messages[code],\n        position,\n        code\n      )\n    }\n  }\n\n  /**\n   * Flush `queue` (normal text).\n   * Macro invoked before each reference and at the end of `value`.\n   * Does nothing when `queue` is empty.\n   */\n  function flush() {\n    if (queue) {\n      result.push(queue)\n\n      if (options.text) {\n        options.text.call(options.textContext, queue, {\n          start: previous,\n          end: now()\n        })\n      }\n\n      queue = ''\n    }\n  }\n}\n\n/**\n * Check if `character` is outside the permissible unicode range.\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction prohibited(code) {\n  return (code >= 0xd800 && code <= 0xdfff) || code > 0x10ffff\n}\n\n/**\n * Check if `character` is disallowed.\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction disallowed(code) {\n  return (\n    (code >= 0x0001 && code <= 0x0008) ||\n    code === 0x000b ||\n    (code >= 0x000d && code <= 0x001f) ||\n    (code >= 0x007f && code <= 0x009f) ||\n    (code >= 0xfdd0 && code <= 0xfdef) ||\n    (code & 0xffff) === 0xffff ||\n    (code & 0xffff) === 0xfffe\n  )\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}