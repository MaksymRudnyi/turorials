{"ast":null,"code":"// @ts-nocheck\nimport refractorMarkup from './markup.js';\nxquery.displayName = 'xquery';\nxquery.aliases = [];\n/** @type {import('../core.js').Syntax} */\n\nexport default function xquery(Prism) {\n  Prism.register(refractorMarkup);\n\n  (function (Prism) {\n    Prism.languages.xquery = Prism.languages.extend('markup', {\n      'xquery-comment': {\n        pattern: /\\(:[\\s\\S]*?:\\)/,\n        greedy: true,\n        alias: 'comment'\n      },\n      string: {\n        pattern: /([\"'])(?:\\1\\1|(?!\\1)[\\s\\S])*\\1/,\n        greedy: true\n      },\n      extension: {\n        pattern: /\\(#.+?#\\)/,\n        alias: 'symbol'\n      },\n      variable: /\\$[-\\w:]+/,\n      axis: {\n        pattern: /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,\n        lookbehind: true,\n        alias: 'operator'\n      },\n      'keyword-operator': {\n        pattern: /(^|[^:-])\\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\\b(?=$|[^:-])/,\n        lookbehind: true,\n        alias: 'operator'\n      },\n      keyword: {\n        pattern: /(^|[^:-])\\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\\b(?=$|[^:-])/,\n        lookbehind: true\n      },\n      function: /[\\w-]+(?::[\\w-]+)*(?=\\s*\\()/,\n      'xquery-element': {\n        pattern: /(element\\s+)[\\w-]+(?::[\\w-]+)*/,\n        lookbehind: true,\n        alias: 'tag'\n      },\n      'xquery-attribute': {\n        pattern: /(attribute\\s+)[\\w-]+(?::[\\w-]+)*/,\n        lookbehind: true,\n        alias: 'attr-name'\n      },\n      builtin: {\n        pattern: /(^|[^:-])\\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:ENTITIES|ENTITY|ID|IDREFS?|NCName|NMTOKENS?|NOTATION|Name|QName|anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|int|integer|language|long|negativeInteger|nonNegativeInteger|nonPositiveInteger|normalizedString|positiveInteger|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\\b(?=$|[^:-])/,\n        lookbehind: true\n      },\n      number: /\\b\\d+(?:\\.\\d+)?(?:E[+-]?\\d+)?/,\n      operator: [/[+*=?|@]|\\.\\.?|:=|!=|<[=<]?|>[=>]?/, {\n        pattern: /(\\s)-(?=\\s)/,\n        lookbehind: true\n      }],\n      punctuation: /[[\\](){},;:/]/\n    });\n    Prism.languages.xquery.tag.pattern = /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/;\n    Prism.languages.xquery['tag'].inside['attr-value'].pattern = /=(?:(\"|')(?:\\\\[\\s\\S]|\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+)/;\n    Prism.languages.xquery['tag'].inside['attr-value'].inside['punctuation'] = /^=\"|\"$/;\n    Prism.languages.xquery['tag'].inside['attr-value'].inside['expression'] = {\n      // Allow for two levels of nesting\n      pattern: /\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}/,\n      inside: Prism.languages.xquery,\n      alias: 'language-xquery'\n    }; // The following will handle plain text inside tags\n\n    var stringifyToken = function (token) {\n      if (typeof token === 'string') {\n        return token;\n      }\n\n      if (typeof token.content === 'string') {\n        return token.content;\n      }\n\n      return token.content.map(stringifyToken).join('');\n    };\n\n    var walkTokens = function (tokens) {\n      var openedTags = [];\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n        var notTagNorBrace = false;\n\n        if (typeof token !== 'string') {\n          if (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {\n            // We found a tag, now find its kind\n            if (token.content[0].content[0].content === '</') {\n              // Closing tag\n              if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {\n                // Pop matching opening tag\n                openedTags.pop();\n              }\n            } else {\n              if (token.content[token.content.length - 1].content === '/>') {// Autoclosed tag, ignore\n              } else {\n                // Opening tag\n                openedTags.push({\n                  tagName: stringifyToken(token.content[0].content[1]),\n                  openedBraces: 0\n                });\n              }\n            }\n          } else if (openedTags.length > 0 && token.type === 'punctuation' && token.content === '{' && ( // Ignore `{{`\n          !tokens[i + 1] || tokens[i + 1].type !== 'punctuation' || tokens[i + 1].content !== '{') && (!tokens[i - 1] || tokens[i - 1].type !== 'plain-text' || tokens[i - 1].content !== '{')) {\n            // Here we might have entered an XQuery expression inside a tag\n            openedTags[openedTags.length - 1].openedBraces++;\n          } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {\n            // Here we might have left an XQuery expression inside a tag\n            openedTags[openedTags.length - 1].openedBraces--;\n          } else if (token.type !== 'comment') {\n            notTagNorBrace = true;\n          }\n        }\n\n        if (notTagNorBrace || typeof token === 'string') {\n          if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\n            // Here we are inside a tag, and not inside an XQuery expression.\n            // That's plain text: drop any tokens matched.\n            var plainText = stringifyToken(token); // And merge text with adjacent text\n\n            if (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {\n              plainText += stringifyToken(tokens[i + 1]);\n              tokens.splice(i + 1, 1);\n            }\n\n            if (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {\n              plainText = stringifyToken(tokens[i - 1]) + plainText;\n              tokens.splice(i - 1, 1);\n              i--;\n            }\n\n            if (/^\\s+$/.test(plainText)) {\n              tokens[i] = plainText;\n            } else {\n              tokens[i] = new Prism.Token('plain-text', plainText, null, plainText);\n            }\n          }\n        }\n\n        if (token.content && typeof token.content !== 'string') {\n          walkTokens(token.content);\n        }\n      }\n    };\n\n    Prism.hooks.add('after-tokenize', function (env) {\n      if (env.language !== 'xquery') {\n        return;\n      }\n\n      walkTokens(env.tokens);\n    });\n  })(Prism);\n}","map":{"version":3,"names":["refractorMarkup","xquery","displayName","aliases","Prism","register","languages","extend","pattern","greedy","alias","string","extension","variable","axis","lookbehind","keyword","function","builtin","number","operator","punctuation","tag","inside","stringifyToken","token","content","map","join","walkTokens","tokens","openedTags","i","length","notTagNorBrace","type","tagName","pop","push","openedBraces","plainText","splice","test","Token","hooks","add","env","language"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/refractor/lang/xquery.js"],"sourcesContent":["// @ts-nocheck\nimport refractorMarkup from './markup.js'\nxquery.displayName = 'xquery'\nxquery.aliases = []\n\n/** @type {import('../core.js').Syntax} */\nexport default function xquery(Prism) {\n  Prism.register(refractorMarkup)\n  ;(function (Prism) {\n    Prism.languages.xquery = Prism.languages.extend('markup', {\n      'xquery-comment': {\n        pattern: /\\(:[\\s\\S]*?:\\)/,\n        greedy: true,\n        alias: 'comment'\n      },\n      string: {\n        pattern: /([\"'])(?:\\1\\1|(?!\\1)[\\s\\S])*\\1/,\n        greedy: true\n      },\n      extension: {\n        pattern: /\\(#.+?#\\)/,\n        alias: 'symbol'\n      },\n      variable: /\\$[-\\w:]+/,\n      axis: {\n        pattern:\n          /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,\n        lookbehind: true,\n        alias: 'operator'\n      },\n      'keyword-operator': {\n        pattern:\n          /(^|[^:-])\\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\\b(?=$|[^:-])/,\n        lookbehind: true,\n        alias: 'operator'\n      },\n      keyword: {\n        pattern:\n          /(^|[^:-])\\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\\b(?=$|[^:-])/,\n        lookbehind: true\n      },\n      function: /[\\w-]+(?::[\\w-]+)*(?=\\s*\\()/,\n      'xquery-element': {\n        pattern: /(element\\s+)[\\w-]+(?::[\\w-]+)*/,\n        lookbehind: true,\n        alias: 'tag'\n      },\n      'xquery-attribute': {\n        pattern: /(attribute\\s+)[\\w-]+(?::[\\w-]+)*/,\n        lookbehind: true,\n        alias: 'attr-name'\n      },\n      builtin: {\n        pattern:\n          /(^|[^:-])\\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:ENTITIES|ENTITY|ID|IDREFS?|NCName|NMTOKENS?|NOTATION|Name|QName|anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|int|integer|language|long|negativeInteger|nonNegativeInteger|nonPositiveInteger|normalizedString|positiveInteger|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\\b(?=$|[^:-])/,\n        lookbehind: true\n      },\n      number: /\\b\\d+(?:\\.\\d+)?(?:E[+-]?\\d+)?/,\n      operator: [\n        /[+*=?|@]|\\.\\.?|:=|!=|<[=<]?|>[=>]?/,\n        {\n          pattern: /(\\s)-(?=\\s)/,\n          lookbehind: true\n        }\n      ],\n      punctuation: /[[\\](){},;:/]/\n    })\n    Prism.languages.xquery.tag.pattern =\n      /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/\n    Prism.languages.xquery['tag'].inside['attr-value'].pattern =\n      /=(?:(\"|')(?:\\\\[\\s\\S]|\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+)/\n    Prism.languages.xquery['tag'].inside['attr-value'].inside['punctuation'] =\n      /^=\"|\"$/\n    Prism.languages.xquery['tag'].inside['attr-value'].inside['expression'] = {\n      // Allow for two levels of nesting\n      pattern: /\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}/,\n      inside: Prism.languages.xquery,\n      alias: 'language-xquery'\n    } // The following will handle plain text inside tags\n\n    var stringifyToken = function (token) {\n      if (typeof token === 'string') {\n        return token\n      }\n\n      if (typeof token.content === 'string') {\n        return token.content\n      }\n\n      return token.content.map(stringifyToken).join('')\n    }\n\n    var walkTokens = function (tokens) {\n      var openedTags = []\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i]\n        var notTagNorBrace = false\n\n        if (typeof token !== 'string') {\n          if (\n            token.type === 'tag' &&\n            token.content[0] &&\n            token.content[0].type === 'tag'\n          ) {\n            // We found a tag, now find its kind\n            if (token.content[0].content[0].content === '</') {\n              // Closing tag\n              if (\n                openedTags.length > 0 &&\n                openedTags[openedTags.length - 1].tagName ===\n                  stringifyToken(token.content[0].content[1])\n              ) {\n                // Pop matching opening tag\n                openedTags.pop()\n              }\n            } else {\n              if (token.content[token.content.length - 1].content === '/>') {\n                // Autoclosed tag, ignore\n              } else {\n                // Opening tag\n                openedTags.push({\n                  tagName: stringifyToken(token.content[0].content[1]),\n                  openedBraces: 0\n                })\n              }\n            }\n          } else if (\n            openedTags.length > 0 &&\n            token.type === 'punctuation' &&\n            token.content === '{' && // Ignore `{{`\n            (!tokens[i + 1] ||\n              tokens[i + 1].type !== 'punctuation' ||\n              tokens[i + 1].content !== '{') &&\n            (!tokens[i - 1] ||\n              tokens[i - 1].type !== 'plain-text' ||\n              tokens[i - 1].content !== '{')\n          ) {\n            // Here we might have entered an XQuery expression inside a tag\n            openedTags[openedTags.length - 1].openedBraces++\n          } else if (\n            openedTags.length > 0 &&\n            openedTags[openedTags.length - 1].openedBraces > 0 &&\n            token.type === 'punctuation' &&\n            token.content === '}'\n          ) {\n            // Here we might have left an XQuery expression inside a tag\n            openedTags[openedTags.length - 1].openedBraces--\n          } else if (token.type !== 'comment') {\n            notTagNorBrace = true\n          }\n        }\n\n        if (notTagNorBrace || typeof token === 'string') {\n          if (\n            openedTags.length > 0 &&\n            openedTags[openedTags.length - 1].openedBraces === 0\n          ) {\n            // Here we are inside a tag, and not inside an XQuery expression.\n            // That's plain text: drop any tokens matched.\n            var plainText = stringifyToken(token) // And merge text with adjacent text\n\n            if (\n              i < tokens.length - 1 &&\n              (typeof tokens[i + 1] === 'string' ||\n                tokens[i + 1].type === 'plain-text')\n            ) {\n              plainText += stringifyToken(tokens[i + 1])\n              tokens.splice(i + 1, 1)\n            }\n\n            if (\n              i > 0 &&\n              (typeof tokens[i - 1] === 'string' ||\n                tokens[i - 1].type === 'plain-text')\n            ) {\n              plainText = stringifyToken(tokens[i - 1]) + plainText\n              tokens.splice(i - 1, 1)\n              i--\n            }\n\n            if (/^\\s+$/.test(plainText)) {\n              tokens[i] = plainText\n            } else {\n              tokens[i] = new Prism.Token(\n                'plain-text',\n                plainText,\n                null,\n                plainText\n              )\n            }\n          }\n        }\n\n        if (token.content && typeof token.content !== 'string') {\n          walkTokens(token.content)\n        }\n      }\n    }\n\n    Prism.hooks.add('after-tokenize', function (env) {\n      if (env.language !== 'xquery') {\n        return\n      }\n\n      walkTokens(env.tokens)\n    })\n  })(Prism)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}