{"ast":null,"code":"var ERRORCLASS = \"error\";\n\nfunction wordRegexp(words) {\n  return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n}\n\nvar operators = /^(?:->|=>|\\+[+=]?|-[\\-=]?|\\*[\\*=]?|\\/[\\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\\|=?|\\^=?|\\~|!|\\?|(or|and|\\|\\||&&|\\?)=)/;\nvar delimiters = /^(?:[()\\[\\]{},:`=;]|\\.\\.?\\.?)/;\nvar identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;\nvar atProp = /^@[_A-Za-z$][_A-Za-z$0-9]*/;\nvar wordOperators = wordRegexp([\"and\", \"or\", \"not\", \"is\", \"isnt\", \"in\", \"instanceof\", \"typeof\"]);\nvar indentKeywords = [\"for\", \"while\", \"loop\", \"if\", \"unless\", \"else\", \"switch\", \"try\", \"catch\", \"finally\", \"class\"];\nvar commonKeywords = [\"break\", \"by\", \"continue\", \"debugger\", \"delete\", \"do\", \"in\", \"of\", \"new\", \"return\", \"then\", \"this\", \"@\", \"throw\", \"when\", \"until\", \"extends\"];\nvar keywords = wordRegexp(indentKeywords.concat(commonKeywords));\nindentKeywords = wordRegexp(indentKeywords);\nvar stringPrefixes = /^('{3}|\\\"{3}|['\\\"])/;\nvar regexPrefixes = /^(\\/{3}|\\/)/;\nvar commonConstants = [\"Infinity\", \"NaN\", \"undefined\", \"null\", \"true\", \"false\", \"on\", \"off\", \"yes\", \"no\"];\nvar constants = wordRegexp(commonConstants); // Tokenizers\n\nfunction tokenBase(stream, state) {\n  // Handle scope changes\n  if (stream.sol()) {\n    if (state.scope.align === null) state.scope.align = false;\n    var scopeOffset = state.scope.offset;\n\n    if (stream.eatSpace()) {\n      var lineOffset = stream.indentation();\n\n      if (lineOffset > scopeOffset && state.scope.type == \"coffee\") {\n        return \"indent\";\n      } else if (lineOffset < scopeOffset) {\n        return \"dedent\";\n      }\n\n      return null;\n    } else {\n      if (scopeOffset > 0) {\n        dedent(stream, state);\n      }\n    }\n  }\n\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  var ch = stream.peek(); // Handle docco title comment (single line)\n\n  if (stream.match(\"####\")) {\n    stream.skipToEnd();\n    return \"comment\";\n  } // Handle multi line comments\n\n\n  if (stream.match(\"###\")) {\n    state.tokenize = longComment;\n    return state.tokenize(stream, state);\n  } // Single line comment\n\n\n  if (ch === \"#\") {\n    stream.skipToEnd();\n    return \"comment\";\n  } // Handle number literals\n\n\n  if (stream.match(/^-?[0-9\\.]/, false)) {\n    var floatLiteral = false; // Floats\n\n    if (stream.match(/^-?\\d*\\.\\d+(e[\\+\\-]?\\d+)?/i)) {\n      floatLiteral = true;\n    }\n\n    if (stream.match(/^-?\\d+\\.\\d*/)) {\n      floatLiteral = true;\n    }\n\n    if (stream.match(/^-?\\.\\d+/)) {\n      floatLiteral = true;\n    }\n\n    if (floatLiteral) {\n      // prevent from getting extra . on 1..\n      if (stream.peek() == \".\") {\n        stream.backUp(1);\n      }\n\n      return \"number\";\n    } // Integers\n\n\n    var intLiteral = false; // Hex\n\n    if (stream.match(/^-?0x[0-9a-f]+/i)) {\n      intLiteral = true;\n    } // Decimal\n\n\n    if (stream.match(/^-?[1-9]\\d*(e[\\+\\-]?\\d+)?/)) {\n      intLiteral = true;\n    } // Zero by itself with no other piece of number.\n\n\n    if (stream.match(/^-?0(?![\\dx])/i)) {\n      intLiteral = true;\n    }\n\n    if (intLiteral) {\n      return \"number\";\n    }\n  } // Handle strings\n\n\n  if (stream.match(stringPrefixes)) {\n    state.tokenize = tokenFactory(stream.current(), false, \"string\");\n    return state.tokenize(stream, state);\n  } // Handle regex literals\n\n\n  if (stream.match(regexPrefixes)) {\n    if (stream.current() != \"/\" || stream.match(/^.*\\//, false)) {\n      // prevent highlight of division\n      state.tokenize = tokenFactory(stream.current(), true, \"string.special\");\n      return state.tokenize(stream, state);\n    } else {\n      stream.backUp(1);\n    }\n  } // Handle operators and delimiters\n\n\n  if (stream.match(operators) || stream.match(wordOperators)) {\n    return \"operator\";\n  }\n\n  if (stream.match(delimiters)) {\n    return \"punctuation\";\n  }\n\n  if (stream.match(constants)) {\n    return \"atom\";\n  }\n\n  if (stream.match(atProp) || state.prop && stream.match(identifiers)) {\n    return \"property\";\n  }\n\n  if (stream.match(keywords)) {\n    return \"keyword\";\n  }\n\n  if (stream.match(identifiers)) {\n    return \"variable\";\n  } // Handle non-detected items\n\n\n  stream.next();\n  return ERRORCLASS;\n}\n\nfunction tokenFactory(delimiter, singleline, outclass) {\n  return function (stream, state) {\n    while (!stream.eol()) {\n      stream.eatWhile(/[^'\"\\/\\\\]/);\n\n      if (stream.eat(\"\\\\\")) {\n        stream.next();\n\n        if (singleline && stream.eol()) {\n          return outclass;\n        }\n      } else if (stream.match(delimiter)) {\n        state.tokenize = tokenBase;\n        return outclass;\n      } else {\n        stream.eat(/['\"\\/]/);\n      }\n    }\n\n    if (singleline) {\n      state.tokenize = tokenBase;\n    }\n\n    return outclass;\n  };\n}\n\nfunction longComment(stream, state) {\n  while (!stream.eol()) {\n    stream.eatWhile(/[^#]/);\n\n    if (stream.match(\"###\")) {\n      state.tokenize = tokenBase;\n      break;\n    }\n\n    stream.eatWhile(\"#\");\n  }\n\n  return \"comment\";\n}\n\nfunction indent(stream, state) {\n  let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"coffee\";\n  var offset = 0,\n      align = false,\n      alignOffset = null;\n\n  for (var scope = state.scope; scope; scope = scope.prev) {\n    if (scope.type === \"coffee\" || scope.type == \"}\") {\n      offset = scope.offset + stream.indentUnit;\n      break;\n    }\n  }\n\n  if (type !== \"coffee\") {\n    align = null;\n    alignOffset = stream.column() + stream.current().length;\n  } else if (state.scope.align) {\n    state.scope.align = false;\n  }\n\n  state.scope = {\n    offset: offset,\n    type: type,\n    prev: state.scope,\n    align: align,\n    alignOffset: alignOffset\n  };\n}\n\nfunction dedent(stream, state) {\n  if (!state.scope.prev) return;\n\n  if (state.scope.type === \"coffee\") {\n    var _indent = stream.indentation();\n\n    var matched = false;\n\n    for (var scope = state.scope; scope; scope = scope.prev) {\n      if (_indent === scope.offset) {\n        matched = true;\n        break;\n      }\n    }\n\n    if (!matched) {\n      return true;\n    }\n\n    while (state.scope.prev && state.scope.offset !== _indent) {\n      state.scope = state.scope.prev;\n    }\n\n    return false;\n  } else {\n    state.scope = state.scope.prev;\n    return false;\n  }\n}\n\nfunction tokenLexer(stream, state) {\n  var style = state.tokenize(stream, state);\n  var current = stream.current(); // Handle scope changes.\n\n  if (current === \"return\") {\n    state.dedent = true;\n  }\n\n  if ((current === \"->\" || current === \"=>\") && stream.eol() || style === \"indent\") {\n    indent(stream, state);\n  }\n\n  var delimiter_index = \"[({\".indexOf(current);\n\n  if (delimiter_index !== -1) {\n    indent(stream, state, \"])}\".slice(delimiter_index, delimiter_index + 1));\n  }\n\n  if (indentKeywords.exec(current)) {\n    indent(stream, state);\n  }\n\n  if (current == \"then\") {\n    dedent(stream, state);\n  }\n\n  if (style === \"dedent\") {\n    if (dedent(stream, state)) {\n      return ERRORCLASS;\n    }\n  }\n\n  delimiter_index = \"])}\".indexOf(current);\n\n  if (delimiter_index !== -1) {\n    while (state.scope.type == \"coffee\" && state.scope.prev) state.scope = state.scope.prev;\n\n    if (state.scope.type == current) state.scope = state.scope.prev;\n  }\n\n  if (state.dedent && stream.eol()) {\n    if (state.scope.type == \"coffee\" && state.scope.prev) state.scope = state.scope.prev;\n    state.dedent = false;\n  }\n\n  return style == \"indent\" || style == \"dedent\" ? null : style;\n}\n\nexport const coffeeScript = {\n  startState: function () {\n    return {\n      tokenize: tokenBase,\n      scope: {\n        offset: 0,\n        type: \"coffee\",\n        prev: null,\n        align: false\n      },\n      prop: false,\n      dedent: 0\n    };\n  },\n  token: function (stream, state) {\n    var fillAlign = state.scope.align === null && state.scope;\n    if (fillAlign && stream.sol()) fillAlign.align = false;\n    var style = tokenLexer(stream, state);\n\n    if (style && style != \"comment\") {\n      if (fillAlign) fillAlign.align = true;\n      state.prop = style == \"punctuation\" && stream.current() == \".\";\n    }\n\n    return style;\n  },\n  indent: function (state, text) {\n    if (state.tokenize != tokenBase) return 0;\n    var scope = state.scope;\n    var closer = text && \"])}\".indexOf(text.charAt(0)) > -1;\n    if (closer) while (scope.type == \"coffee\" && scope.prev) scope = scope.prev;\n    var closes = closer && scope.type === text.charAt(0);\n    if (scope.align) return scope.alignOffset - (closes ? 1 : 0);else return (closes ? scope.prev : scope).offset;\n  },\n  languageData: {\n    commentTokens: {\n      line: \"#\"\n    }\n  }\n};","map":{"version":3,"names":["ERRORCLASS","wordRegexp","words","RegExp","join","operators","delimiters","identifiers","atProp","wordOperators","indentKeywords","commonKeywords","keywords","concat","stringPrefixes","regexPrefixes","commonConstants","constants","tokenBase","stream","state","sol","scope","align","scopeOffset","offset","eatSpace","lineOffset","indentation","type","dedent","ch","peek","match","skipToEnd","tokenize","longComment","floatLiteral","backUp","intLiteral","tokenFactory","current","prop","next","delimiter","singleline","outclass","eol","eatWhile","eat","indent","alignOffset","prev","indentUnit","column","length","_indent","matched","tokenLexer","style","delimiter_index","indexOf","slice","exec","coffeeScript","startState","token","fillAlign","text","closer","charAt","closes","languageData","commentTokens","line"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/@codemirror/legacy-modes/mode/coffeescript.js"],"sourcesContent":["var ERRORCLASS = \"error\";\n\nfunction wordRegexp(words) {\n  return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n}\n\nvar operators = /^(?:->|=>|\\+[+=]?|-[\\-=]?|\\*[\\*=]?|\\/[\\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\\|=?|\\^=?|\\~|!|\\?|(or|and|\\|\\||&&|\\?)=)/;\nvar delimiters = /^(?:[()\\[\\]{},:`=;]|\\.\\.?\\.?)/;\nvar identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;\nvar atProp = /^@[_A-Za-z$][_A-Za-z$0-9]*/;\n\nvar wordOperators = wordRegexp([\"and\", \"or\", \"not\",\n                                \"is\", \"isnt\", \"in\",\n                                \"instanceof\", \"typeof\"]);\nvar indentKeywords = [\"for\", \"while\", \"loop\", \"if\", \"unless\", \"else\",\n                      \"switch\", \"try\", \"catch\", \"finally\", \"class\"];\nvar commonKeywords = [\"break\", \"by\", \"continue\", \"debugger\", \"delete\",\n                      \"do\", \"in\", \"of\", \"new\", \"return\", \"then\",\n                      \"this\", \"@\", \"throw\", \"when\", \"until\", \"extends\"];\n\nvar keywords = wordRegexp(indentKeywords.concat(commonKeywords));\n\nindentKeywords = wordRegexp(indentKeywords);\n\n\nvar stringPrefixes = /^('{3}|\\\"{3}|['\\\"])/;\nvar regexPrefixes = /^(\\/{3}|\\/)/;\nvar commonConstants = [\"Infinity\", \"NaN\", \"undefined\", \"null\", \"true\", \"false\", \"on\", \"off\", \"yes\", \"no\"];\nvar constants = wordRegexp(commonConstants);\n\n// Tokenizers\nfunction tokenBase(stream, state) {\n  // Handle scope changes\n  if (stream.sol()) {\n    if (state.scope.align === null) state.scope.align = false;\n    var scopeOffset = state.scope.offset;\n    if (stream.eatSpace()) {\n      var lineOffset = stream.indentation();\n      if (lineOffset > scopeOffset && state.scope.type == \"coffee\") {\n        return \"indent\";\n      } else if (lineOffset < scopeOffset) {\n        return \"dedent\";\n      }\n      return null;\n    } else {\n      if (scopeOffset > 0) {\n        dedent(stream, state);\n      }\n    }\n  }\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  var ch = stream.peek();\n\n  // Handle docco title comment (single line)\n  if (stream.match(\"####\")) {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  // Handle multi line comments\n  if (stream.match(\"###\")) {\n    state.tokenize = longComment;\n    return state.tokenize(stream, state);\n  }\n\n  // Single line comment\n  if (ch === \"#\") {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  // Handle number literals\n  if (stream.match(/^-?[0-9\\.]/, false)) {\n    var floatLiteral = false;\n    // Floats\n    if (stream.match(/^-?\\d*\\.\\d+(e[\\+\\-]?\\d+)?/i)) {\n      floatLiteral = true;\n    }\n    if (stream.match(/^-?\\d+\\.\\d*/)) {\n      floatLiteral = true;\n    }\n    if (stream.match(/^-?\\.\\d+/)) {\n      floatLiteral = true;\n    }\n\n    if (floatLiteral) {\n      // prevent from getting extra . on 1..\n      if (stream.peek() == \".\"){\n        stream.backUp(1);\n      }\n      return \"number\";\n    }\n    // Integers\n    var intLiteral = false;\n    // Hex\n    if (stream.match(/^-?0x[0-9a-f]+/i)) {\n      intLiteral = true;\n    }\n    // Decimal\n    if (stream.match(/^-?[1-9]\\d*(e[\\+\\-]?\\d+)?/)) {\n      intLiteral = true;\n    }\n    // Zero by itself with no other piece of number.\n    if (stream.match(/^-?0(?![\\dx])/i)) {\n      intLiteral = true;\n    }\n    if (intLiteral) {\n      return \"number\";\n    }\n  }\n\n  // Handle strings\n  if (stream.match(stringPrefixes)) {\n    state.tokenize = tokenFactory(stream.current(), false, \"string\");\n    return state.tokenize(stream, state);\n  }\n  // Handle regex literals\n  if (stream.match(regexPrefixes)) {\n    if (stream.current() != \"/\" || stream.match(/^.*\\//, false)) { // prevent highlight of division\n      state.tokenize = tokenFactory(stream.current(), true, \"string.special\");\n      return state.tokenize(stream, state);\n    } else {\n      stream.backUp(1);\n    }\n  }\n\n\n\n  // Handle operators and delimiters\n  if (stream.match(operators) || stream.match(wordOperators)) {\n    return \"operator\";\n  }\n  if (stream.match(delimiters)) {\n    return \"punctuation\";\n  }\n\n  if (stream.match(constants)) {\n    return \"atom\";\n  }\n\n  if (stream.match(atProp) || state.prop && stream.match(identifiers)) {\n    return \"property\";\n  }\n\n  if (stream.match(keywords)) {\n    return \"keyword\";\n  }\n\n  if (stream.match(identifiers)) {\n    return \"variable\";\n  }\n\n  // Handle non-detected items\n  stream.next();\n  return ERRORCLASS;\n}\n\nfunction tokenFactory(delimiter, singleline, outclass) {\n  return function(stream, state) {\n    while (!stream.eol()) {\n      stream.eatWhile(/[^'\"\\/\\\\]/);\n      if (stream.eat(\"\\\\\")) {\n        stream.next();\n        if (singleline && stream.eol()) {\n          return outclass;\n        }\n      } else if (stream.match(delimiter)) {\n        state.tokenize = tokenBase;\n        return outclass;\n      } else {\n        stream.eat(/['\"\\/]/);\n      }\n    }\n    if (singleline) {\n      state.tokenize = tokenBase;\n    }\n    return outclass;\n  };\n}\n\nfunction longComment(stream, state) {\n  while (!stream.eol()) {\n    stream.eatWhile(/[^#]/);\n    if (stream.match(\"###\")) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    stream.eatWhile(\"#\");\n  }\n  return \"comment\";\n}\n\nfunction indent(stream, state, type = \"coffee\") {\n  var offset = 0, align = false, alignOffset = null;\n  for (var scope = state.scope; scope; scope = scope.prev) {\n    if (scope.type === \"coffee\" || scope.type == \"}\") {\n      offset = scope.offset + stream.indentUnit;\n      break;\n    }\n  }\n  if (type !== \"coffee\") {\n    align = null;\n    alignOffset = stream.column() + stream.current().length;\n  } else if (state.scope.align) {\n    state.scope.align = false;\n  }\n  state.scope = {\n    offset: offset,\n    type: type,\n    prev: state.scope,\n    align: align,\n    alignOffset: alignOffset\n  };\n}\n\nfunction dedent(stream, state) {\n  if (!state.scope.prev) return;\n  if (state.scope.type === \"coffee\") {\n    var _indent = stream.indentation();\n    var matched = false;\n    for (var scope = state.scope; scope; scope = scope.prev) {\n      if (_indent === scope.offset) {\n        matched = true;\n        break;\n      }\n    }\n    if (!matched) {\n      return true;\n    }\n    while (state.scope.prev && state.scope.offset !== _indent) {\n      state.scope = state.scope.prev;\n    }\n    return false;\n  } else {\n    state.scope = state.scope.prev;\n    return false;\n  }\n}\n\nfunction tokenLexer(stream, state) {\n  var style = state.tokenize(stream, state);\n  var current = stream.current();\n\n  // Handle scope changes.\n  if (current === \"return\") {\n    state.dedent = true;\n  }\n  if (((current === \"->\" || current === \"=>\") && stream.eol())\n      || style === \"indent\") {\n    indent(stream, state);\n  }\n  var delimiter_index = \"[({\".indexOf(current);\n  if (delimiter_index !== -1) {\n    indent(stream, state, \"])}\".slice(delimiter_index, delimiter_index+1));\n  }\n  if (indentKeywords.exec(current)){\n    indent(stream, state);\n  }\n  if (current == \"then\"){\n    dedent(stream, state);\n  }\n\n\n  if (style === \"dedent\") {\n    if (dedent(stream, state)) {\n      return ERRORCLASS;\n    }\n  }\n  delimiter_index = \"])}\".indexOf(current);\n  if (delimiter_index !== -1) {\n    while (state.scope.type == \"coffee\" && state.scope.prev)\n      state.scope = state.scope.prev;\n    if (state.scope.type == current)\n      state.scope = state.scope.prev;\n  }\n  if (state.dedent && stream.eol()) {\n    if (state.scope.type == \"coffee\" && state.scope.prev)\n      state.scope = state.scope.prev;\n    state.dedent = false;\n  }\n\n  return style == \"indent\" || style == \"dedent\" ? null : style;\n}\n\nexport const coffeeScript = {\n  startState: function() {\n    return {\n      tokenize: tokenBase,\n      scope: {offset: 0, type:\"coffee\", prev: null, align: false},\n      prop: false,\n      dedent: 0\n    };\n  },\n\n  token: function(stream, state) {\n    var fillAlign = state.scope.align === null && state.scope;\n    if (fillAlign && stream.sol()) fillAlign.align = false;\n\n    var style = tokenLexer(stream, state);\n    if (style && style != \"comment\") {\n      if (fillAlign) fillAlign.align = true;\n      state.prop = style == \"punctuation\" && stream.current() == \".\"\n    }\n\n    return style;\n  },\n\n  indent: function(state, text) {\n    if (state.tokenize != tokenBase) return 0;\n    var scope = state.scope;\n    var closer = text && \"])}\".indexOf(text.charAt(0)) > -1;\n    if (closer) while (scope.type == \"coffee\" && scope.prev) scope = scope.prev;\n    var closes = closer && scope.type === text.charAt(0);\n    if (scope.align)\n      return scope.alignOffset - (closes ? 1 : 0);\n    else\n      return (closes ? scope.prev : scope).offset;\n  },\n\n  languageData: {\n    commentTokens: {line: \"#\"}\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}