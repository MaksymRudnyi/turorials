{"ast":null,"code":"function parseWords(str) {\n  var obj = {},\n      words = str.split(\" \");\n\n  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n\n  return obj;\n}\n\nvar keywords = parseWords(\"Tcl safe after append array auto_execok auto_import auto_load \" + \"auto_mkindex auto_mkindex_old auto_qualify auto_reset bgerror \" + \"binary break catch cd close concat continue dde eof encoding error \" + \"eval exec exit expr fblocked fconfigure fcopy file fileevent filename \" + \"filename flush for foreach format gets glob global history http if \" + \"incr info interp join lappend lindex linsert list llength load lrange \" + \"lreplace lsearch lset lsort memory msgcat namespace open package parray \" + \"pid pkg::create pkg_mkIndex proc puts pwd re_syntax read regex regexp \" + \"registry regsub rename resource return scan seek set socket source split \" + \"string subst switch tcl_endOfWord tcl_findLibrary tcl_startOfNextWord \" + \"tcl_wordBreakAfter tcl_startOfPreviousWord tcl_wordBreakBefore tcltest \" + \"tclvars tell time trace unknown unset update uplevel upvar variable \" + \"vwait\");\nvar functions = parseWords(\"if elseif else and not or eq ne in ni for foreach while switch\");\nvar isOperatorChar = /[+\\-*&%=<>!?^\\/\\|]/;\n\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\n\nfunction tokenBase(stream, state) {\n  var beforeParams = state.beforeParams;\n  state.beforeParams = false;\n  var ch = stream.next();\n\n  if ((ch == '\"' || ch == \"'\") && state.inParams) {\n    return chain(stream, state, tokenString(ch));\n  } else if (/[\\[\\]{}\\(\\),;\\.]/.test(ch)) {\n    if (ch == \"(\" && beforeParams) state.inParams = true;else if (ch == \")\") state.inParams = false;\n    return null;\n  } else if (/\\d/.test(ch)) {\n    stream.eatWhile(/[\\w\\.]/);\n    return \"number\";\n  } else if (ch == \"#\") {\n    if (stream.eat(\"*\")) return chain(stream, state, tokenComment);\n    if (ch == \"#\" && stream.match(/ *\\[ *\\[/)) return chain(stream, state, tokenUnparsed);\n    stream.skipToEnd();\n    return \"comment\";\n  } else if (ch == '\"') {\n    stream.skipTo(/\"/);\n    return \"comment\";\n  } else if (ch == \"$\") {\n    stream.eatWhile(/[$_a-z0-9A-Z\\.{:]/);\n    stream.eatWhile(/}/);\n    state.beforeParams = true;\n    return \"builtin\";\n  } else if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return \"comment\";\n  } else {\n    stream.eatWhile(/[\\w\\$_{}\\xa1-\\uffff]/);\n    var word = stream.current().toLowerCase();\n    if (keywords && keywords.propertyIsEnumerable(word)) return \"keyword\";\n\n    if (functions && functions.propertyIsEnumerable(word)) {\n      state.beforeParams = true;\n      return \"keyword\";\n    }\n\n    return null;\n  }\n}\n\nfunction tokenString(quote) {\n  return function (stream, state) {\n    var escaped = false,\n        next,\n        end = false;\n\n    while ((next = stream.next()) != null) {\n      if (next == quote && !escaped) {\n        end = true;\n        break;\n      }\n\n      escaped = !escaped && next == \"\\\\\";\n    }\n\n    if (end) state.tokenize = tokenBase;\n    return \"string\";\n  };\n}\n\nfunction tokenComment(stream, state) {\n  var maybeEnd = false,\n      ch;\n\n  while (ch = stream.next()) {\n    if (ch == \"#\" && maybeEnd) {\n      state.tokenize = tokenBase;\n      break;\n    }\n\n    maybeEnd = ch == \"*\";\n  }\n\n  return \"comment\";\n}\n\nfunction tokenUnparsed(stream, state) {\n  var maybeEnd = 0,\n      ch;\n\n  while (ch = stream.next()) {\n    if (ch == \"#\" && maybeEnd == 2) {\n      state.tokenize = tokenBase;\n      break;\n    }\n\n    if (ch == \"]\") maybeEnd++;else if (ch != \" \") maybeEnd = 0;\n  }\n\n  return \"meta\";\n}\n\nexport const tcl = {\n  startState: function () {\n    return {\n      tokenize: tokenBase,\n      beforeParams: false,\n      inParams: false\n    };\n  },\n  token: function (stream, state) {\n    if (stream.eatSpace()) return null;\n    return state.tokenize(stream, state);\n  },\n  languageData: {\n    commentTokens: {\n      line: \"#\"\n    }\n  }\n};","map":{"version":3,"names":["parseWords","str","obj","words","split","i","length","keywords","functions","isOperatorChar","chain","stream","state","f","tokenize","tokenBase","beforeParams","ch","next","inParams","tokenString","test","eatWhile","eat","tokenComment","match","tokenUnparsed","skipToEnd","skipTo","word","current","toLowerCase","propertyIsEnumerable","quote","escaped","end","maybeEnd","tcl","startState","token","eatSpace","languageData","commentTokens","line"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/@codemirror/legacy-modes/mode/tcl.js"],"sourcesContent":["function parseWords(str) {\n  var obj = {}, words = str.split(\" \");\n  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n  return obj;\n}\nvar keywords = parseWords(\"Tcl safe after append array auto_execok auto_import auto_load \" +\n                          \"auto_mkindex auto_mkindex_old auto_qualify auto_reset bgerror \" +\n                          \"binary break catch cd close concat continue dde eof encoding error \" +\n                          \"eval exec exit expr fblocked fconfigure fcopy file fileevent filename \" +\n                          \"filename flush for foreach format gets glob global history http if \" +\n                          \"incr info interp join lappend lindex linsert list llength load lrange \" +\n                          \"lreplace lsearch lset lsort memory msgcat namespace open package parray \" +\n                          \"pid pkg::create pkg_mkIndex proc puts pwd re_syntax read regex regexp \" +\n                          \"registry regsub rename resource return scan seek set socket source split \" +\n                          \"string subst switch tcl_endOfWord tcl_findLibrary tcl_startOfNextWord \" +\n                          \"tcl_wordBreakAfter tcl_startOfPreviousWord tcl_wordBreakBefore tcltest \" +\n                          \"tclvars tell time trace unknown unset update uplevel upvar variable \" +\n                          \"vwait\");\nvar functions = parseWords(\"if elseif else and not or eq ne in ni for foreach while switch\");\nvar isOperatorChar = /[+\\-*&%=<>!?^\\/\\|]/;\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\nfunction tokenBase(stream, state) {\n  var beforeParams = state.beforeParams;\n  state.beforeParams = false;\n  var ch = stream.next();\n  if ((ch == '\"' || ch == \"'\") && state.inParams) {\n    return chain(stream, state, tokenString(ch));\n  } else if (/[\\[\\]{}\\(\\),;\\.]/.test(ch)) {\n    if (ch == \"(\" && beforeParams) state.inParams = true;\n    else if (ch == \")\") state.inParams = false;\n    return null;\n  } else if (/\\d/.test(ch)) {\n    stream.eatWhile(/[\\w\\.]/);\n    return \"number\";\n  } else if (ch == \"#\") {\n    if (stream.eat(\"*\"))\n      return chain(stream, state, tokenComment);\n    if (ch == \"#\" && stream.match(/ *\\[ *\\[/))\n      return chain(stream, state, tokenUnparsed);\n    stream.skipToEnd();\n    return \"comment\";\n  } else if (ch == '\"') {\n    stream.skipTo(/\"/);\n    return \"comment\";\n  } else if (ch == \"$\") {\n    stream.eatWhile(/[$_a-z0-9A-Z\\.{:]/);\n    stream.eatWhile(/}/);\n    state.beforeParams = true;\n    return \"builtin\";\n  } else if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return \"comment\";\n  } else {\n    stream.eatWhile(/[\\w\\$_{}\\xa1-\\uffff]/);\n    var word = stream.current().toLowerCase();\n    if (keywords && keywords.propertyIsEnumerable(word))\n      return \"keyword\";\n    if (functions && functions.propertyIsEnumerable(word)) {\n      state.beforeParams = true;\n      return \"keyword\";\n    }\n    return null;\n  }\n}\nfunction tokenString(quote) {\n  return function(stream, state) {\n    var escaped = false, next, end = false;\n    while ((next = stream.next()) != null) {\n      if (next == quote && !escaped) {\n        end = true;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    if (end) state.tokenize = tokenBase;\n    return \"string\";\n  };\n}\nfunction tokenComment(stream, state) {\n  var maybeEnd = false, ch;\n  while (ch = stream.next()) {\n    if (ch == \"#\" && maybeEnd) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    maybeEnd = (ch == \"*\");\n  }\n  return \"comment\";\n}\nfunction tokenUnparsed(stream, state) {\n  var maybeEnd = 0, ch;\n  while (ch = stream.next()) {\n    if (ch == \"#\" && maybeEnd == 2) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    if (ch == \"]\")\n      maybeEnd++;\n    else if (ch != \" \")\n      maybeEnd = 0;\n  }\n  return \"meta\";\n}\nexport const tcl = {\n  startState: function() {\n    return {\n      tokenize: tokenBase,\n      beforeParams: false,\n      inParams: false\n    };\n  },\n  token: function(stream, state) {\n    if (stream.eatSpace()) return null;\n    return state.tokenize(stream, state);\n  },\n  languageData: {\n    commentTokens: {line: \"#\"}\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}