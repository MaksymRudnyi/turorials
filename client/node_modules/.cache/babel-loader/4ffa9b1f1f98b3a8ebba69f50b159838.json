{"ast":null,"code":"import { NodeProp } from '@lezer/common';\nlet nextTagID = 0; /// Highlighting tags are markers that denote a highlighting category.\n/// They are [associated](#highlight.styleTags) with parts of a syntax\n/// tree by a language mode, and then mapped to an actual CSS style by\n/// a [highlighter](#highlight.Highlighter).\n///\n/// Because syntax tree node types and highlight styles have to be\n/// able to talk the same language, CodeMirror uses a mostly _closed_\n/// [vocabulary](#highlight.tags) of syntax tags (as opposed to\n/// traditional open string-based systems, which make it hard for\n/// highlighting themes to cover all the tokens produced by the\n/// various languages).\n///\n/// It _is_ possible to [define](#highlight.Tag^define) your own\n/// highlighting tags for system-internal use (where you control both\n/// the language package and the highlighter), but such tags will not\n/// be picked up by regular highlighters (though you can derive them\n/// from standard tags to allow highlighters to fall back to those).\n\nclass Tag {\n  /// @internal\n  constructor( /// The set of this tag and all its parent tags, starting with\n  /// this one itself and sorted in order of decreasing specificity.\n  set, /// The base unmodified tag that this one is based on, if it's\n  /// modified @internal\n  base, /// The modifiers applied to this.base @internal\n  modified) {\n    this.set = set;\n    this.base = base;\n    this.modified = modified; /// @internal\n\n    this.id = nextTagID++;\n  } /// Define a new tag. If `parent` is given, the tag is treated as a\n  /// sub-tag of that parent, and\n  /// [highlighters](#highlight.tagHighlighter) that don't mention\n  /// this tag will try to fall back to the parent tag (or grandparent\n  /// tag, etc).\n\n\n  static define(parent) {\n    if (parent === null || parent === void 0 ? void 0 : parent.base) throw new Error(\"Can not derive from a modified tag\");\n    let tag = new Tag([], null, []);\n    tag.set.push(tag);\n    if (parent) for (let t of parent.set) tag.set.push(t);\n    return tag;\n  } /// Define a tag _modifier_, which is a function that, given a tag,\n  /// will return a tag that is a subtag of the original. Applying the\n  /// same modifier to a twice tag will return the same value (`m1(t1)\n  /// == m1(t1)`) and applying multiple modifiers will, regardless or\n  /// order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n  ///\n  /// When multiple modifiers are applied to a given base tag, each\n  /// smaller set of modifiers is registered as a parent, so that for\n  /// example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n  /// `m1(m3(t1)`, and so on.\n\n\n  static defineModifier() {\n    let mod = new Modifier();\n    return tag => {\n      if (tag.modified.indexOf(mod) > -1) return tag;\n      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));\n    };\n  }\n\n}\n\nlet nextModifierID = 0;\n\nclass Modifier {\n  constructor() {\n    this.instances = [];\n    this.id = nextModifierID++;\n  }\n\n  static get(base, mods) {\n    if (!mods.length) return base;\n    let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));\n    if (exists) return exists;\n    let set = [],\n        tag = new Tag(set, base, mods);\n\n    for (let m of mods) m.instances.push(tag);\n\n    let configs = permute(mods);\n\n    for (let parent of base.set) for (let config of configs) set.push(Modifier.get(parent, config));\n\n    return tag;\n  }\n\n}\n\nfunction sameArray(a, b) {\n  return a.length == b.length && a.every((x, i) => x == b[i]);\n}\n\nfunction permute(array) {\n  let result = [array];\n\n  for (let i = 0; i < array.length; i++) {\n    for (let a of permute(array.slice(0, i).concat(array.slice(i + 1)))) result.push(a);\n  }\n\n  return result;\n} /// This function is used to add a set of tags to a language syntax\n/// via [`NodeSet.extend`](#common.NodeSet.extend) or\n/// [`LRParser.configure`](#lr.LRParser.configure).\n///\n/// The argument object maps node selectors to [highlighting\n/// tags](#highlight.Tag) or arrays of tags.\n///\n/// Node selectors may hold one or more (space-separated) node paths.\n/// Such a path can be a [node name](#common.NodeType.name), or\n/// multiple node names (or `*` wildcards) separated by slash\n/// characters, as in `\"Block/Declaration/VariableName\"`. Such a path\n/// matches the final node but only if its direct parent nodes are the\n/// other nodes mentioned. A `*` in such a path matches any parent,\n/// but only a single level—wildcards that match multiple parents\n/// aren't supported, both for efficiency reasons and because Lezer\n/// trees make it rather hard to reason about what they would match.)\n///\n/// A path can be ended with `/...` to indicate that the tag assigned\n/// to the node should also apply to all child nodes, even if they\n/// match their own style (by default, only the innermost style is\n/// used).\n///\n/// When a path ends in `!`, as in `Attribute!`, no further matching\n/// happens for the node's child nodes, and the entire node gets the\n/// given style.\n///\n/// In this notation, node names that contain `/`, `!`, `*`, or `...`\n/// must be quoted as JSON strings.\n///\n/// For example:\n///\n/// ```javascript\n/// parser.withProps(\n///   styleTags({\n///     // Style Number and BigNumber nodes\n///     \"Number BigNumber\": tags.number,\n///     // Style Escape nodes whose parent is String\n///     \"String/Escape\": tags.escape,\n///     // Style anything inside Attributes nodes\n///     \"Attributes!\": tags.meta,\n///     // Add a style to all content inside Italic nodes\n///     \"Italic/...\": tags.emphasis,\n///     // Style InvalidString nodes as both `string` and `invalid`\n///     \"InvalidString\": [tags.string, tags.invalid],\n///     // Style the node named \"/\" as punctuation\n///     '\"/\"': tags.punctuation\n///   })\n/// )\n/// ```\n\n\nfunction styleTags(spec) {\n  let byName = Object.create(null);\n\n  for (let prop in spec) {\n    let tags = spec[prop];\n    if (!Array.isArray(tags)) tags = [tags];\n\n    for (let part of prop.split(\" \")) if (part) {\n      let pieces = [],\n          mode = 2\n      /* Normal */\n      ,\n          rest = part;\n\n      for (let pos = 0;;) {\n        if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n          mode = 1\n          /* Inherit */\n          ;\n          break;\n        }\n\n        let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n        if (!m) throw new RangeError(\"Invalid path: \" + part);\n        pieces.push(m[0] == \"*\" ? \"\" : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n        pos += m[0].length;\n        if (pos == part.length) break;\n        let next = part[pos++];\n\n        if (pos == part.length && next == \"!\") {\n          mode = 0\n          /* Opaque */\n          ;\n          break;\n        }\n\n        if (next != \"/\") throw new RangeError(\"Invalid path: \" + part);\n        rest = part.slice(pos);\n      }\n\n      let last = pieces.length - 1,\n          inner = pieces[last];\n      if (!inner) throw new RangeError(\"Invalid path: \" + part);\n      let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n      byName[inner] = rule.sort(byName[inner]);\n    }\n  }\n\n  return ruleNodeProp.add(byName);\n}\n\nconst ruleNodeProp = new NodeProp();\n\nclass Rule {\n  constructor(tags, mode, context, next) {\n    this.tags = tags;\n    this.mode = mode;\n    this.context = context;\n    this.next = next;\n  }\n\n  sort(other) {\n    if (!other || other.depth < this.depth) {\n      this.next = other;\n      return this;\n    }\n\n    other.next = this.sort(other.next);\n    return other;\n  }\n\n  get depth() {\n    return this.context ? this.context.length : 0;\n  }\n\n} /// Define a [highlighter](#highlight.Highlighter) from an array of\n/// tag/class pairs. Classes associated with more specific tags will\n/// take precedence.\n\n\nfunction tagHighlighter(tags, options) {\n  let map = Object.create(null);\n\n  for (let style of tags) {\n    if (!Array.isArray(style.tag)) map[style.tag.id] = style.class;else for (let tag of style.tag) map[tag.id] = style.class;\n  }\n\n  let {\n    scope,\n    all = null\n  } = options || {};\n  return {\n    style: tags => {\n      let cls = all;\n\n      for (let tag of tags) {\n        for (let sub of tag.set) {\n          let tagClass = map[sub.id];\n\n          if (tagClass) {\n            cls = cls ? cls + \" \" + tagClass : tagClass;\n            break;\n          }\n        }\n      }\n\n      return cls;\n    },\n    scope: scope\n  };\n}\n\nfunction highlightTags(highlighters, tags) {\n  let result = null;\n\n  for (let highlighter of highlighters) {\n    let value = highlighter.style(tags);\n    if (value) result = result ? result + \" \" + value : value;\n  }\n\n  return result;\n} /// Highlight the given [tree](#common.Tree) with the given\n/// [highlighter](#highlight.Highlighter).\n\n\nfunction highlightTree(tree, highlighter, /// Assign styling to a region of the text. Will be called, in order\n/// of position, for any ranges where more than zero classes apply.\n/// `classes` is a space separated string of CSS classes.\nputStyle) {\n  let from = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let to = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : tree.length;\n  let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);\n  builder.highlightRange(tree.cursor(), from, to, \"\", builder.highlighters);\n  builder.flush(to);\n}\n\nclass HighlightBuilder {\n  constructor(at, highlighters, span) {\n    this.at = at;\n    this.highlighters = highlighters;\n    this.span = span;\n    this.class = \"\";\n  }\n\n  startSpan(at, cls) {\n    if (cls != this.class) {\n      this.flush(at);\n      if (at > this.at) this.at = at;\n      this.class = cls;\n    }\n  }\n\n  flush(to) {\n    if (to > this.at && this.class) this.span(this.at, to, this.class);\n  }\n\n  highlightRange(cursor, from, to, inheritedClass, highlighters) {\n    let {\n      type,\n      from: start,\n      to: end\n    } = cursor;\n    if (start >= to || end <= from) return;\n    if (type.isTop) highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));\n    let cls = inheritedClass;\n    let rule = type.prop(ruleNodeProp),\n        opaque = false;\n\n    while (rule) {\n      if (!rule.context || cursor.matchContext(rule.context)) {\n        let tagCls = highlightTags(highlighters, rule.tags);\n\n        if (tagCls) {\n          if (cls) cls += \" \";\n          cls += tagCls;\n          if (rule.mode == 1\n          /* Inherit */\n          ) inheritedClass += (inheritedClass ? \" \" : \"\") + tagCls;else if (rule.mode == 0\n          /* Opaque */\n          ) opaque = true;\n        }\n\n        break;\n      }\n\n      rule = rule.next;\n    }\n\n    this.startSpan(cursor.from, cls);\n    if (opaque) return;\n    let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);\n\n    if (mounted && mounted.overlay) {\n      let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n      let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));\n      let hasChild = cursor.firstChild();\n\n      for (let i = 0, pos = start;; i++) {\n        let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n        let nextPos = next ? next.from + start : end;\n        let rangeFrom = Math.max(from, pos),\n            rangeTo = Math.min(to, nextPos);\n\n        if (rangeFrom < rangeTo && hasChild) {\n          while (cursor.from < rangeTo) {\n            this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);\n            this.startSpan(Math.min(to, cursor.to), cls);\n            if (cursor.to >= nextPos || !cursor.nextSibling()) break;\n          }\n        }\n\n        if (!next || nextPos > to) break;\n        pos = next.to + start;\n\n        if (pos > from) {\n          this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, innerHighlighters);\n          this.startSpan(pos, cls);\n        }\n      }\n\n      if (hasChild) cursor.parent();\n    } else if (cursor.firstChild()) {\n      do {\n        if (cursor.to <= from) continue;\n        if (cursor.from >= to) break;\n        this.highlightRange(cursor, from, to, inheritedClass, highlighters);\n        this.startSpan(Math.min(to, cursor.to), cls);\n      } while (cursor.nextSibling());\n\n      cursor.parent();\n    }\n  }\n\n}\n\nconst t = Tag.define;\nconst comment = t(),\n      name = t(),\n      typeName = t(name),\n      propertyName = t(name),\n      literal = t(),\n      string = t(literal),\n      number = t(literal),\n      content = t(),\n      heading = t(content),\n      keyword = t(),\n      operator = t(),\n      punctuation = t(),\n      bracket = t(punctuation),\n      meta = t(); /// The default set of highlighting [tags](#highlight.Tag).\n///\n/// This collection is heavily biased towards programming languages,\n/// and necessarily incomplete. A full ontology of syntactic\n/// constructs would fill a stack of books, and be impractical to\n/// write themes for. So try to make do with this set. If all else\n/// fails, [open an\n/// issue](https://github.com/codemirror/codemirror.next) to propose a\n/// new tag, or [define](#highlight.Tag^define) a local custom tag for\n/// your use case.\n///\n/// Note that it is not obligatory to always attach the most specific\n/// tag possible to an element—if your grammar can't easily\n/// distinguish a certain type of element (such as a local variable),\n/// it is okay to style it as its more general variant (a variable).\n/// \n/// For tags that extend some parent tag, the documentation links to\n/// the parent.\n\nconst tags = {\n  /// A comment.\n  comment,\n  /// A line [comment](#highlight.tags.comment).\n  lineComment: t(comment),\n  /// A block [comment](#highlight.tags.comment).\n  blockComment: t(comment),\n  /// A documentation [comment](#highlight.tags.comment).\n  docComment: t(comment),\n  /// Any kind of identifier.\n  name,\n  /// The [name](#highlight.tags.name) of a variable.\n  variableName: t(name),\n  /// A type [name](#highlight.tags.name).\n  typeName: typeName,\n  /// A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n  tagName: t(typeName),\n  /// A property or field [name](#highlight.tags.name).\n  propertyName: propertyName,\n  /// An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\n  attributeName: t(propertyName),\n  /// The [name](#highlight.tags.name) of a class.\n  className: t(name),\n  /// A label [name](#highlight.tags.name).\n  labelName: t(name),\n  /// A namespace [name](#highlight.tags.name).\n  namespace: t(name),\n  /// The [name](#highlight.tags.name) of a macro.\n  macroName: t(name),\n  /// A literal value.\n  literal,\n  /// A string [literal](#highlight.tags.literal).\n  string,\n  /// A documentation [string](#highlight.tags.string).\n  docString: t(string),\n  /// A character literal (subtag of [string](#highlight.tags.string)).\n  character: t(string),\n  /// An attribute value (subtag of [string](#highlight.tags.string)).\n  attributeValue: t(string),\n  /// A number [literal](#highlight.tags.literal).\n  number,\n  /// An integer [number](#highlight.tags.number) literal.\n  integer: t(number),\n  /// A floating-point [number](#highlight.tags.number) literal.\n  float: t(number),\n  /// A boolean [literal](#highlight.tags.literal).\n  bool: t(literal),\n  /// Regular expression [literal](#highlight.tags.literal).\n  regexp: t(literal),\n  /// An escape [literal](#highlight.tags.literal), for example a\n  /// backslash escape in a string.\n  escape: t(literal),\n  /// A color [literal](#highlight.tags.literal).\n  color: t(literal),\n  /// A URL [literal](#highlight.tags.literal).\n  url: t(literal),\n  /// A language keyword.\n  keyword,\n  /// The [keyword](#highlight.tags.keyword) for the self or this\n  /// object.\n  self: t(keyword),\n  /// The [keyword](#highlight.tags.keyword) for null.\n  null: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) denoting some atomic value.\n  atom: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) that represents a unit.\n  unit: t(keyword),\n  /// A modifier [keyword](#highlight.tags.keyword).\n  modifier: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) that acts as an operator.\n  operatorKeyword: t(keyword),\n  /// A control-flow related [keyword](#highlight.tags.keyword).\n  controlKeyword: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) that defines something.\n  definitionKeyword: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) related to defining or\n  /// interfacing with modules.\n  moduleKeyword: t(keyword),\n  /// An operator.\n  operator,\n  /// An [operator](#highlight.tags.operator) that defines something.\n  derefOperator: t(operator),\n  /// Arithmetic-related [operator](#highlight.tags.operator).\n  arithmeticOperator: t(operator),\n  /// Logical [operator](#highlight.tags.operator).\n  logicOperator: t(operator),\n  /// Bit [operator](#highlight.tags.operator).\n  bitwiseOperator: t(operator),\n  /// Comparison [operator](#highlight.tags.operator).\n  compareOperator: t(operator),\n  /// [Operator](#highlight.tags.operator) that updates its operand.\n  updateOperator: t(operator),\n  /// [Operator](#highlight.tags.operator) that defines something.\n  definitionOperator: t(operator),\n  /// Type-related [operator](#highlight.tags.operator).\n  typeOperator: t(operator),\n  /// Control-flow [operator](#highlight.tags.operator).\n  controlOperator: t(operator),\n  /// Program or markup punctuation.\n  punctuation,\n  /// [Punctuation](#highlight.tags.punctuation) that separates\n  /// things.\n  separator: t(punctuation),\n  /// Bracket-style [punctuation](#highlight.tags.punctuation).\n  bracket,\n  /// Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n  /// tokens).\n  angleBracket: t(bracket),\n  /// Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n  /// tokens).\n  squareBracket: t(bracket),\n  /// Parentheses (usually `(` and `)` tokens). Subtag of\n  /// [bracket](#highlight.tags.bracket).\n  paren: t(bracket),\n  /// Braces (usually `{` and `}` tokens). Subtag of\n  /// [bracket](#highlight.tags.bracket).\n  brace: t(bracket),\n  /// Content, for example plain text in XML or markup documents.\n  content,\n  /// [Content](#highlight.tags.content) that represents a heading.\n  heading,\n  /// A level 1 [heading](#highlight.tags.heading).\n  heading1: t(heading),\n  /// A level 2 [heading](#highlight.tags.heading).\n  heading2: t(heading),\n  /// A level 3 [heading](#highlight.tags.heading).\n  heading3: t(heading),\n  /// A level 4 [heading](#highlight.tags.heading).\n  heading4: t(heading),\n  /// A level 5 [heading](#highlight.tags.heading).\n  heading5: t(heading),\n  /// A level 6 [heading](#highlight.tags.heading).\n  heading6: t(heading),\n  /// A prose separator (such as a horizontal rule).\n  contentSeparator: t(content),\n  /// [Content](#highlight.tags.content) that represents a list.\n  list: t(content),\n  /// [Content](#highlight.tags.content) that represents a quote.\n  quote: t(content),\n  /// [Content](#highlight.tags.content) that is emphasized.\n  emphasis: t(content),\n  /// [Content](#highlight.tags.content) that is styled strong.\n  strong: t(content),\n  /// [Content](#highlight.tags.content) that is part of a link.\n  link: t(content),\n  /// [Content](#highlight.tags.content) that is styled as code or\n  /// monospace.\n  monospace: t(content),\n  /// [Content](#highlight.tags.content) that has a strike-through\n  /// style.\n  strikethrough: t(content),\n  /// Inserted text in a change-tracking format.\n  inserted: t(),\n  /// Deleted text.\n  deleted: t(),\n  /// Changed text.\n  changed: t(),\n  /// An invalid or unsyntactic element.\n  invalid: t(),\n  /// Metadata or meta-instruction.\n  meta,\n  /// [Metadata](#highlight.tags.meta) that applies to the entire\n  /// document.\n  documentMeta: t(meta),\n  /// [Metadata](#highlight.tags.meta) that annotates or adds\n  /// attributes to a given syntactic element.\n  annotation: t(meta),\n  /// Processing instruction or preprocessor directive. Subtag of\n  /// [meta](#highlight.tags.meta).\n  processingInstruction: t(meta),\n  /// [Modifier](#highlight.Tag^defineModifier) that indicates that a\n  /// given element is being defined. Expected to be used with the\n  /// various [name](#highlight.tags.name) tags.\n  definition: Tag.defineModifier(),\n  /// [Modifier](#highlight.Tag^defineModifier) that indicates that\n  /// something is constant. Mostly expected to be used with\n  /// [variable names](#highlight.tags.variableName).\n  constant: Tag.defineModifier(),\n  /// [Modifier](#highlight.Tag^defineModifier) used to indicate that\n  /// a [variable](#highlight.tags.variableName) or [property\n  /// name](#highlight.tags.propertyName) is being called or defined\n  /// as a function.\n  function: Tag.defineModifier(),\n  /// [Modifier](#highlight.Tag^defineModifier) that can be applied to\n  /// [names](#highlight.tags.name) to indicate that they belong to\n  /// the language's standard environment.\n  standard: Tag.defineModifier(),\n  /// [Modifier](#highlight.Tag^defineModifier) that indicates a given\n  /// [names](#highlight.tags.name) is local to some scope.\n  local: Tag.defineModifier(),\n  /// A generic variant [modifier](#highlight.Tag^defineModifier) that\n  /// can be used to tag language-specific alternative variants of\n  /// some common tag. It is recommended for themes to define special\n  /// forms of at least the [string](#highlight.tags.string) and\n  /// [variable name](#highlight.tags.variableName) tags, since those\n  /// come up a lot.\n  special: Tag.defineModifier()\n}; /// This is a highlighter that adds stable, predictable classes to\n/// tokens, for styling with external CSS.\n///\n/// The following tags are mapped to their name prefixed with `\"tok-\"`\n/// (for example `\"tok-comment\"`):\n///\n/// * [`link`](#highlight.tags.link)\n/// * [`heading`](#highlight.tags.heading)\n/// * [`emphasis`](#highlight.tags.emphasis)\n/// * [`strong`](#highlight.tags.strong)\n/// * [`keyword`](#highlight.tags.keyword)\n/// * [`atom`](#highlight.tags.atom)\n/// * [`bool`](#highlight.tags.bool)\n/// * [`url`](#highlight.tags.url)\n/// * [`labelName`](#highlight.tags.labelName)\n/// * [`inserted`](#highlight.tags.inserted)\n/// * [`deleted`](#highlight.tags.deleted)\n/// * [`literal`](#highlight.tags.literal)\n/// * [`string`](#highlight.tags.string)\n/// * [`number`](#highlight.tags.number)\n/// * [`variableName`](#highlight.tags.variableName)\n/// * [`typeName`](#highlight.tags.typeName)\n/// * [`namespace`](#highlight.tags.namespace)\n/// * [`className`](#highlight.tags.className)\n/// * [`macroName`](#highlight.tags.macroName)\n/// * [`propertyName`](#highlight.tags.propertyName)\n/// * [`operator`](#highlight.tags.operator)\n/// * [`comment`](#highlight.tags.comment)\n/// * [`meta`](#highlight.tags.meta)\n/// * [`punctuation`](#highlight.tags.punctuation)\n/// * [`invalid`](#highlight.tags.invalid)\n///\n/// In addition, these mappings are provided:\n///\n/// * [`regexp`](#highlight.tags.regexp),\n///   [`escape`](#highlight.tags.escape), and\n///   [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n///   are mapped to `\"tok-string2\"`\n/// * [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName2\"`\n/// * [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName tok-local\"`\n/// * [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName tok-definition\"`\n/// * [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)\n///   to `\"tok-propertyName tok-definition\"`\n\nconst classHighlighter = tagHighlighter([{\n  tag: tags.link,\n  class: \"tok-link\"\n}, {\n  tag: tags.heading,\n  class: \"tok-heading\"\n}, {\n  tag: tags.emphasis,\n  class: \"tok-emphasis\"\n}, {\n  tag: tags.strong,\n  class: \"tok-strong\"\n}, {\n  tag: tags.keyword,\n  class: \"tok-keyword\"\n}, {\n  tag: tags.atom,\n  class: \"tok-atom\"\n}, {\n  tag: tags.bool,\n  class: \"tok-bool\"\n}, {\n  tag: tags.url,\n  class: \"tok-url\"\n}, {\n  tag: tags.labelName,\n  class: \"tok-labelName\"\n}, {\n  tag: tags.inserted,\n  class: \"tok-inserted\"\n}, {\n  tag: tags.deleted,\n  class: \"tok-deleted\"\n}, {\n  tag: tags.literal,\n  class: \"tok-literal\"\n}, {\n  tag: tags.string,\n  class: \"tok-string\"\n}, {\n  tag: tags.number,\n  class: \"tok-number\"\n}, {\n  tag: [tags.regexp, tags.escape, tags.special(tags.string)],\n  class: \"tok-string2\"\n}, {\n  tag: tags.variableName,\n  class: \"tok-variableName\"\n}, {\n  tag: tags.local(tags.variableName),\n  class: \"tok-variableName tok-local\"\n}, {\n  tag: tags.definition(tags.variableName),\n  class: \"tok-variableName tok-definition\"\n}, {\n  tag: tags.special(tags.variableName),\n  class: \"tok-variableName2\"\n}, {\n  tag: tags.definition(tags.propertyName),\n  class: \"tok-propertyName tok-definition\"\n}, {\n  tag: tags.typeName,\n  class: \"tok-typeName\"\n}, {\n  tag: tags.namespace,\n  class: \"tok-namespace\"\n}, {\n  tag: tags.className,\n  class: \"tok-className\"\n}, {\n  tag: tags.macroName,\n  class: \"tok-macroName\"\n}, {\n  tag: tags.propertyName,\n  class: \"tok-propertyName\"\n}, {\n  tag: tags.operator,\n  class: \"tok-operator\"\n}, {\n  tag: tags.comment,\n  class: \"tok-comment\"\n}, {\n  tag: tags.meta,\n  class: \"tok-meta\"\n}, {\n  tag: tags.invalid,\n  class: \"tok-invalid\"\n}, {\n  tag: tags.punctuation,\n  class: \"tok-punctuation\"\n}]);\nexport { Tag, classHighlighter, highlightTree, styleTags, tagHighlighter, tags };","map":{"version":3,"names":["NodeProp","nextTagID","Tag","constructor","set","base","modified","id","define","parent","Error","tag","push","t","defineModifier","mod","Modifier","indexOf","get","concat","sort","a","b","nextModifierID","instances","mods","length","exists","find","sameArray","m","configs","permute","config","every","x","i","array","result","slice","styleTags","spec","byName","Object","create","prop","tags","Array","isArray","part","split","pieces","mode","rest","pos","exec","RangeError","JSON","parse","next","last","inner","rule","Rule","ruleNodeProp","add","context","other","depth","tagHighlighter","options","map","style","class","scope","all","cls","sub","tagClass","highlightTags","highlighters","highlighter","value","highlightTree","tree","putStyle","from","to","builder","HighlightBuilder","highlightRange","cursor","flush","at","span","startSpan","inheritedClass","type","start","end","isTop","filter","h","opaque","matchContext","tagCls","mounted","overlay","node","enter","innerHighlighters","hasChild","firstChild","nextPos","rangeFrom","Math","max","rangeTo","min","nextSibling","comment","name","typeName","propertyName","literal","string","number","content","heading","keyword","operator","punctuation","bracket","meta","lineComment","blockComment","docComment","variableName","tagName","attributeName","className","labelName","namespace","macroName","docString","character","attributeValue","integer","float","bool","regexp","escape","color","url","self","null","atom","unit","modifier","operatorKeyword","controlKeyword","definitionKeyword","moduleKeyword","derefOperator","arithmeticOperator","logicOperator","bitwiseOperator","compareOperator","updateOperator","definitionOperator","typeOperator","controlOperator","separator","angleBracket","squareBracket","paren","brace","heading1","heading2","heading3","heading4","heading5","heading6","contentSeparator","list","quote","emphasis","strong","link","monospace","strikethrough","inserted","deleted","changed","invalid","documentMeta","annotation","processingInstruction","definition","constant","function","standard","local","special","classHighlighter"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/@lezer/highlight/dist/index.js"],"sourcesContent":["import { NodeProp } from '@lezer/common';\n\nlet nextTagID = 0;\n/// Highlighting tags are markers that denote a highlighting category.\n/// They are [associated](#highlight.styleTags) with parts of a syntax\n/// tree by a language mode, and then mapped to an actual CSS style by\n/// a [highlighter](#highlight.Highlighter).\n///\n/// Because syntax tree node types and highlight styles have to be\n/// able to talk the same language, CodeMirror uses a mostly _closed_\n/// [vocabulary](#highlight.tags) of syntax tags (as opposed to\n/// traditional open string-based systems, which make it hard for\n/// highlighting themes to cover all the tokens produced by the\n/// various languages).\n///\n/// It _is_ possible to [define](#highlight.Tag^define) your own\n/// highlighting tags for system-internal use (where you control both\n/// the language package and the highlighter), but such tags will not\n/// be picked up by regular highlighters (though you can derive them\n/// from standard tags to allow highlighters to fall back to those).\nclass Tag {\n    /// @internal\n    constructor(\n    /// The set of this tag and all its parent tags, starting with\n    /// this one itself and sorted in order of decreasing specificity.\n    set, \n    /// The base unmodified tag that this one is based on, if it's\n    /// modified @internal\n    base, \n    /// The modifiers applied to this.base @internal\n    modified) {\n        this.set = set;\n        this.base = base;\n        this.modified = modified;\n        /// @internal\n        this.id = nextTagID++;\n    }\n    /// Define a new tag. If `parent` is given, the tag is treated as a\n    /// sub-tag of that parent, and\n    /// [highlighters](#highlight.tagHighlighter) that don't mention\n    /// this tag will try to fall back to the parent tag (or grandparent\n    /// tag, etc).\n    static define(parent) {\n        if (parent === null || parent === void 0 ? void 0 : parent.base)\n            throw new Error(\"Can not derive from a modified tag\");\n        let tag = new Tag([], null, []);\n        tag.set.push(tag);\n        if (parent)\n            for (let t of parent.set)\n                tag.set.push(t);\n        return tag;\n    }\n    /// Define a tag _modifier_, which is a function that, given a tag,\n    /// will return a tag that is a subtag of the original. Applying the\n    /// same modifier to a twice tag will return the same value (`m1(t1)\n    /// == m1(t1)`) and applying multiple modifiers will, regardless or\n    /// order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n    ///\n    /// When multiple modifiers are applied to a given base tag, each\n    /// smaller set of modifiers is registered as a parent, so that for\n    /// example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n    /// `m1(m3(t1)`, and so on.\n    static defineModifier() {\n        let mod = new Modifier;\n        return (tag) => {\n            if (tag.modified.indexOf(mod) > -1)\n                return tag;\n            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));\n        };\n    }\n}\nlet nextModifierID = 0;\nclass Modifier {\n    constructor() {\n        this.instances = [];\n        this.id = nextModifierID++;\n    }\n    static get(base, mods) {\n        if (!mods.length)\n            return base;\n        let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));\n        if (exists)\n            return exists;\n        let set = [], tag = new Tag(set, base, mods);\n        for (let m of mods)\n            m.instances.push(tag);\n        let configs = permute(mods);\n        for (let parent of base.set)\n            for (let config of configs)\n                set.push(Modifier.get(parent, config));\n        return tag;\n    }\n}\nfunction sameArray(a, b) {\n    return a.length == b.length && a.every((x, i) => x == b[i]);\n}\nfunction permute(array) {\n    let result = [array];\n    for (let i = 0; i < array.length; i++) {\n        for (let a of permute(array.slice(0, i).concat(array.slice(i + 1))))\n            result.push(a);\n    }\n    return result;\n}\n/// This function is used to add a set of tags to a language syntax\n/// via [`NodeSet.extend`](#common.NodeSet.extend) or\n/// [`LRParser.configure`](#lr.LRParser.configure).\n///\n/// The argument object maps node selectors to [highlighting\n/// tags](#highlight.Tag) or arrays of tags.\n///\n/// Node selectors may hold one or more (space-separated) node paths.\n/// Such a path can be a [node name](#common.NodeType.name), or\n/// multiple node names (or `*` wildcards) separated by slash\n/// characters, as in `\"Block/Declaration/VariableName\"`. Such a path\n/// matches the final node but only if its direct parent nodes are the\n/// other nodes mentioned. A `*` in such a path matches any parent,\n/// but only a single level—wildcards that match multiple parents\n/// aren't supported, both for efficiency reasons and because Lezer\n/// trees make it rather hard to reason about what they would match.)\n///\n/// A path can be ended with `/...` to indicate that the tag assigned\n/// to the node should also apply to all child nodes, even if they\n/// match their own style (by default, only the innermost style is\n/// used).\n///\n/// When a path ends in `!`, as in `Attribute!`, no further matching\n/// happens for the node's child nodes, and the entire node gets the\n/// given style.\n///\n/// In this notation, node names that contain `/`, `!`, `*`, or `...`\n/// must be quoted as JSON strings.\n///\n/// For example:\n///\n/// ```javascript\n/// parser.withProps(\n///   styleTags({\n///     // Style Number and BigNumber nodes\n///     \"Number BigNumber\": tags.number,\n///     // Style Escape nodes whose parent is String\n///     \"String/Escape\": tags.escape,\n///     // Style anything inside Attributes nodes\n///     \"Attributes!\": tags.meta,\n///     // Add a style to all content inside Italic nodes\n///     \"Italic/...\": tags.emphasis,\n///     // Style InvalidString nodes as both `string` and `invalid`\n///     \"InvalidString\": [tags.string, tags.invalid],\n///     // Style the node named \"/\" as punctuation\n///     '\"/\"': tags.punctuation\n///   })\n/// )\n/// ```\nfunction styleTags(spec) {\n    let byName = Object.create(null);\n    for (let prop in spec) {\n        let tags = spec[prop];\n        if (!Array.isArray(tags))\n            tags = [tags];\n        for (let part of prop.split(\" \"))\n            if (part) {\n                let pieces = [], mode = 2 /* Normal */, rest = part;\n                for (let pos = 0;;) {\n                    if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n                        mode = 1 /* Inherit */;\n                        break;\n                    }\n                    let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n                    if (!m)\n                        throw new RangeError(\"Invalid path: \" + part);\n                    pieces.push(m[0] == \"*\" ? \"\" : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n                    pos += m[0].length;\n                    if (pos == part.length)\n                        break;\n                    let next = part[pos++];\n                    if (pos == part.length && next == \"!\") {\n                        mode = 0 /* Opaque */;\n                        break;\n                    }\n                    if (next != \"/\")\n                        throw new RangeError(\"Invalid path: \" + part);\n                    rest = part.slice(pos);\n                }\n                let last = pieces.length - 1, inner = pieces[last];\n                if (!inner)\n                    throw new RangeError(\"Invalid path: \" + part);\n                let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n                byName[inner] = rule.sort(byName[inner]);\n            }\n    }\n    return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new NodeProp();\nclass Rule {\n    constructor(tags, mode, context, next) {\n        this.tags = tags;\n        this.mode = mode;\n        this.context = context;\n        this.next = next;\n    }\n    sort(other) {\n        if (!other || other.depth < this.depth) {\n            this.next = other;\n            return this;\n        }\n        other.next = this.sort(other.next);\n        return other;\n    }\n    get depth() { return this.context ? this.context.length : 0; }\n}\n/// Define a [highlighter](#highlight.Highlighter) from an array of\n/// tag/class pairs. Classes associated with more specific tags will\n/// take precedence.\nfunction tagHighlighter(tags, options) {\n    let map = Object.create(null);\n    for (let style of tags) {\n        if (!Array.isArray(style.tag))\n            map[style.tag.id] = style.class;\n        else\n            for (let tag of style.tag)\n                map[tag.id] = style.class;\n    }\n    let { scope, all = null } = options || {};\n    return {\n        style: (tags) => {\n            let cls = all;\n            for (let tag of tags) {\n                for (let sub of tag.set) {\n                    let tagClass = map[sub.id];\n                    if (tagClass) {\n                        cls = cls ? cls + \" \" + tagClass : tagClass;\n                        break;\n                    }\n                }\n            }\n            return cls;\n        },\n        scope: scope\n    };\n}\nfunction highlightTags(highlighters, tags) {\n    let result = null;\n    for (let highlighter of highlighters) {\n        let value = highlighter.style(tags);\n        if (value)\n            result = result ? result + \" \" + value : value;\n    }\n    return result;\n}\n/// Highlight the given [tree](#common.Tree) with the given\n/// [highlighter](#highlight.Highlighter).\nfunction highlightTree(tree, highlighter, \n/// Assign styling to a region of the text. Will be called, in order\n/// of position, for any ranges where more than zero classes apply.\n/// `classes` is a space separated string of CSS classes.\nputStyle, \n/// The start of the range to highlight.\nfrom = 0, \n/// The end of the range.\nto = tree.length) {\n    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);\n    builder.highlightRange(tree.cursor(), from, to, \"\", builder.highlighters);\n    builder.flush(to);\n}\nclass HighlightBuilder {\n    constructor(at, highlighters, span) {\n        this.at = at;\n        this.highlighters = highlighters;\n        this.span = span;\n        this.class = \"\";\n    }\n    startSpan(at, cls) {\n        if (cls != this.class) {\n            this.flush(at);\n            if (at > this.at)\n                this.at = at;\n            this.class = cls;\n        }\n    }\n    flush(to) {\n        if (to > this.at && this.class)\n            this.span(this.at, to, this.class);\n    }\n    highlightRange(cursor, from, to, inheritedClass, highlighters) {\n        let { type, from: start, to: end } = cursor;\n        if (start >= to || end <= from)\n            return;\n        if (type.isTop)\n            highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));\n        let cls = inheritedClass;\n        let rule = type.prop(ruleNodeProp), opaque = false;\n        while (rule) {\n            if (!rule.context || cursor.matchContext(rule.context)) {\n                let tagCls = highlightTags(highlighters, rule.tags);\n                if (tagCls) {\n                    if (cls)\n                        cls += \" \";\n                    cls += tagCls;\n                    if (rule.mode == 1 /* Inherit */)\n                        inheritedClass += (inheritedClass ? \" \" : \"\") + tagCls;\n                    else if (rule.mode == 0 /* Opaque */)\n                        opaque = true;\n                }\n                break;\n            }\n            rule = rule.next;\n        }\n        this.startSpan(cursor.from, cls);\n        if (opaque)\n            return;\n        let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);\n        if (mounted && mounted.overlay) {\n            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n            let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));\n            let hasChild = cursor.firstChild();\n            for (let i = 0, pos = start;; i++) {\n                let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n                let nextPos = next ? next.from + start : end;\n                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);\n                if (rangeFrom < rangeTo && hasChild) {\n                    while (cursor.from < rangeTo) {\n                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);\n                        this.startSpan(Math.min(to, cursor.to), cls);\n                        if (cursor.to >= nextPos || !cursor.nextSibling())\n                            break;\n                    }\n                }\n                if (!next || nextPos > to)\n                    break;\n                pos = next.to + start;\n                if (pos > from) {\n                    this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, innerHighlighters);\n                    this.startSpan(pos, cls);\n                }\n            }\n            if (hasChild)\n                cursor.parent();\n        }\n        else if (cursor.firstChild()) {\n            do {\n                if (cursor.to <= from)\n                    continue;\n                if (cursor.from >= to)\n                    break;\n                this.highlightRange(cursor, from, to, inheritedClass, highlighters);\n                this.startSpan(Math.min(to, cursor.to), cls);\n            } while (cursor.nextSibling());\n            cursor.parent();\n        }\n    }\n}\nconst t = Tag.define;\nconst comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();\n/// The default set of highlighting [tags](#highlight.Tag).\n///\n/// This collection is heavily biased towards programming languages,\n/// and necessarily incomplete. A full ontology of syntactic\n/// constructs would fill a stack of books, and be impractical to\n/// write themes for. So try to make do with this set. If all else\n/// fails, [open an\n/// issue](https://github.com/codemirror/codemirror.next) to propose a\n/// new tag, or [define](#highlight.Tag^define) a local custom tag for\n/// your use case.\n///\n/// Note that it is not obligatory to always attach the most specific\n/// tag possible to an element—if your grammar can't easily\n/// distinguish a certain type of element (such as a local variable),\n/// it is okay to style it as its more general variant (a variable).\n/// \n/// For tags that extend some parent tag, the documentation links to\n/// the parent.\nconst tags = {\n    /// A comment.\n    comment,\n    /// A line [comment](#highlight.tags.comment).\n    lineComment: t(comment),\n    /// A block [comment](#highlight.tags.comment).\n    blockComment: t(comment),\n    /// A documentation [comment](#highlight.tags.comment).\n    docComment: t(comment),\n    /// Any kind of identifier.\n    name,\n    /// The [name](#highlight.tags.name) of a variable.\n    variableName: t(name),\n    /// A type [name](#highlight.tags.name).\n    typeName: typeName,\n    /// A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n    tagName: t(typeName),\n    /// A property or field [name](#highlight.tags.name).\n    propertyName: propertyName,\n    /// An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\n    attributeName: t(propertyName),\n    /// The [name](#highlight.tags.name) of a class.\n    className: t(name),\n    /// A label [name](#highlight.tags.name).\n    labelName: t(name),\n    /// A namespace [name](#highlight.tags.name).\n    namespace: t(name),\n    /// The [name](#highlight.tags.name) of a macro.\n    macroName: t(name),\n    /// A literal value.\n    literal,\n    /// A string [literal](#highlight.tags.literal).\n    string,\n    /// A documentation [string](#highlight.tags.string).\n    docString: t(string),\n    /// A character literal (subtag of [string](#highlight.tags.string)).\n    character: t(string),\n    /// An attribute value (subtag of [string](#highlight.tags.string)).\n    attributeValue: t(string),\n    /// A number [literal](#highlight.tags.literal).\n    number,\n    /// An integer [number](#highlight.tags.number) literal.\n    integer: t(number),\n    /// A floating-point [number](#highlight.tags.number) literal.\n    float: t(number),\n    /// A boolean [literal](#highlight.tags.literal).\n    bool: t(literal),\n    /// Regular expression [literal](#highlight.tags.literal).\n    regexp: t(literal),\n    /// An escape [literal](#highlight.tags.literal), for example a\n    /// backslash escape in a string.\n    escape: t(literal),\n    /// A color [literal](#highlight.tags.literal).\n    color: t(literal),\n    /// A URL [literal](#highlight.tags.literal).\n    url: t(literal),\n    /// A language keyword.\n    keyword,\n    /// The [keyword](#highlight.tags.keyword) for the self or this\n    /// object.\n    self: t(keyword),\n    /// The [keyword](#highlight.tags.keyword) for null.\n    null: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) denoting some atomic value.\n    atom: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) that represents a unit.\n    unit: t(keyword),\n    /// A modifier [keyword](#highlight.tags.keyword).\n    modifier: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) that acts as an operator.\n    operatorKeyword: t(keyword),\n    /// A control-flow related [keyword](#highlight.tags.keyword).\n    controlKeyword: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) that defines something.\n    definitionKeyword: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) related to defining or\n    /// interfacing with modules.\n    moduleKeyword: t(keyword),\n    /// An operator.\n    operator,\n    /// An [operator](#highlight.tags.operator) that defines something.\n    derefOperator: t(operator),\n    /// Arithmetic-related [operator](#highlight.tags.operator).\n    arithmeticOperator: t(operator),\n    /// Logical [operator](#highlight.tags.operator).\n    logicOperator: t(operator),\n    /// Bit [operator](#highlight.tags.operator).\n    bitwiseOperator: t(operator),\n    /// Comparison [operator](#highlight.tags.operator).\n    compareOperator: t(operator),\n    /// [Operator](#highlight.tags.operator) that updates its operand.\n    updateOperator: t(operator),\n    /// [Operator](#highlight.tags.operator) that defines something.\n    definitionOperator: t(operator),\n    /// Type-related [operator](#highlight.tags.operator).\n    typeOperator: t(operator),\n    /// Control-flow [operator](#highlight.tags.operator).\n    controlOperator: t(operator),\n    /// Program or markup punctuation.\n    punctuation,\n    /// [Punctuation](#highlight.tags.punctuation) that separates\n    /// things.\n    separator: t(punctuation),\n    /// Bracket-style [punctuation](#highlight.tags.punctuation).\n    bracket,\n    /// Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n    /// tokens).\n    angleBracket: t(bracket),\n    /// Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n    /// tokens).\n    squareBracket: t(bracket),\n    /// Parentheses (usually `(` and `)` tokens). Subtag of\n    /// [bracket](#highlight.tags.bracket).\n    paren: t(bracket),\n    /// Braces (usually `{` and `}` tokens). Subtag of\n    /// [bracket](#highlight.tags.bracket).\n    brace: t(bracket),\n    /// Content, for example plain text in XML or markup documents.\n    content,\n    /// [Content](#highlight.tags.content) that represents a heading.\n    heading,\n    /// A level 1 [heading](#highlight.tags.heading).\n    heading1: t(heading),\n    /// A level 2 [heading](#highlight.tags.heading).\n    heading2: t(heading),\n    /// A level 3 [heading](#highlight.tags.heading).\n    heading3: t(heading),\n    /// A level 4 [heading](#highlight.tags.heading).\n    heading4: t(heading),\n    /// A level 5 [heading](#highlight.tags.heading).\n    heading5: t(heading),\n    /// A level 6 [heading](#highlight.tags.heading).\n    heading6: t(heading),\n    /// A prose separator (such as a horizontal rule).\n    contentSeparator: t(content),\n    /// [Content](#highlight.tags.content) that represents a list.\n    list: t(content),\n    /// [Content](#highlight.tags.content) that represents a quote.\n    quote: t(content),\n    /// [Content](#highlight.tags.content) that is emphasized.\n    emphasis: t(content),\n    /// [Content](#highlight.tags.content) that is styled strong.\n    strong: t(content),\n    /// [Content](#highlight.tags.content) that is part of a link.\n    link: t(content),\n    /// [Content](#highlight.tags.content) that is styled as code or\n    /// monospace.\n    monospace: t(content),\n    /// [Content](#highlight.tags.content) that has a strike-through\n    /// style.\n    strikethrough: t(content),\n    /// Inserted text in a change-tracking format.\n    inserted: t(),\n    /// Deleted text.\n    deleted: t(),\n    /// Changed text.\n    changed: t(),\n    /// An invalid or unsyntactic element.\n    invalid: t(),\n    /// Metadata or meta-instruction.\n    meta,\n    /// [Metadata](#highlight.tags.meta) that applies to the entire\n    /// document.\n    documentMeta: t(meta),\n    /// [Metadata](#highlight.tags.meta) that annotates or adds\n    /// attributes to a given syntactic element.\n    annotation: t(meta),\n    /// Processing instruction or preprocessor directive. Subtag of\n    /// [meta](#highlight.tags.meta).\n    processingInstruction: t(meta),\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates that a\n    /// given element is being defined. Expected to be used with the\n    /// various [name](#highlight.tags.name) tags.\n    definition: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates that\n    /// something is constant. Mostly expected to be used with\n    /// [variable names](#highlight.tags.variableName).\n    constant: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) used to indicate that\n    /// a [variable](#highlight.tags.variableName) or [property\n    /// name](#highlight.tags.propertyName) is being called or defined\n    /// as a function.\n    function: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) that can be applied to\n    /// [names](#highlight.tags.name) to indicate that they belong to\n    /// the language's standard environment.\n    standard: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates a given\n    /// [names](#highlight.tags.name) is local to some scope.\n    local: Tag.defineModifier(),\n    /// A generic variant [modifier](#highlight.Tag^defineModifier) that\n    /// can be used to tag language-specific alternative variants of\n    /// some common tag. It is recommended for themes to define special\n    /// forms of at least the [string](#highlight.tags.string) and\n    /// [variable name](#highlight.tags.variableName) tags, since those\n    /// come up a lot.\n    special: Tag.defineModifier()\n};\n/// This is a highlighter that adds stable, predictable classes to\n/// tokens, for styling with external CSS.\n///\n/// The following tags are mapped to their name prefixed with `\"tok-\"`\n/// (for example `\"tok-comment\"`):\n///\n/// * [`link`](#highlight.tags.link)\n/// * [`heading`](#highlight.tags.heading)\n/// * [`emphasis`](#highlight.tags.emphasis)\n/// * [`strong`](#highlight.tags.strong)\n/// * [`keyword`](#highlight.tags.keyword)\n/// * [`atom`](#highlight.tags.atom)\n/// * [`bool`](#highlight.tags.bool)\n/// * [`url`](#highlight.tags.url)\n/// * [`labelName`](#highlight.tags.labelName)\n/// * [`inserted`](#highlight.tags.inserted)\n/// * [`deleted`](#highlight.tags.deleted)\n/// * [`literal`](#highlight.tags.literal)\n/// * [`string`](#highlight.tags.string)\n/// * [`number`](#highlight.tags.number)\n/// * [`variableName`](#highlight.tags.variableName)\n/// * [`typeName`](#highlight.tags.typeName)\n/// * [`namespace`](#highlight.tags.namespace)\n/// * [`className`](#highlight.tags.className)\n/// * [`macroName`](#highlight.tags.macroName)\n/// * [`propertyName`](#highlight.tags.propertyName)\n/// * [`operator`](#highlight.tags.operator)\n/// * [`comment`](#highlight.tags.comment)\n/// * [`meta`](#highlight.tags.meta)\n/// * [`punctuation`](#highlight.tags.punctuation)\n/// * [`invalid`](#highlight.tags.invalid)\n///\n/// In addition, these mappings are provided:\n///\n/// * [`regexp`](#highlight.tags.regexp),\n///   [`escape`](#highlight.tags.escape), and\n///   [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n///   are mapped to `\"tok-string2\"`\n/// * [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName2\"`\n/// * [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName tok-local\"`\n/// * [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName tok-definition\"`\n/// * [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)\n///   to `\"tok-propertyName tok-definition\"`\nconst classHighlighter = tagHighlighter([\n    { tag: tags.link, class: \"tok-link\" },\n    { tag: tags.heading, class: \"tok-heading\" },\n    { tag: tags.emphasis, class: \"tok-emphasis\" },\n    { tag: tags.strong, class: \"tok-strong\" },\n    { tag: tags.keyword, class: \"tok-keyword\" },\n    { tag: tags.atom, class: \"tok-atom\" },\n    { tag: tags.bool, class: \"tok-bool\" },\n    { tag: tags.url, class: \"tok-url\" },\n    { tag: tags.labelName, class: \"tok-labelName\" },\n    { tag: tags.inserted, class: \"tok-inserted\" },\n    { tag: tags.deleted, class: \"tok-deleted\" },\n    { tag: tags.literal, class: \"tok-literal\" },\n    { tag: tags.string, class: \"tok-string\" },\n    { tag: tags.number, class: \"tok-number\" },\n    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: \"tok-string2\" },\n    { tag: tags.variableName, class: \"tok-variableName\" },\n    { tag: tags.local(tags.variableName), class: \"tok-variableName tok-local\" },\n    { tag: tags.definition(tags.variableName), class: \"tok-variableName tok-definition\" },\n    { tag: tags.special(tags.variableName), class: \"tok-variableName2\" },\n    { tag: tags.definition(tags.propertyName), class: \"tok-propertyName tok-definition\" },\n    { tag: tags.typeName, class: \"tok-typeName\" },\n    { tag: tags.namespace, class: \"tok-namespace\" },\n    { tag: tags.className, class: \"tok-className\" },\n    { tag: tags.macroName, class: \"tok-macroName\" },\n    { tag: tags.propertyName, class: \"tok-propertyName\" },\n    { tag: tags.operator, class: \"tok-operator\" },\n    { tag: tags.comment, class: \"tok-comment\" },\n    { tag: tags.meta, class: \"tok-meta\" },\n    { tag: tags.invalid, class: \"tok-invalid\" },\n    { tag: tags.punctuation, class: \"tok-punctuation\" }\n]);\n\nexport { Tag, classHighlighter, highlightTree, styleTags, tagHighlighter, tags };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}