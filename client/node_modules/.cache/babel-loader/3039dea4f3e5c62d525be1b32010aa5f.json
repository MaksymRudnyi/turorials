{"ast":null,"code":"// The keywords object is set to the result of this self executing\n// function. Each keyword is a property of the keywords object whose\n// value is {type: atype, style: astyle}\nvar keywords = function () {\n  // convenience functions used to build keywords object\n  function kw(type) {\n    return {\n      type: type,\n      style: \"keyword\"\n    };\n  }\n\n  var operator = kw(\"operator\"),\n      atom = {\n    type: \"atom\",\n    style: \"atom\"\n  },\n      punctuation = {\n    type: \"punctuation\",\n    style: null\n  },\n      qualifier = {\n    type: \"axis_specifier\",\n    style: \"qualifier\"\n  }; // kwObj is what is return from this function at the end\n\n  var kwObj = {\n    ',': punctuation\n  }; // a list of 'basic' keywords. For each add a property to kwObj with the value of\n  // {type: basic[i], style: \"keyword\"} e.g. 'after' --> {type: \"after\", style: \"keyword\"}\n\n  var basic = ['after', 'all', 'allowing', 'ancestor', 'ancestor-or-self', 'any', 'array', 'as', 'ascending', 'at', 'attribute', 'base-uri', 'before', 'boundary-space', 'by', 'case', 'cast', 'castable', 'catch', 'child', 'collation', 'comment', 'construction', 'contains', 'content', 'context', 'copy', 'copy-namespaces', 'count', 'decimal-format', 'declare', 'default', 'delete', 'descendant', 'descendant-or-self', 'descending', 'diacritics', 'different', 'distance', 'document', 'document-node', 'element', 'else', 'empty', 'empty-sequence', 'encoding', 'end', 'entire', 'every', 'exactly', 'except', 'external', 'first', 'following', 'following-sibling', 'for', 'from', 'ftand', 'ftnot', 'ft-option', 'ftor', 'function', 'fuzzy', 'greatest', 'group', 'if', 'import', 'in', 'inherit', 'insensitive', 'insert', 'instance', 'intersect', 'into', 'invoke', 'is', 'item', 'language', 'last', 'lax', 'least', 'let', 'levels', 'lowercase', 'map', 'modify', 'module', 'most', 'namespace', 'next', 'no', 'node', 'nodes', 'no-inherit', 'no-preserve', 'not', 'occurs', 'of', 'only', 'option', 'order', 'ordered', 'ordering', 'paragraph', 'paragraphs', 'parent', 'phrase', 'preceding', 'preceding-sibling', 'preserve', 'previous', 'processing-instruction', 'relationship', 'rename', 'replace', 'return', 'revalidation', 'same', 'satisfies', 'schema', 'schema-attribute', 'schema-element', 'score', 'self', 'sensitive', 'sentence', 'sentences', 'sequence', 'skip', 'sliding', 'some', 'stable', 'start', 'stemming', 'stop', 'strict', 'strip', 'switch', 'text', 'then', 'thesaurus', 'times', 'to', 'transform', 'treat', 'try', 'tumbling', 'type', 'typeswitch', 'union', 'unordered', 'update', 'updating', 'uppercase', 'using', 'validate', 'value', 'variable', 'version', 'weight', 'when', 'where', 'wildcards', 'window', 'with', 'without', 'word', 'words', 'xquery'];\n\n  for (var i = 0, l = basic.length; i < l; i++) {\n    kwObj[basic[i]] = kw(basic[i]);\n  }\n\n  ; // a list of types. For each add a property to kwObj with the value of\n  // {type: \"atom\", style: \"atom\"}\n\n  var types = ['xs:anyAtomicType', 'xs:anySimpleType', 'xs:anyType', 'xs:anyURI', 'xs:base64Binary', 'xs:boolean', 'xs:byte', 'xs:date', 'xs:dateTime', 'xs:dateTimeStamp', 'xs:dayTimeDuration', 'xs:decimal', 'xs:double', 'xs:duration', 'xs:ENTITIES', 'xs:ENTITY', 'xs:float', 'xs:gDay', 'xs:gMonth', 'xs:gMonthDay', 'xs:gYear', 'xs:gYearMonth', 'xs:hexBinary', 'xs:ID', 'xs:IDREF', 'xs:IDREFS', 'xs:int', 'xs:integer', 'xs:item', 'xs:java', 'xs:language', 'xs:long', 'xs:Name', 'xs:NCName', 'xs:negativeInteger', 'xs:NMTOKEN', 'xs:NMTOKENS', 'xs:nonNegativeInteger', 'xs:nonPositiveInteger', 'xs:normalizedString', 'xs:NOTATION', 'xs:numeric', 'xs:positiveInteger', 'xs:precisionDecimal', 'xs:QName', 'xs:short', 'xs:string', 'xs:time', 'xs:token', 'xs:unsignedByte', 'xs:unsignedInt', 'xs:unsignedLong', 'xs:unsignedShort', 'xs:untyped', 'xs:untypedAtomic', 'xs:yearMonthDuration'];\n\n  for (var i = 0, l = types.length; i < l; i++) {\n    kwObj[types[i]] = atom;\n  }\n\n  ; // each operator will add a property to kwObj with value of {type: \"operator\", style: \"keyword\"}\n\n  var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];\n\n  for (var i = 0, l = operators.length; i < l; i++) {\n    kwObj[operators[i]] = operator;\n  }\n\n  ; // each axis_specifiers will add a property to kwObj with value of {type: \"axis_specifier\", style: \"qualifier\"}\n\n  var axis_specifiers = [\"self::\", \"attribute::\", \"child::\", \"descendant::\", \"descendant-or-self::\", \"parent::\", \"ancestor::\", \"ancestor-or-self::\", \"following::\", \"preceding::\", \"following-sibling::\", \"preceding-sibling::\"];\n\n  for (var i = 0, l = axis_specifiers.length; i < l; i++) {\n    kwObj[axis_specifiers[i]] = qualifier;\n  }\n\n  ;\n  return kwObj;\n}();\n\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n} // the primary mode tokenizer\n\n\nfunction tokenBase(stream, state) {\n  var ch = stream.next(),\n      mightBeFunction = false,\n      isEQName = isEQNameAhead(stream); // an XML tag (if not in some sub, chained tokenizer)\n\n  if (ch == \"<\") {\n    if (stream.match(\"!--\", true)) return chain(stream, state, tokenXMLComment);\n\n    if (stream.match(\"![CDATA\", false)) {\n      state.tokenize = tokenCDATA;\n      return \"tag\";\n    }\n\n    if (stream.match(\"?\", false)) {\n      return chain(stream, state, tokenPreProcessing);\n    }\n\n    var isclose = stream.eat(\"/\");\n    stream.eatSpace();\n    var tagName = \"\",\n        c;\n\n    while (c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/)) tagName += c;\n\n    return chain(stream, state, tokenTag(tagName, isclose));\n  } // start code block\n  else if (ch == \"{\") {\n    pushStateStack(state, {\n      type: \"codeblock\"\n    });\n    return null;\n  } // end code block\n  else if (ch == \"}\") {\n    popStateStack(state);\n    return null;\n  } // if we're in an XML block\n  else if (isInXmlBlock(state)) {\n    if (ch == \">\") return \"tag\";else if (ch == \"/\" && stream.eat(\">\")) {\n      popStateStack(state);\n      return \"tag\";\n    } else return \"variable\";\n  } // if a number\n  else if (/\\d/.test(ch)) {\n    stream.match(/^\\d*(?:\\.\\d*)?(?:E[+\\-]?\\d+)?/);\n    return \"atom\";\n  } // comment start\n  else if (ch === \"(\" && stream.eat(\":\")) {\n    pushStateStack(state, {\n      type: \"comment\"\n    });\n    return chain(stream, state, tokenComment);\n  } // quoted string\n  else if (!isEQName && (ch === '\"' || ch === \"'\")) return chain(stream, state, tokenString(ch)); // variable\n  else if (ch === \"$\") {\n    return chain(stream, state, tokenVariable);\n  } // assignment\n  else if (ch === \":\" && stream.eat(\"=\")) {\n    return \"keyword\";\n  } // open paren\n  else if (ch === \"(\") {\n    pushStateStack(state, {\n      type: \"paren\"\n    });\n    return null;\n  } // close paren\n  else if (ch === \")\") {\n    popStateStack(state);\n    return null;\n  } // open paren\n  else if (ch === \"[\") {\n    pushStateStack(state, {\n      type: \"bracket\"\n    });\n    return null;\n  } // close paren\n  else if (ch === \"]\") {\n    popStateStack(state);\n    return null;\n  } else {\n    var known = keywords.propertyIsEnumerable(ch) && keywords[ch]; // if there's a EQName ahead, consume the rest of the string portion, it's likely a function\n\n    if (isEQName && ch === '\\\"') while (stream.next() !== '\"') {}\n    if (isEQName && ch === '\\'') while (stream.next() !== '\\'') {} // gobble up a word if the character is not known\n\n    if (!known) stream.eatWhile(/[\\w\\$_-]/); // gobble a colon in the case that is a lib func type call fn:doc\n\n    var foundColon = stream.eat(\":\"); // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier\n    // which should get matched as a keyword\n\n    if (!stream.eat(\":\") && foundColon) {\n      stream.eatWhile(/[\\w\\$_-]/);\n    } // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)\n\n\n    if (stream.match(/^[ \\t]*\\(/, false)) {\n      mightBeFunction = true;\n    } // is the word a keyword?\n\n\n    var word = stream.current();\n    known = keywords.propertyIsEnumerable(word) && keywords[word]; // if we think it's a function call but not yet known,\n    // set style to variable for now for lack of something better\n\n    if (mightBeFunction && !known) known = {\n      type: \"function_call\",\n      style: \"def\"\n    }; // if the previous word was element, attribute, axis specifier, this word should be the name of that\n\n    if (isInXmlConstructor(state)) {\n      popStateStack(state);\n      return \"variable\";\n    } // as previously checked, if the word is element,attribute, axis specifier, call it an \"xmlconstructor\" and\n    // push the stack so we know to look for it on the next word\n\n\n    if (word == \"element\" || word == \"attribute\" || known.type == \"axis_specifier\") pushStateStack(state, {\n      type: \"xmlconstructor\"\n    }); // if the word is known, return the details of that else just call this a generic 'word'\n\n    return known ? known.style : \"variable\";\n  }\n} // handle comments, including nested\n\n\nfunction tokenComment(stream, state) {\n  var maybeEnd = false,\n      maybeNested = false,\n      nestedCount = 0,\n      ch;\n\n  while (ch = stream.next()) {\n    if (ch == \")\" && maybeEnd) {\n      if (nestedCount > 0) nestedCount--;else {\n        popStateStack(state);\n        break;\n      }\n    } else if (ch == \":\" && maybeNested) {\n      nestedCount++;\n    }\n\n    maybeEnd = ch == \":\";\n    maybeNested = ch == \"(\";\n  }\n\n  return \"comment\";\n} // tokenizer for string literals\n// optionally pass a tokenizer function to set state.tokenize back to when finished\n\n\nfunction tokenString(quote, f) {\n  return function (stream, state) {\n    var ch;\n\n    if (isInString(state) && stream.current() == quote) {\n      popStateStack(state);\n      if (f) state.tokenize = f;\n      return \"string\";\n    }\n\n    pushStateStack(state, {\n      type: \"string\",\n      name: quote,\n      tokenize: tokenString(quote, f)\n    }); // if we're in a string and in an XML block, allow an embedded code block\n\n    if (stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n      state.tokenize = tokenBase;\n      return \"string\";\n    }\n\n    while (ch = stream.next()) {\n      if (ch == quote) {\n        popStateStack(state);\n        if (f) state.tokenize = f;\n        break;\n      } else {\n        // if we're in a string and in an XML block, allow an embedded code block in an attribute\n        if (stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n          state.tokenize = tokenBase;\n          return \"string\";\n        }\n      }\n    }\n\n    return \"string\";\n  };\n} // tokenizer for variables\n\n\nfunction tokenVariable(stream, state) {\n  var isVariableChar = /[\\w\\$_-]/; // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote\n\n  if (stream.eat(\"\\\"\")) {\n    while (stream.next() !== '\\\"') {}\n\n    ;\n    stream.eat(\":\");\n  } else {\n    stream.eatWhile(isVariableChar);\n    if (!stream.match(\":=\", false)) stream.eat(\":\");\n  }\n\n  stream.eatWhile(isVariableChar);\n  state.tokenize = tokenBase;\n  return \"variable\";\n} // tokenizer for XML tags\n\n\nfunction tokenTag(name, isclose) {\n  return function (stream, state) {\n    stream.eatSpace();\n\n    if (isclose && stream.eat(\">\")) {\n      popStateStack(state);\n      state.tokenize = tokenBase;\n      return \"tag\";\n    } // self closing tag without attributes?\n\n\n    if (!stream.eat(\"/\")) pushStateStack(state, {\n      type: \"tag\",\n      name: name,\n      tokenize: tokenBase\n    });\n\n    if (!stream.eat(\">\")) {\n      state.tokenize = tokenAttribute;\n      return \"tag\";\n    } else {\n      state.tokenize = tokenBase;\n    }\n\n    return \"tag\";\n  };\n} // tokenizer for XML attributes\n\n\nfunction tokenAttribute(stream, state) {\n  var ch = stream.next();\n\n  if (ch == \"/\" && stream.eat(\">\")) {\n    if (isInXmlAttributeBlock(state)) popStateStack(state);\n    if (isInXmlBlock(state)) popStateStack(state);\n    return \"tag\";\n  }\n\n  if (ch == \">\") {\n    if (isInXmlAttributeBlock(state)) popStateStack(state);\n    return \"tag\";\n  }\n\n  if (ch == \"=\") return null; // quoted string\n\n  if (ch == '\"' || ch == \"'\") return chain(stream, state, tokenString(ch, tokenAttribute));\n  if (!isInXmlAttributeBlock(state)) pushStateStack(state, {\n    type: \"attribute\",\n    tokenize: tokenAttribute\n  });\n  stream.eat(/[a-zA-Z_:]/);\n  stream.eatWhile(/[-a-zA-Z0-9_:.]/);\n  stream.eatSpace(); // the case where the attribute has not value and the tag was closed\n\n  if (stream.match(\">\", false) || stream.match(\"/\", false)) {\n    popStateStack(state);\n    state.tokenize = tokenBase;\n  }\n\n  return \"attribute\";\n} // handle comments, including nested\n\n\nfunction tokenXMLComment(stream, state) {\n  var ch;\n\n  while (ch = stream.next()) {\n    if (ch == \"-\" && stream.match(\"->\", true)) {\n      state.tokenize = tokenBase;\n      return \"comment\";\n    }\n  }\n} // handle CDATA\n\n\nfunction tokenCDATA(stream, state) {\n  var ch;\n\n  while (ch = stream.next()) {\n    if (ch == \"]\" && stream.match(\"]\", true)) {\n      state.tokenize = tokenBase;\n      return \"comment\";\n    }\n  }\n} // handle preprocessing instructions\n\n\nfunction tokenPreProcessing(stream, state) {\n  var ch;\n\n  while (ch = stream.next()) {\n    if (ch == \"?\" && stream.match(\">\", true)) {\n      state.tokenize = tokenBase;\n      return \"processingInstruction\";\n    }\n  }\n} // functions to test the current context of the state\n\n\nfunction isInXmlBlock(state) {\n  return isIn(state, \"tag\");\n}\n\nfunction isInXmlAttributeBlock(state) {\n  return isIn(state, \"attribute\");\n}\n\nfunction isInXmlConstructor(state) {\n  return isIn(state, \"xmlconstructor\");\n}\n\nfunction isInString(state) {\n  return isIn(state, \"string\");\n}\n\nfunction isEQNameAhead(stream) {\n  // assume we've already eaten a quote (\")\n  if (stream.current() === '\"') return stream.match(/^[^\\\"]+\\\"\\:/, false);else if (stream.current() === '\\'') return stream.match(/^[^\\\"]+\\'\\:/, false);else return false;\n}\n\nfunction isIn(state, type) {\n  return state.stack.length && state.stack[state.stack.length - 1].type == type;\n}\n\nfunction pushStateStack(state, newState) {\n  state.stack.push(newState);\n}\n\nfunction popStateStack(state) {\n  state.stack.pop();\n  var reinstateTokenize = state.stack.length && state.stack[state.stack.length - 1].tokenize;\n  state.tokenize = reinstateTokenize || tokenBase;\n} // the interface for the mode API\n\n\nexport const xQuery = {\n  startState: function () {\n    return {\n      tokenize: tokenBase,\n      cc: [],\n      stack: []\n    };\n  },\n  token: function (stream, state) {\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    return style;\n  },\n  languageData: {\n    commentTokens: {\n      block: {\n        open: \"(:\",\n        close: \":)\"\n      }\n    }\n  }\n};","map":{"version":3,"names":["keywords","kw","type","style","operator","atom","punctuation","qualifier","kwObj","basic","i","l","length","types","operators","axis_specifiers","chain","stream","state","f","tokenize","tokenBase","ch","next","mightBeFunction","isEQName","isEQNameAhead","match","tokenXMLComment","tokenCDATA","tokenPreProcessing","isclose","eat","eatSpace","tagName","c","tokenTag","pushStateStack","popStateStack","isInXmlBlock","test","tokenComment","tokenString","tokenVariable","known","propertyIsEnumerable","eatWhile","foundColon","word","current","isInXmlConstructor","maybeEnd","maybeNested","nestedCount","quote","isInString","name","isInXmlAttributeBlock","isVariableChar","tokenAttribute","isIn","stack","newState","push","pop","reinstateTokenize","xQuery","startState","cc","token","languageData","commentTokens","block","open","close"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/@codemirror/legacy-modes/mode/xquery.js"],"sourcesContent":["// The keywords object is set to the result of this self executing\n// function. Each keyword is a property of the keywords object whose\n// value is {type: atype, style: astyle}\nvar keywords = function(){\n  // convenience functions used to build keywords object\n  function kw(type) {return {type: type, style: \"keyword\"};}\n  var operator = kw(\"operator\")\n  , atom = {type: \"atom\", style: \"atom\"}\n  , punctuation = {type: \"punctuation\", style: null}\n  , qualifier = {type: \"axis_specifier\", style: \"qualifier\"};\n\n  // kwObj is what is return from this function at the end\n  var kwObj = {\n    ',': punctuation\n  };\n\n  // a list of 'basic' keywords. For each add a property to kwObj with the value of\n  // {type: basic[i], style: \"keyword\"} e.g. 'after' --> {type: \"after\", style: \"keyword\"}\n  var basic = ['after', 'all', 'allowing', 'ancestor', 'ancestor-or-self', 'any', 'array', 'as',\n               'ascending', 'at', 'attribute', 'base-uri', 'before', 'boundary-space', 'by', 'case', 'cast',\n               'castable', 'catch', 'child', 'collation', 'comment', 'construction', 'contains', 'content',\n               'context', 'copy', 'copy-namespaces', 'count', 'decimal-format', 'declare', 'default', 'delete',\n               'descendant', 'descendant-or-self', 'descending', 'diacritics', 'different', 'distance',\n               'document', 'document-node', 'element', 'else', 'empty', 'empty-sequence', 'encoding', 'end',\n               'entire', 'every', 'exactly', 'except', 'external', 'first', 'following', 'following-sibling',\n               'for', 'from', 'ftand', 'ftnot', 'ft-option', 'ftor', 'function', 'fuzzy', 'greatest', 'group',\n               'if', 'import', 'in', 'inherit', 'insensitive', 'insert', 'instance', 'intersect', 'into',\n               'invoke', 'is', 'item', 'language', 'last', 'lax', 'least', 'let', 'levels', 'lowercase', 'map',\n               'modify', 'module', 'most', 'namespace', 'next', 'no', 'node', 'nodes', 'no-inherit',\n               'no-preserve', 'not', 'occurs', 'of', 'only', 'option', 'order', 'ordered', 'ordering',\n               'paragraph', 'paragraphs', 'parent', 'phrase', 'preceding', 'preceding-sibling', 'preserve',\n               'previous', 'processing-instruction', 'relationship', 'rename', 'replace', 'return',\n               'revalidation', 'same', 'satisfies', 'schema', 'schema-attribute', 'schema-element', 'score',\n               'self', 'sensitive', 'sentence', 'sentences', 'sequence', 'skip', 'sliding', 'some', 'stable',\n               'start', 'stemming', 'stop', 'strict', 'strip', 'switch', 'text', 'then', 'thesaurus', 'times',\n               'to', 'transform', 'treat', 'try', 'tumbling', 'type', 'typeswitch', 'union', 'unordered',\n               'update', 'updating', 'uppercase', 'using', 'validate', 'value', 'variable', 'version',\n               'weight', 'when', 'where', 'wildcards', 'window', 'with', 'without', 'word', 'words', 'xquery'];\n  for(var i=0, l=basic.length; i < l; i++) { kwObj[basic[i]] = kw(basic[i]);};\n\n  // a list of types. For each add a property to kwObj with the value of\n  // {type: \"atom\", style: \"atom\"}\n  var types = ['xs:anyAtomicType', 'xs:anySimpleType', 'xs:anyType', 'xs:anyURI',\n               'xs:base64Binary', 'xs:boolean', 'xs:byte', 'xs:date', 'xs:dateTime', 'xs:dateTimeStamp',\n               'xs:dayTimeDuration', 'xs:decimal', 'xs:double', 'xs:duration', 'xs:ENTITIES', 'xs:ENTITY',\n               'xs:float', 'xs:gDay', 'xs:gMonth', 'xs:gMonthDay', 'xs:gYear', 'xs:gYearMonth', 'xs:hexBinary',\n               'xs:ID', 'xs:IDREF', 'xs:IDREFS', 'xs:int', 'xs:integer', 'xs:item', 'xs:java', 'xs:language',\n               'xs:long', 'xs:Name', 'xs:NCName', 'xs:negativeInteger', 'xs:NMTOKEN', 'xs:NMTOKENS',\n               'xs:nonNegativeInteger', 'xs:nonPositiveInteger', 'xs:normalizedString', 'xs:NOTATION',\n               'xs:numeric', 'xs:positiveInteger', 'xs:precisionDecimal', 'xs:QName', 'xs:short', 'xs:string',\n               'xs:time', 'xs:token', 'xs:unsignedByte', 'xs:unsignedInt', 'xs:unsignedLong',\n               'xs:unsignedShort', 'xs:untyped', 'xs:untypedAtomic', 'xs:yearMonthDuration'];\n  for(var i=0, l=types.length; i < l; i++) { kwObj[types[i]] = atom;};\n\n  // each operator will add a property to kwObj with value of {type: \"operator\", style: \"keyword\"}\n  var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];\n  for(var i=0, l=operators.length; i < l; i++) { kwObj[operators[i]] = operator;};\n\n  // each axis_specifiers will add a property to kwObj with value of {type: \"axis_specifier\", style: \"qualifier\"}\n  var axis_specifiers = [\"self::\", \"attribute::\", \"child::\", \"descendant::\", \"descendant-or-self::\", \"parent::\",\n                         \"ancestor::\", \"ancestor-or-self::\", \"following::\", \"preceding::\", \"following-sibling::\", \"preceding-sibling::\"];\n  for(var i=0, l=axis_specifiers.length; i < l; i++) { kwObj[axis_specifiers[i]] = qualifier; };\n\n  return kwObj;\n}();\n\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\n\n// the primary mode tokenizer\nfunction tokenBase(stream, state) {\n  var ch = stream.next(),\n      mightBeFunction = false,\n      isEQName = isEQNameAhead(stream);\n\n  // an XML tag (if not in some sub, chained tokenizer)\n  if (ch == \"<\") {\n    if(stream.match(\"!--\", true))\n      return chain(stream, state, tokenXMLComment);\n\n    if(stream.match(\"![CDATA\", false)) {\n      state.tokenize = tokenCDATA;\n      return \"tag\";\n    }\n\n    if(stream.match(\"?\", false)) {\n      return chain(stream, state, tokenPreProcessing);\n    }\n\n    var isclose = stream.eat(\"/\");\n    stream.eatSpace();\n    var tagName = \"\", c;\n    while ((c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/))) tagName += c;\n\n    return chain(stream, state, tokenTag(tagName, isclose));\n  }\n  // start code block\n  else if(ch == \"{\") {\n    pushStateStack(state, { type: \"codeblock\"});\n    return null;\n  }\n  // end code block\n  else if(ch == \"}\") {\n    popStateStack(state);\n    return null;\n  }\n  // if we're in an XML block\n  else if(isInXmlBlock(state)) {\n    if(ch == \">\")\n      return \"tag\";\n    else if(ch == \"/\" && stream.eat(\">\")) {\n      popStateStack(state);\n      return \"tag\";\n    }\n    else\n      return \"variable\";\n  }\n  // if a number\n  else if (/\\d/.test(ch)) {\n    stream.match(/^\\d*(?:\\.\\d*)?(?:E[+\\-]?\\d+)?/);\n    return \"atom\";\n  }\n  // comment start\n  else if (ch === \"(\" && stream.eat(\":\")) {\n    pushStateStack(state, { type: \"comment\"});\n    return chain(stream, state, tokenComment);\n  }\n  // quoted string\n  else if (!isEQName && (ch === '\"' || ch === \"'\"))\n    return chain(stream, state, tokenString(ch));\n  // variable\n  else if(ch === \"$\") {\n    return chain(stream, state, tokenVariable);\n  }\n  // assignment\n  else if(ch ===\":\" && stream.eat(\"=\")) {\n    return \"keyword\";\n  }\n  // open paren\n  else if(ch === \"(\") {\n    pushStateStack(state, { type: \"paren\"});\n    return null;\n  }\n  // close paren\n  else if(ch === \")\") {\n    popStateStack(state);\n    return null;\n  }\n  // open paren\n  else if(ch === \"[\") {\n    pushStateStack(state, { type: \"bracket\"});\n    return null;\n  }\n  // close paren\n  else if(ch === \"]\") {\n    popStateStack(state);\n    return null;\n  }\n  else {\n    var known = keywords.propertyIsEnumerable(ch) && keywords[ch];\n\n    // if there's a EQName ahead, consume the rest of the string portion, it's likely a function\n    if(isEQName && ch === '\\\"') while(stream.next() !== '\"'){}\n    if(isEQName && ch === '\\'') while(stream.next() !== '\\''){}\n\n    // gobble up a word if the character is not known\n    if(!known) stream.eatWhile(/[\\w\\$_-]/);\n\n    // gobble a colon in the case that is a lib func type call fn:doc\n    var foundColon = stream.eat(\":\");\n\n    // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier\n    // which should get matched as a keyword\n    if(!stream.eat(\":\") && foundColon) {\n      stream.eatWhile(/[\\w\\$_-]/);\n    }\n    // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)\n    if(stream.match(/^[ \\t]*\\(/, false)) {\n      mightBeFunction = true;\n    }\n    // is the word a keyword?\n    var word = stream.current();\n    known = keywords.propertyIsEnumerable(word) && keywords[word];\n\n    // if we think it's a function call but not yet known,\n    // set style to variable for now for lack of something better\n    if(mightBeFunction && !known) known = {type: \"function_call\", style: \"def\"};\n\n    // if the previous word was element, attribute, axis specifier, this word should be the name of that\n    if(isInXmlConstructor(state)) {\n      popStateStack(state);\n      return \"variable\";\n    }\n    // as previously checked, if the word is element,attribute, axis specifier, call it an \"xmlconstructor\" and\n    // push the stack so we know to look for it on the next word\n    if(word == \"element\" || word == \"attribute\" || known.type == \"axis_specifier\") pushStateStack(state, {type: \"xmlconstructor\"});\n\n    // if the word is known, return the details of that else just call this a generic 'word'\n    return known ? known.style : \"variable\";\n  }\n}\n\n// handle comments, including nested\nfunction tokenComment(stream, state) {\n  var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;\n  while (ch = stream.next()) {\n    if (ch == \")\" && maybeEnd) {\n      if(nestedCount > 0)\n        nestedCount--;\n      else {\n        popStateStack(state);\n        break;\n      }\n    }\n    else if(ch == \":\" && maybeNested) {\n      nestedCount++;\n    }\n    maybeEnd = (ch == \":\");\n    maybeNested = (ch == \"(\");\n  }\n\n  return \"comment\";\n}\n\n// tokenizer for string literals\n// optionally pass a tokenizer function to set state.tokenize back to when finished\nfunction tokenString(quote, f) {\n  return function(stream, state) {\n    var ch;\n\n    if(isInString(state) && stream.current() == quote) {\n      popStateStack(state);\n      if(f) state.tokenize = f;\n      return \"string\";\n    }\n\n    pushStateStack(state, { type: \"string\", name: quote, tokenize: tokenString(quote, f) });\n\n    // if we're in a string and in an XML block, allow an embedded code block\n    if(stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n      state.tokenize = tokenBase;\n      return \"string\";\n    }\n\n\n    while (ch = stream.next()) {\n      if (ch ==  quote) {\n        popStateStack(state);\n        if(f) state.tokenize = f;\n        break;\n      }\n      else {\n        // if we're in a string and in an XML block, allow an embedded code block in an attribute\n        if(stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n          state.tokenize = tokenBase;\n          return \"string\";\n        }\n\n      }\n    }\n\n    return \"string\";\n  };\n}\n\n// tokenizer for variables\nfunction tokenVariable(stream, state) {\n  var isVariableChar = /[\\w\\$_-]/;\n\n  // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote\n  if(stream.eat(\"\\\"\")) {\n    while(stream.next() !== '\\\"'){};\n    stream.eat(\":\");\n  } else {\n    stream.eatWhile(isVariableChar);\n    if(!stream.match(\":=\", false)) stream.eat(\":\");\n  }\n  stream.eatWhile(isVariableChar);\n  state.tokenize = tokenBase;\n  return \"variable\";\n}\n\n// tokenizer for XML tags\nfunction tokenTag(name, isclose) {\n  return function(stream, state) {\n    stream.eatSpace();\n    if(isclose && stream.eat(\">\")) {\n      popStateStack(state);\n      state.tokenize = tokenBase;\n      return \"tag\";\n    }\n    // self closing tag without attributes?\n    if(!stream.eat(\"/\"))\n      pushStateStack(state, { type: \"tag\", name: name, tokenize: tokenBase});\n    if(!stream.eat(\">\")) {\n      state.tokenize = tokenAttribute;\n      return \"tag\";\n    }\n    else {\n      state.tokenize = tokenBase;\n    }\n    return \"tag\";\n  };\n}\n\n// tokenizer for XML attributes\nfunction tokenAttribute(stream, state) {\n  var ch = stream.next();\n\n  if(ch == \"/\" && stream.eat(\">\")) {\n    if(isInXmlAttributeBlock(state)) popStateStack(state);\n    if(isInXmlBlock(state)) popStateStack(state);\n    return \"tag\";\n  }\n  if(ch == \">\") {\n    if(isInXmlAttributeBlock(state)) popStateStack(state);\n    return \"tag\";\n  }\n  if(ch == \"=\")\n    return null;\n  // quoted string\n  if (ch == '\"' || ch == \"'\")\n    return chain(stream, state, tokenString(ch, tokenAttribute));\n\n  if(!isInXmlAttributeBlock(state))\n    pushStateStack(state, { type: \"attribute\", tokenize: tokenAttribute});\n\n  stream.eat(/[a-zA-Z_:]/);\n  stream.eatWhile(/[-a-zA-Z0-9_:.]/);\n  stream.eatSpace();\n\n  // the case where the attribute has not value and the tag was closed\n  if(stream.match(\">\", false) || stream.match(\"/\", false)) {\n    popStateStack(state);\n    state.tokenize = tokenBase;\n  }\n\n  return \"attribute\";\n}\n\n// handle comments, including nested\nfunction tokenXMLComment(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"-\" && stream.match(\"->\", true)) {\n      state.tokenize = tokenBase;\n      return \"comment\";\n    }\n  }\n}\n\n\n// handle CDATA\nfunction tokenCDATA(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"]\" && stream.match(\"]\", true)) {\n      state.tokenize = tokenBase;\n      return \"comment\";\n    }\n  }\n}\n\n// handle preprocessing instructions\nfunction tokenPreProcessing(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"?\" && stream.match(\">\", true)) {\n      state.tokenize = tokenBase;\n      return \"processingInstruction\";\n    }\n  }\n}\n\n\n// functions to test the current context of the state\nfunction isInXmlBlock(state) { return isIn(state, \"tag\"); }\nfunction isInXmlAttributeBlock(state) { return isIn(state, \"attribute\"); }\nfunction isInXmlConstructor(state) { return isIn(state, \"xmlconstructor\"); }\nfunction isInString(state) { return isIn(state, \"string\"); }\n\nfunction isEQNameAhead(stream) {\n  // assume we've already eaten a quote (\")\n  if(stream.current() === '\"')\n    return stream.match(/^[^\\\"]+\\\"\\:/, false);\n  else if(stream.current() === '\\'')\n    return stream.match(/^[^\\\"]+\\'\\:/, false);\n  else\n    return false;\n}\n\nfunction isIn(state, type) {\n  return (state.stack.length && state.stack[state.stack.length - 1].type == type);\n}\n\nfunction pushStateStack(state, newState) {\n  state.stack.push(newState);\n}\n\nfunction popStateStack(state) {\n  state.stack.pop();\n  var reinstateTokenize = state.stack.length && state.stack[state.stack.length-1].tokenize;\n  state.tokenize = reinstateTokenize || tokenBase;\n}\n\n// the interface for the mode API\nexport const xQuery = {\n  startState: function() {\n    return {\n      tokenize: tokenBase,\n      cc: [],\n      stack: []\n    };\n  },\n\n  token: function(stream, state) {\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    return style;\n  },\n\n  languageData: {\n    commentTokens: {block: {open: \"(:\", close: \":)\"}}\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}