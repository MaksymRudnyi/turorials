{"ast":null,"code":"/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('parse5').Document} P5Document\n * @typedef {import('parse5').DocumentFragment} P5Fragment\n * @typedef {Omit<import('parse5').Element, 'parentNode'>} P5Element\n * @typedef {import('parse5').Attribute} P5Attribute\n * @typedef {Omit<import('parse5').Location, 'startOffset' | 'endOffset'> & {startOffset: number|undefined, endOffset: number|undefined}} P5Location\n * @typedef {import('parse5').ParserOptions} P5ParserOptions\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').DocType} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Content} Content\n * @typedef {Root|Content} Node\n * @typedef {import('../complex-types').Raw} Raw\n *\n * @typedef {Omit<Comment, 'value'> & {value: {stitch: Node}}} Stitch\n *\n * @typedef Options\n * @property {Array<string>} [passThrough]\n *   List of custom hast node types to pass through (keep) in hast.\n *   If the passed through nodes have children, those children are expected to\n *   be hast and will be handled.\n *\n * @typedef HiddenTokenizer\n * @property {Array<HiddenLocationTracker>} __mixins\n *   Way too simple, but works for us.\n * @property {HiddenPreprocessor} preprocessor\n * @property {(value: string) => void} write\n * @property {() => number} _consume\n * @property {Array<HiddenToken>} tokenQueue\n * @property {string} state\n * @property {string} returnState\n * @property {number} charRefCode\n * @property {Array<number>} tempBuff\n * @property {Function} _flushCodePointsConsumedAsCharacterReference\n * @property {string} lastStartTagName\n * @property {number} consumedAfterSnapshot\n * @property {boolean} active\n * @property {HiddenToken|undefined} currentCharacterToken\n * @property {HiddenToken|undefined} currentToken\n * @property {unknown} currentAttr\n * @property {Function} NAMED_CHARACTER_REFERENCE_STATE\n * @property {Function} NUMERIC_CHARACTER_REFERENCE_END_STATE\n *\n * @typedef {Record<string, unknown> & {location: P5Location}} HiddenToken\n *\n * @typedef HiddenPreprocessor\n * @property {string|undefined} html\n * @property {number} pos\n * @property {number} lastGapPos\n * @property {number} lastCharPos\n * @property {Array<number>} gapStack\n * @property {boolean} skipNextNewLine\n * @property {boolean} lastChunkWritten\n * @property {boolean} endOfChunkHit\n *\n * @typedef HiddenLocationTracker\n * @property {P5Location|undefined} currentAttrLocation\n * @property {P5Location} ctLoc\n * @property {HiddenPosTracker} posTracker\n *\n * @typedef HiddenPosTracker\n * @property {boolean} isEol\n * @property {number} lineStartPos\n * @property {number} droppedBufferSize\n * @property {number} offset\n * @property {number} col\n * @property {number} line\n */\n// @ts-expect-error: untyped.\nimport Parser from 'parse5/lib/parser/index.js';\nimport { pointStart, pointEnd } from 'unist-util-position';\nimport { visit } from 'unist-util-visit';\nimport { fromParse5 } from 'hast-util-from-parse5';\nimport { toParse5 } from 'hast-util-to-parse5';\nimport { htmlVoidElements } from 'html-void-elements';\nimport { webNamespaces } from 'web-namespaces';\nimport { zwitch } from 'zwitch';\nconst inTemplateMode = 'IN_TEMPLATE_MODE';\nconst dataState = 'DATA_STATE';\nconst characterToken = 'CHARACTER_TOKEN';\nconst startTagToken = 'START_TAG_TOKEN';\nconst endTagToken = 'END_TAG_TOKEN';\nconst commentToken = 'COMMENT_TOKEN';\nconst doctypeToken = 'DOCTYPE_TOKEN';\n/** @type {P5ParserOptions} */\n\nconst parseOptions = {\n  sourceCodeLocationInfo: true,\n  scriptingEnabled: false\n};\n/**\n * Given a hast tree and an optional vfile (for positional info), return a new\n * parsed-again hast tree.\n *\n * @param tree\n *   Original hast tree.\n * @param file\n *   Virtual file for positional info, optional.\n * @param options\n *   Configuration.\n */\n\nexport const raw =\n/**\n * @type {(\n *   ((tree: Node, file: VFile|undefined, options?: Options) => Node) &\n *   ((tree: Node, options?: Options) => Node)\n * )}\n */\n\n/**\n * @param {Node} tree\n * @param {VFile} [file]\n * @param {Options} [options]\n */\nfunction (tree, file, options) {\n  let index = -1;\n  const parser = new Parser(parseOptions);\n  const one = zwitch('type', {\n    // @ts-expect-error: hush.\n    handlers: {\n      root,\n      element,\n      text,\n      comment,\n      doctype,\n      raw: handleRaw\n    },\n    // @ts-expect-error: hush.\n    unknown\n  });\n  /** @type {boolean|undefined} */\n\n  let stitches;\n  /** @type {HiddenTokenizer|undefined} */\n\n  let tokenizer;\n  /** @type {HiddenPreprocessor|undefined} */\n\n  let preprocessor;\n  /** @type {HiddenPosTracker|undefined} */\n\n  let posTracker;\n  /** @type {HiddenLocationTracker|undefined} */\n\n  let locationTracker;\n\n  if (isOptions(file)) {\n    options = file;\n    file = undefined;\n  }\n\n  if (options && options.passThrough) {\n    while (++index < options.passThrough.length) {\n      // @ts-expect-error: hush.\n      one.handlers[options.passThrough[index]] = stitch;\n    }\n  }\n\n  const result = fromParse5(documentMode(tree) ? document() : fragment(), file);\n\n  if (stitches) {\n    visit(result, 'comment', (node, index, parent) => {\n      const stitch =\n      /** @type {Stitch} */\n\n      /** @type {unknown} */\n      node;\n\n      if (stitch.value.stitch && parent !== null && index !== null) {\n        // @ts-expect-error: assume the stitch is allowed.\n        parent.children[index] = stitch.value.stitch;\n        return index;\n      }\n    });\n  } // Unpack if possible and when not given a `root`.\n\n\n  if (tree.type !== 'root' && result.type === 'root' && result.children.length === 1) {\n    return result.children[0];\n  }\n\n  return result;\n  /**\n   * @returns {P5Fragment}\n   */\n\n  function fragment() {\n    /** @type {P5Element} */\n    const context = {\n      nodeName: 'template',\n      tagName: 'template',\n      attrs: [],\n      namespaceURI: webNamespaces.html,\n      childNodes: []\n    };\n    /** @type {P5Element} */\n\n    const mock = {\n      nodeName: 'documentmock',\n      tagName: 'documentmock',\n      attrs: [],\n      namespaceURI: webNamespaces.html,\n      childNodes: []\n    };\n    /** @type {P5Fragment} */\n\n    const doc = {\n      nodeName: '#document-fragment',\n      childNodes: []\n    };\n\n    parser._bootstrap(mock, context);\n\n    parser._pushTmplInsertionMode(inTemplateMode);\n\n    parser._initTokenizerForFragmentParsing();\n\n    parser._insertFakeRootElement();\n\n    parser._resetInsertionMode();\n\n    parser._findFormInFragmentContext();\n\n    tokenizer = parser.tokenizer;\n    /* c8 ignore next */\n\n    if (!tokenizer) throw new Error('Expected `tokenizer`');\n    preprocessor = tokenizer.preprocessor;\n    locationTracker = tokenizer.__mixins[0];\n    posTracker = locationTracker.posTracker;\n    one(tree);\n    resetTokenizer();\n\n    parser._adoptNodes(mock.childNodes[0], doc);\n\n    return doc;\n  }\n  /**\n   * @returns {P5Document}\n   */\n\n\n  function document() {\n    /** @type {P5Document} */\n    const doc = parser.treeAdapter.createDocument();\n\n    parser._bootstrap(doc, undefined);\n\n    tokenizer = parser.tokenizer;\n    /* c8 ignore next */\n\n    if (!tokenizer) throw new Error('Expected `tokenizer`');\n    preprocessor = tokenizer.preprocessor;\n    locationTracker = tokenizer.__mixins[0];\n    posTracker = locationTracker.posTracker;\n    one(tree);\n    resetTokenizer();\n    return doc;\n  }\n  /**\n   * @param {Array<Content>} nodes\n   * @returns {void}\n   */\n\n\n  function all(nodes) {\n    let index = -1;\n    /* istanbul ignore else - invalid nodes, see rehypejs/rehype-raw#7. */\n\n    if (nodes) {\n      while (++index < nodes.length) {\n        one(nodes[index]);\n      }\n    }\n  }\n  /**\n   * @param {Root} node\n   * @returns {void}\n   */\n\n\n  function root(node) {\n    all(node.children);\n  }\n  /**\n   * @param {Element} node\n   * @returns {void}\n   */\n\n\n  function element(node) {\n    resetTokenizer();\n\n    parser._processToken(startTag(node), webNamespaces.html);\n\n    all(node.children);\n\n    if (!htmlVoidElements.includes(node.tagName)) {\n      resetTokenizer();\n\n      parser._processToken(endTag(node));\n    }\n  }\n  /**\n   * @param {Text} node\n   * @returns {void}\n   */\n\n\n  function text(node) {\n    resetTokenizer();\n\n    parser._processToken({\n      type: characterToken,\n      chars: node.value,\n      location: createParse5Location(node)\n    });\n  }\n  /**\n   * @param {Doctype} node\n   * @returns {void}\n   */\n\n\n  function doctype(node) {\n    resetTokenizer();\n\n    parser._processToken({\n      type: doctypeToken,\n      name: 'html',\n      forceQuirks: false,\n      publicId: '',\n      systemId: '',\n      location: createParse5Location(node)\n    });\n  }\n  /**\n   * @param {Comment|Stitch} node\n   * @returns {void}\n   */\n\n\n  function comment(node) {\n    resetTokenizer();\n\n    parser._processToken({\n      type: commentToken,\n      data: node.value,\n      location: createParse5Location(node)\n    });\n  }\n  /**\n   * @param {Raw} node\n   * @returns {void}\n   */\n\n\n  function handleRaw(node) {\n    const start = pointStart(node);\n    const line = start.line || 1;\n    const column = start.column || 1;\n    const offset = start.offset || 0;\n    /* c8 ignore next 4 */\n\n    if (!preprocessor) throw new Error('Expected `preprocessor`');\n    if (!tokenizer) throw new Error('Expected `tokenizer`');\n    if (!posTracker) throw new Error('Expected `posTracker`');\n    if (!locationTracker) throw new Error('Expected `locationTracker`'); // Reset preprocessor:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/preprocessor.js#L17>.\n\n    preprocessor.html = undefined;\n    preprocessor.pos = -1;\n    preprocessor.lastGapPos = -1;\n    preprocessor.lastCharPos = -1;\n    preprocessor.gapStack = [];\n    preprocessor.skipNextNewLine = false;\n    preprocessor.lastChunkWritten = false;\n    preprocessor.endOfChunkHit = false; // Reset preprocessor mixin:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/position-tracking/preprocessor-mixin.js>.\n\n    posTracker.isEol = false;\n    posTracker.lineStartPos = -column + 1; // Looks weird, but ensures we get correct positional info.\n\n    posTracker.droppedBufferSize = offset;\n    posTracker.offset = 0;\n    posTracker.col = 1;\n    posTracker.line = line; // Reset location tracker:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js>.\n\n    locationTracker.currentAttrLocation = undefined;\n    locationTracker.ctLoc = createParse5Location(node); // See the code for `parse` and `parseFragment`:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/parser/index.js#L371>.\n\n    tokenizer.write(node.value);\n\n    parser._runParsingLoop(null); // Character references hang, so if we ended there, we need to flush\n    // those too.\n    // We reset the preprocessor as if the document ends here.\n    // Then one single call to the relevant state does the trick, parse5\n    // consumes the whole token.\n\n\n    if (tokenizer.state === 'NAMED_CHARACTER_REFERENCE_STATE' || tokenizer.state === 'NUMERIC_CHARACTER_REFERENCE_END_STATE') {\n      preprocessor.lastChunkWritten = true;\n      tokenizer[tokenizer.state](tokenizer._consume());\n    }\n  }\n  /**\n   * @param {Node} node\n   */\n\n\n  function stitch(node) {\n    stitches = true;\n    /** @type {Node} */\n\n    let clone; // Recurse, because to somewhat handle `[<x>]</x>` (where `[]` denotes the\n    // passed through node).\n\n    if ('children' in node) {\n      clone = { ...node,\n        children: raw({\n          type: 'root',\n          children: node.children\n        }, file, options // @ts-expect-error Assume a given parent yields a parent.\n        ).children\n      };\n    } else {\n      clone = { ...node\n      };\n    } // Hack: `value` is supposed to be a string, but as none of the tools\n    // (`parse5` or `hast-util-from-parse5`) looks at it, we can pass nodes\n    // through.\n\n\n    comment({\n      type: 'comment',\n      value: {\n        stitch: clone\n      }\n    });\n  }\n\n  function resetTokenizer() {\n    /* c8 ignore next 2 */\n    if (!tokenizer) throw new Error('Expected `tokenizer`');\n    if (!posTracker) throw new Error('Expected `posTracker`'); // Process final characters if they’re still there after hibernating.\n    // Similar to:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js#L95>.\n\n    const token = tokenizer.currentCharacterToken;\n\n    if (token) {\n      token.location.endLine = posTracker.line;\n      token.location.endCol = posTracker.col + 1;\n      token.location.endOffset = posTracker.offset + 1;\n\n      parser._processToken(token);\n    } // Reset tokenizer:\n    // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/index.js#L218-L234>.\n    // Especially putting it back in the `data` state is useful: some elements,\n    // like textareas and iframes, change the state.\n    // See GH-7.\n    // But also if broken HTML is in `raw`, and then a correct element is given.\n    // See GH-11.\n\n\n    tokenizer.tokenQueue = [];\n    tokenizer.state = dataState;\n    tokenizer.returnState = '';\n    tokenizer.charRefCode = -1;\n    tokenizer.tempBuff = [];\n    tokenizer.lastStartTagName = '';\n    tokenizer.consumedAfterSnapshot = -1;\n    tokenizer.active = false;\n    tokenizer.currentCharacterToken = undefined;\n    tokenizer.currentToken = undefined;\n    tokenizer.currentAttr = undefined;\n  }\n};\n/**\n * @param {Element} node\n * @returns {HiddenToken}\n */\n\nfunction startTag(node) {\n  /** @type {P5Location} */\n  const location = Object.assign(createParse5Location(node)); // @ts-expect-error extra positional info.\n\n  location.startTag = Object.assign({}, location); // Untyped token.\n\n  return {\n    type: startTagToken,\n    tagName: node.tagName,\n    selfClosing: false,\n    attrs: attributes(node),\n    location\n  };\n}\n/**\n * @param {Element} node\n * @returns {Array<P5Attribute>}\n */\n\n\nfunction attributes(node) {\n  return toParse5({\n    tagName: node.tagName,\n    type: 'element',\n    properties: node.properties,\n    children: [] // @ts-expect-error Assume element.\n\n  }).attrs;\n}\n/**\n * @param {Element} node\n * @returns {HiddenToken}\n */\n\n\nfunction endTag(node) {\n  /** @type {P5Location} */\n  const location = Object.assign(createParse5Location(node)); // @ts-expect-error extra positional info.\n\n  location.startTag = Object.assign({}, location); // Untyped token.\n\n  return {\n    type: endTagToken,\n    tagName: node.tagName,\n    attrs: [],\n    location\n  };\n}\n/**\n * @param {Node} node\n */\n\n\nfunction unknown(node) {\n  throw new Error('Cannot compile `' + node.type + '` node');\n}\n/**\n * @param {Node} node\n * @returns {boolean}\n */\n\n\nfunction documentMode(node) {\n  const head = node.type === 'root' ? node.children[0] : node;\n  return Boolean(head && (head.type === 'doctype' || head.type === 'element' && head.tagName === 'html'));\n}\n/**\n * @param {Node|Stitch} node\n * @returns {P5Location}\n */\n\n\nfunction createParse5Location(node) {\n  const start = pointStart(node);\n  const end = pointEnd(node);\n  return {\n    startLine: start.line,\n    startCol: start.column,\n    startOffset: start.offset,\n    endLine: end.line,\n    endCol: end.column,\n    endOffset: end.offset\n  };\n}\n/**\n * @param {VFile|Options|undefined} value\n * @return {value is Options}\n */\n\n\nfunction isOptions(value) {\n  return Boolean(value && !('message' in value && 'messages' in value));\n}","map":{"version":3,"names":["Parser","pointStart","pointEnd","visit","fromParse5","toParse5","htmlVoidElements","webNamespaces","zwitch","inTemplateMode","dataState","characterToken","startTagToken","endTagToken","commentToken","doctypeToken","parseOptions","sourceCodeLocationInfo","scriptingEnabled","raw","tree","file","options","index","parser","one","handlers","root","element","text","comment","doctype","handleRaw","unknown","stitches","tokenizer","preprocessor","posTracker","locationTracker","isOptions","undefined","passThrough","length","stitch","result","documentMode","document","fragment","node","parent","value","children","type","context","nodeName","tagName","attrs","namespaceURI","html","childNodes","mock","doc","_bootstrap","_pushTmplInsertionMode","_initTokenizerForFragmentParsing","_insertFakeRootElement","_resetInsertionMode","_findFormInFragmentContext","Error","__mixins","resetTokenizer","_adoptNodes","treeAdapter","createDocument","all","nodes","_processToken","startTag","includes","endTag","chars","location","createParse5Location","name","forceQuirks","publicId","systemId","data","start","line","column","offset","pos","lastGapPos","lastCharPos","gapStack","skipNextNewLine","lastChunkWritten","endOfChunkHit","isEol","lineStartPos","droppedBufferSize","col","currentAttrLocation","ctLoc","write","_runParsingLoop","state","_consume","clone","token","currentCharacterToken","endLine","endCol","endOffset","tokenQueue","returnState","charRefCode","tempBuff","lastStartTagName","consumedAfterSnapshot","active","currentToken","currentAttr","Object","assign","selfClosing","attributes","properties","head","Boolean","end","startLine","startCol","startOffset"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/hast-util-raw/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('parse5').Document} P5Document\n * @typedef {import('parse5').DocumentFragment} P5Fragment\n * @typedef {Omit<import('parse5').Element, 'parentNode'>} P5Element\n * @typedef {import('parse5').Attribute} P5Attribute\n * @typedef {Omit<import('parse5').Location, 'startOffset' | 'endOffset'> & {startOffset: number|undefined, endOffset: number|undefined}} P5Location\n * @typedef {import('parse5').ParserOptions} P5ParserOptions\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').DocType} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Content} Content\n * @typedef {Root|Content} Node\n * @typedef {import('../complex-types').Raw} Raw\n *\n * @typedef {Omit<Comment, 'value'> & {value: {stitch: Node}}} Stitch\n *\n * @typedef Options\n * @property {Array<string>} [passThrough]\n *   List of custom hast node types to pass through (keep) in hast.\n *   If the passed through nodes have children, those children are expected to\n *   be hast and will be handled.\n *\n * @typedef HiddenTokenizer\n * @property {Array<HiddenLocationTracker>} __mixins\n *   Way too simple, but works for us.\n * @property {HiddenPreprocessor} preprocessor\n * @property {(value: string) => void} write\n * @property {() => number} _consume\n * @property {Array<HiddenToken>} tokenQueue\n * @property {string} state\n * @property {string} returnState\n * @property {number} charRefCode\n * @property {Array<number>} tempBuff\n * @property {Function} _flushCodePointsConsumedAsCharacterReference\n * @property {string} lastStartTagName\n * @property {number} consumedAfterSnapshot\n * @property {boolean} active\n * @property {HiddenToken|undefined} currentCharacterToken\n * @property {HiddenToken|undefined} currentToken\n * @property {unknown} currentAttr\n * @property {Function} NAMED_CHARACTER_REFERENCE_STATE\n * @property {Function} NUMERIC_CHARACTER_REFERENCE_END_STATE\n *\n * @typedef {Record<string, unknown> & {location: P5Location}} HiddenToken\n *\n * @typedef HiddenPreprocessor\n * @property {string|undefined} html\n * @property {number} pos\n * @property {number} lastGapPos\n * @property {number} lastCharPos\n * @property {Array<number>} gapStack\n * @property {boolean} skipNextNewLine\n * @property {boolean} lastChunkWritten\n * @property {boolean} endOfChunkHit\n *\n * @typedef HiddenLocationTracker\n * @property {P5Location|undefined} currentAttrLocation\n * @property {P5Location} ctLoc\n * @property {HiddenPosTracker} posTracker\n *\n * @typedef HiddenPosTracker\n * @property {boolean} isEol\n * @property {number} lineStartPos\n * @property {number} droppedBufferSize\n * @property {number} offset\n * @property {number} col\n * @property {number} line\n */\n\n// @ts-expect-error: untyped.\nimport Parser from 'parse5/lib/parser/index.js'\nimport {pointStart, pointEnd} from 'unist-util-position'\nimport {visit} from 'unist-util-visit'\nimport {fromParse5} from 'hast-util-from-parse5'\nimport {toParse5} from 'hast-util-to-parse5'\nimport {htmlVoidElements} from 'html-void-elements'\nimport {webNamespaces} from 'web-namespaces'\nimport {zwitch} from 'zwitch'\n\nconst inTemplateMode = 'IN_TEMPLATE_MODE'\nconst dataState = 'DATA_STATE'\nconst characterToken = 'CHARACTER_TOKEN'\nconst startTagToken = 'START_TAG_TOKEN'\nconst endTagToken = 'END_TAG_TOKEN'\nconst commentToken = 'COMMENT_TOKEN'\nconst doctypeToken = 'DOCTYPE_TOKEN'\n\n/** @type {P5ParserOptions} */\nconst parseOptions = {sourceCodeLocationInfo: true, scriptingEnabled: false}\n\n/**\n * Given a hast tree and an optional vfile (for positional info), return a new\n * parsed-again hast tree.\n *\n * @param tree\n *   Original hast tree.\n * @param file\n *   Virtual file for positional info, optional.\n * @param options\n *   Configuration.\n */\nexport const raw =\n  /**\n   * @type {(\n   *   ((tree: Node, file: VFile|undefined, options?: Options) => Node) &\n   *   ((tree: Node, options?: Options) => Node)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {VFile} [file]\n     * @param {Options} [options]\n     */\n    function (tree, file, options) {\n      let index = -1\n      const parser = new Parser(parseOptions)\n      const one = zwitch('type', {\n        // @ts-expect-error: hush.\n        handlers: {root, element, text, comment, doctype, raw: handleRaw},\n        // @ts-expect-error: hush.\n        unknown\n      })\n      /** @type {boolean|undefined} */\n      let stitches\n      /** @type {HiddenTokenizer|undefined} */\n      let tokenizer\n      /** @type {HiddenPreprocessor|undefined} */\n      let preprocessor\n      /** @type {HiddenPosTracker|undefined} */\n      let posTracker\n      /** @type {HiddenLocationTracker|undefined} */\n      let locationTracker\n\n      if (isOptions(file)) {\n        options = file\n        file = undefined\n      }\n\n      if (options && options.passThrough) {\n        while (++index < options.passThrough.length) {\n          // @ts-expect-error: hush.\n          one.handlers[options.passThrough[index]] = stitch\n        }\n      }\n\n      const result = fromParse5(\n        documentMode(tree) ? document() : fragment(),\n        file\n      )\n\n      if (stitches) {\n        visit(result, 'comment', (node, index, parent) => {\n          const stitch = /** @type {Stitch} */ (/** @type {unknown} */ (node))\n          if (stitch.value.stitch && parent !== null && index !== null) {\n            // @ts-expect-error: assume the stitch is allowed.\n            parent.children[index] = stitch.value.stitch\n            return index\n          }\n        })\n      }\n\n      // Unpack if possible and when not given a `root`.\n      if (\n        tree.type !== 'root' &&\n        result.type === 'root' &&\n        result.children.length === 1\n      ) {\n        return result.children[0]\n      }\n\n      return result\n\n      /**\n       * @returns {P5Fragment}\n       */\n      function fragment() {\n        /** @type {P5Element} */\n        const context = {\n          nodeName: 'template',\n          tagName: 'template',\n          attrs: [],\n          namespaceURI: webNamespaces.html,\n          childNodes: []\n        }\n        /** @type {P5Element} */\n        const mock = {\n          nodeName: 'documentmock',\n          tagName: 'documentmock',\n          attrs: [],\n          namespaceURI: webNamespaces.html,\n          childNodes: []\n        }\n        /** @type {P5Fragment} */\n        const doc = {nodeName: '#document-fragment', childNodes: []}\n\n        parser._bootstrap(mock, context)\n        parser._pushTmplInsertionMode(inTemplateMode)\n        parser._initTokenizerForFragmentParsing()\n        parser._insertFakeRootElement()\n        parser._resetInsertionMode()\n        parser._findFormInFragmentContext()\n\n        tokenizer = parser.tokenizer\n        /* c8 ignore next */\n        if (!tokenizer) throw new Error('Expected `tokenizer`')\n        preprocessor = tokenizer.preprocessor\n        locationTracker = tokenizer.__mixins[0]\n        posTracker = locationTracker.posTracker\n\n        one(tree)\n\n        resetTokenizer()\n\n        parser._adoptNodes(mock.childNodes[0], doc)\n\n        return doc\n      }\n\n      /**\n       * @returns {P5Document}\n       */\n      function document() {\n        /** @type {P5Document} */\n        const doc = parser.treeAdapter.createDocument()\n\n        parser._bootstrap(doc, undefined)\n        tokenizer = parser.tokenizer\n        /* c8 ignore next */\n        if (!tokenizer) throw new Error('Expected `tokenizer`')\n        preprocessor = tokenizer.preprocessor\n        locationTracker = tokenizer.__mixins[0]\n        posTracker = locationTracker.posTracker\n\n        one(tree)\n\n        resetTokenizer()\n\n        return doc\n      }\n\n      /**\n       * @param {Array<Content>} nodes\n       * @returns {void}\n       */\n      function all(nodes) {\n        let index = -1\n\n        /* istanbul ignore else - invalid nodes, see rehypejs/rehype-raw#7. */\n        if (nodes) {\n          while (++index < nodes.length) {\n            one(nodes[index])\n          }\n        }\n      }\n\n      /**\n       * @param {Root} node\n       * @returns {void}\n       */\n      function root(node) {\n        all(node.children)\n      }\n\n      /**\n       * @param {Element} node\n       * @returns {void}\n       */\n      function element(node) {\n        resetTokenizer()\n        parser._processToken(startTag(node), webNamespaces.html)\n\n        all(node.children)\n\n        if (!htmlVoidElements.includes(node.tagName)) {\n          resetTokenizer()\n          parser._processToken(endTag(node))\n        }\n      }\n\n      /**\n       * @param {Text} node\n       * @returns {void}\n       */\n      function text(node) {\n        resetTokenizer()\n        parser._processToken({\n          type: characterToken,\n          chars: node.value,\n          location: createParse5Location(node)\n        })\n      }\n\n      /**\n       * @param {Doctype} node\n       * @returns {void}\n       */\n      function doctype(node) {\n        resetTokenizer()\n        parser._processToken({\n          type: doctypeToken,\n          name: 'html',\n          forceQuirks: false,\n          publicId: '',\n          systemId: '',\n          location: createParse5Location(node)\n        })\n      }\n\n      /**\n       * @param {Comment|Stitch} node\n       * @returns {void}\n       */\n      function comment(node) {\n        resetTokenizer()\n        parser._processToken({\n          type: commentToken,\n          data: node.value,\n          location: createParse5Location(node)\n        })\n      }\n\n      /**\n       * @param {Raw} node\n       * @returns {void}\n       */\n      function handleRaw(node) {\n        const start = pointStart(node)\n        const line = start.line || 1\n        const column = start.column || 1\n        const offset = start.offset || 0\n\n        /* c8 ignore next 4 */\n        if (!preprocessor) throw new Error('Expected `preprocessor`')\n        if (!tokenizer) throw new Error('Expected `tokenizer`')\n        if (!posTracker) throw new Error('Expected `posTracker`')\n        if (!locationTracker) throw new Error('Expected `locationTracker`')\n\n        // Reset preprocessor:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/preprocessor.js#L17>.\n        preprocessor.html = undefined\n        preprocessor.pos = -1\n        preprocessor.lastGapPos = -1\n        preprocessor.lastCharPos = -1\n        preprocessor.gapStack = []\n        preprocessor.skipNextNewLine = false\n        preprocessor.lastChunkWritten = false\n        preprocessor.endOfChunkHit = false\n\n        // Reset preprocessor mixin:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/position-tracking/preprocessor-mixin.js>.\n        posTracker.isEol = false\n        posTracker.lineStartPos = -column + 1 // Looks weird, but ensures we get correct positional info.\n        posTracker.droppedBufferSize = offset\n        posTracker.offset = 0\n        posTracker.col = 1\n        posTracker.line = line\n\n        // Reset location tracker:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js>.\n        locationTracker.currentAttrLocation = undefined\n        locationTracker.ctLoc = createParse5Location(node)\n\n        // See the code for `parse` and `parseFragment`:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/parser/index.js#L371>.\n        tokenizer.write(node.value)\n        parser._runParsingLoop(null)\n\n        // Character references hang, so if we ended there, we need to flush\n        // those too.\n        // We reset the preprocessor as if the document ends here.\n        // Then one single call to the relevant state does the trick, parse5\n        // consumes the whole token.\n        if (\n          tokenizer.state === 'NAMED_CHARACTER_REFERENCE_STATE' ||\n          tokenizer.state === 'NUMERIC_CHARACTER_REFERENCE_END_STATE'\n        ) {\n          preprocessor.lastChunkWritten = true\n          tokenizer[tokenizer.state](tokenizer._consume())\n        }\n      }\n\n      /**\n       * @param {Node} node\n       */\n      function stitch(node) {\n        stitches = true\n\n        /** @type {Node} */\n        let clone\n\n        // Recurse, because to somewhat handle `[<x>]</x>` (where `[]` denotes the\n        // passed through node).\n        if ('children' in node) {\n          clone = {\n            ...node,\n            children: raw(\n              {type: 'root', children: node.children},\n              file,\n              options\n              // @ts-expect-error Assume a given parent yields a parent.\n            ).children\n          }\n        } else {\n          clone = {...node}\n        }\n\n        // Hack: `value` is supposed to be a string, but as none of the tools\n        // (`parse5` or `hast-util-from-parse5`) looks at it, we can pass nodes\n        // through.\n        comment({type: 'comment', value: {stitch: clone}})\n      }\n\n      function resetTokenizer() {\n        /* c8 ignore next 2 */\n        if (!tokenizer) throw new Error('Expected `tokenizer`')\n        if (!posTracker) throw new Error('Expected `posTracker`')\n\n        // Process final characters if they’re still there after hibernating.\n        // Similar to:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js#L95>.\n        const token = tokenizer.currentCharacterToken\n\n        if (token) {\n          token.location.endLine = posTracker.line\n          token.location.endCol = posTracker.col + 1\n          token.location.endOffset = posTracker.offset + 1\n          parser._processToken(token)\n        }\n\n        // Reset tokenizer:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/index.js#L218-L234>.\n        // Especially putting it back in the `data` state is useful: some elements,\n        // like textareas and iframes, change the state.\n        // See GH-7.\n        // But also if broken HTML is in `raw`, and then a correct element is given.\n        // See GH-11.\n        tokenizer.tokenQueue = []\n        tokenizer.state = dataState\n        tokenizer.returnState = ''\n        tokenizer.charRefCode = -1\n        tokenizer.tempBuff = []\n        tokenizer.lastStartTagName = ''\n        tokenizer.consumedAfterSnapshot = -1\n        tokenizer.active = false\n        tokenizer.currentCharacterToken = undefined\n        tokenizer.currentToken = undefined\n        tokenizer.currentAttr = undefined\n      }\n    }\n  )\n/**\n * @param {Element} node\n * @returns {HiddenToken}\n */\nfunction startTag(node) {\n  /** @type {P5Location} */\n  const location = Object.assign(createParse5Location(node))\n  // @ts-expect-error extra positional info.\n  location.startTag = Object.assign({}, location)\n\n  // Untyped token.\n  return {\n    type: startTagToken,\n    tagName: node.tagName,\n    selfClosing: false,\n    attrs: attributes(node),\n    location\n  }\n}\n\n/**\n * @param {Element} node\n * @returns {Array<P5Attribute>}\n */\nfunction attributes(node) {\n  return toParse5({\n    tagName: node.tagName,\n    type: 'element',\n    properties: node.properties,\n    children: []\n    // @ts-expect-error Assume element.\n  }).attrs\n}\n\n/**\n * @param {Element} node\n * @returns {HiddenToken}\n */\nfunction endTag(node) {\n  /** @type {P5Location} */\n  const location = Object.assign(createParse5Location(node))\n  // @ts-expect-error extra positional info.\n  location.startTag = Object.assign({}, location)\n\n  // Untyped token.\n  return {\n    type: endTagToken,\n    tagName: node.tagName,\n    attrs: [],\n    location\n  }\n}\n\n/**\n * @param {Node} node\n */\nfunction unknown(node) {\n  throw new Error('Cannot compile `' + node.type + '` node')\n}\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\nfunction documentMode(node) {\n  const head = node.type === 'root' ? node.children[0] : node\n  return Boolean(\n    head &&\n      (head.type === 'doctype' ||\n        (head.type === 'element' && head.tagName === 'html'))\n  )\n}\n\n/**\n * @param {Node|Stitch} node\n * @returns {P5Location}\n */\nfunction createParse5Location(node) {\n  const start = pointStart(node)\n  const end = pointEnd(node)\n\n  return {\n    startLine: start.line,\n    startCol: start.column,\n    startOffset: start.offset,\n    endLine: end.line,\n    endCol: end.column,\n    endOffset: end.offset\n  }\n}\n\n/**\n * @param {VFile|Options|undefined} value\n * @return {value is Options}\n */\nfunction isOptions(value) {\n  return Boolean(value && !('message' in value && 'messages' in value))\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,OAAOA,MAAP,MAAmB,4BAAnB;AACA,SAAQC,UAAR,EAAoBC,QAApB,QAAmC,qBAAnC;AACA,SAAQC,KAAR,QAAoB,kBAApB;AACA,SAAQC,UAAR,QAAyB,uBAAzB;AACA,SAAQC,QAAR,QAAuB,qBAAvB;AACA,SAAQC,gBAAR,QAA+B,oBAA/B;AACA,SAAQC,aAAR,QAA4B,gBAA5B;AACA,SAAQC,MAAR,QAAqB,QAArB;AAEA,MAAMC,cAAc,GAAG,kBAAvB;AACA,MAAMC,SAAS,GAAG,YAAlB;AACA,MAAMC,cAAc,GAAG,iBAAvB;AACA,MAAMC,aAAa,GAAG,iBAAtB;AACA,MAAMC,WAAW,GAAG,eAApB;AACA,MAAMC,YAAY,GAAG,eAArB;AACA,MAAMC,YAAY,GAAG,eAArB;AAEA;;AACA,MAAMC,YAAY,GAAG;EAACC,sBAAsB,EAAE,IAAzB;EAA+BC,gBAAgB,EAAE;AAAjD,CAArB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,GAAG;AACd;AACF;AACA;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACI,UAAUC,IAAV,EAAgBC,IAAhB,EAAsBC,OAAtB,EAA+B;EAC7B,IAAIC,KAAK,GAAG,CAAC,CAAb;EACA,MAAMC,MAAM,GAAG,IAAIxB,MAAJ,CAAWgB,YAAX,CAAf;EACA,MAAMS,GAAG,GAAGjB,MAAM,CAAC,MAAD,EAAS;IACzB;IACAkB,QA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"},"metadata":{},"sourceType":"module"}