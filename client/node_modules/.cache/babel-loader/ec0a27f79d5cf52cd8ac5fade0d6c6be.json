{"ast":null,"code":"/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').SelectIterator} SelectIterator\n * @typedef {import('./types.js').Handler} Handler\n */\nimport { zwitch } from 'zwitch';\nimport { enterState } from './enter-state.js';\nimport { parent, element } from './util.js';\nconst own = {}.hasOwnProperty;\nconst handle = zwitch('nestingOperator', {\n  // @ts-expect-error: hush.\n  unknown: unknownNesting,\n  // @ts-expect-error: hush.\n  invalid: topScan,\n  // `undefined` is the top query selector.\n  handlers: {\n    // @ts-expect-error: hush.\n    null: descendant,\n    // `null` is the descendant combinator.\n    // @ts-expect-error: hush.\n    '>': child,\n    // @ts-expect-error: hush.\n    '+': adjacentSibling,\n    // @ts-expect-error: hush.\n    '~': generalSibling\n  }\n});\n/** @type {Handler} */\n\nexport function nest(query, node, index, parent, state) {\n  handle(query, node, index, parent, state);\n} // Shouldn’t be called, parser gives correct data.\n\n/* c8 ignore next 6 */\n\n/**\n * @param {{[x: string]: unknown, type: string}} query\n */\n\nfunction unknownNesting(query) {\n  throw new Error('Unexpected nesting `' + query.nestingOperator + '`');\n}\n/** @type {Handler} */\n\n\nfunction topScan(query, node, index, parent, state) {\n  // Shouldn’t happen.\n\n  /* c8 ignore next 3 */\n  if (parent || index === null) {\n    throw new Error('topScan is supposed to be called from the root node');\n  } // Shouldn’t happen.\n\n  /* c8 ignore next 3 */\n\n\n  if (!state.iterator) {\n    throw new Error('Expected `iterator`');\n  }\n\n  state.iterator(query, node, index, parent, state);\n  if (!state.shallow) descendant(query, node, index, parent, state);\n}\n/** @type {Handler} */\n\n\nfunction descendant(query, node, index, parent, state) {\n  const previous = state.iterator;\n  state.iterator = iterator;\n  child(query, node, index, parent, state);\n  /** @type {SelectIterator} */\n\n  function iterator(query, node, index, parent, state) {\n    // Shouldn’t happen.\n\n    /* c8 ignore next 3 */\n    if (!previous) {\n      throw new Error('Expected `iterator`');\n    }\n\n    state.iterator = previous;\n    previous(query, node, index, parent, state);\n    state.iterator = iterator;\n    if (state.one && state.found) return;\n    child(query, node, index, parent, state);\n  }\n}\n/** @type {Handler} */\n\n\nfunction child(query, node, _1, _2, state) {\n  if (!parent(node)) return;\n  if (node.children.length === 0) return;\n  indexedSearch(query, node, state);\n}\n/** @type {Handler} */\n\n\nfunction adjacentSibling(query, _, index, parent, state) {\n  // Shouldn’t happen.\n\n  /* c8 ignore next */\n  if (!parent || index === null) return;\n  indexedSearch(query, parent, state, index + 1, true);\n}\n/** @type {Handler} */\n\n\nfunction generalSibling(query, _, index, parent, state) {\n  // Shouldn’t happen.\n\n  /* c8 ignore next */\n  if (!parent || index === null) return;\n  indexedSearch(query, parent, state, index + 1);\n}\n/**\n * Handles `typeIndex` and `typeCount` properties for every walker.\n *\n * @param {Rule} query\n * @param {Parent} parent\n * @param {SelectState} state\n * @param {number} [from=0]\n * @param {boolean} [firstElementOnly=false]\n */\n\n\nfunction indexedSearch(query, parent, state, from, firstElementOnly) {\n  const handle = state.index ? delay : add;\n  const children = parent.children;\n  let elements = 0;\n  let index = -1;\n  /** @type {Record<string, number>} */\n\n  const types = {};\n  /** @type {Array<Function>} */\n\n  const delayed = []; // Start looking at `from`\n\n  if (from === undefined || from === null) from = 0; // Exit if there are no further nodes.\n\n  if (from >= children.length) return; // If we need to index for types, do so for all elements before `from`.\n\n  if (state.index) {\n    while (++index < from) {\n      const child = children[index];\n      if (element(child)) count(child.tagName);\n    }\n  }\n\n  index = from - 1;\n\n  while (++index < children.length) {\n    const child = children[index]; // Only check elements.\n    // Check either all elements, or only check the first sibling\n\n    if (element(child)) {\n      handle(child, index); // Stop if we’re looking for one node and it’s already found.\n\n      if (state.one && state.found) return;\n      if (firstElementOnly) break;\n    }\n  }\n\n  if (state.index) {\n    index = -1;\n\n    while (++index < delayed.length) {\n      delayed[index]();\n      if (state.one && state.found) return;\n    }\n  }\n  /**\n   * @param {Element} node\n   * @param {number} childIndex\n   */\n\n\n  function delay(node, childIndex) {\n    const elementsBefore = elements;\n    const elementsByTypeBefore = own.call(types, node.tagName) ? types[node.tagName] : 0;\n    count(node.tagName);\n    delayed.push(fn);\n\n    function fn() {\n      // Before counting further elements:\n      state.elementIndex = elementsBefore;\n      state.typeIndex = elementsByTypeBefore; // After counting all elements.\n\n      state.elementCount = elements;\n      state.typeCount = types[node.tagName];\n      add(node, childIndex);\n    }\n  }\n  /**\n   * @param {Element} node\n   * @param {number} childIndex\n   */\n\n\n  function add(node, childIndex) {\n    const exit = enterState(state, node); // Shouldn’t happen.\n\n    /* c8 ignore next 3 */\n\n    if (!state.iterator) {\n      throw new Error('Expected `iterator`');\n    }\n\n    state.iterator(query, node, childIndex, parent, state);\n    exit();\n  }\n  /**\n   * @param {string} name\n   */\n\n\n  function count(name) {\n    if (!own.call(types, name)) types[name] = 0;\n    elements++;\n    types[name]++;\n  }\n}","map":{"version":3,"names":["zwitch","enterState","parent","element","own","hasOwnProperty","handle","unknown","unknownNesting","invalid","topScan","handlers","null","descendant","child","adjacentSibling","generalSibling","nest","query","node","index","state","Error","nestingOperator","iterator","shallow","previous","one","found","_1","_2","children","length","indexedSearch","_","from","firstElementOnly","delay","add","elements","types","delayed","undefined","count","tagName","childIndex","elementsBefore","elementsByTypeBefore","call","push","fn","elementIndex","typeIndex","elementCount","typeCount","exit","name"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/hast-util-select/lib/nest.js"],"sourcesContent":["/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').SelectIterator} SelectIterator\n * @typedef {import('./types.js').Handler} Handler\n */\n\nimport {zwitch} from 'zwitch'\nimport {enterState} from './enter-state.js'\nimport {parent, element} from './util.js'\n\nconst own = {}.hasOwnProperty\n\nconst handle = zwitch('nestingOperator', {\n  // @ts-expect-error: hush.\n  unknown: unknownNesting,\n  // @ts-expect-error: hush.\n  invalid: topScan, // `undefined` is the top query selector.\n  handlers: {\n    // @ts-expect-error: hush.\n    null: descendant, // `null` is the descendant combinator.\n    // @ts-expect-error: hush.\n    '>': child,\n    // @ts-expect-error: hush.\n    '+': adjacentSibling,\n    // @ts-expect-error: hush.\n    '~': generalSibling\n  }\n})\n\n/** @type {Handler} */\nexport function nest(query, node, index, parent, state) {\n  handle(query, node, index, parent, state)\n}\n\n// Shouldn’t be called, parser gives correct data.\n/* c8 ignore next 6 */\n/**\n * @param {{[x: string]: unknown, type: string}} query\n */\nfunction unknownNesting(query) {\n  throw new Error('Unexpected nesting `' + query.nestingOperator + '`')\n}\n\n/** @type {Handler} */\nfunction topScan(query, node, index, parent, state) {\n  // Shouldn’t happen.\n  /* c8 ignore next 3 */\n  if (parent || index === null) {\n    throw new Error('topScan is supposed to be called from the root node')\n  }\n\n  // Shouldn’t happen.\n  /* c8 ignore next 3 */\n  if (!state.iterator) {\n    throw new Error('Expected `iterator`')\n  }\n\n  state.iterator(query, node, index, parent, state)\n  if (!state.shallow) descendant(query, node, index, parent, state)\n}\n\n/** @type {Handler} */\nfunction descendant(query, node, index, parent, state) {\n  const previous = state.iterator\n\n  state.iterator = iterator\n  child(query, node, index, parent, state)\n\n  /** @type {SelectIterator} */\n  function iterator(query, node, index, parent, state) {\n    // Shouldn’t happen.\n    /* c8 ignore next 3 */\n    if (!previous) {\n      throw new Error('Expected `iterator`')\n    }\n\n    state.iterator = previous\n    previous(query, node, index, parent, state)\n    state.iterator = iterator\n\n    if (state.one && state.found) return\n\n    child(query, node, index, parent, state)\n  }\n}\n\n/** @type {Handler} */\nfunction child(query, node, _1, _2, state) {\n  if (!parent(node)) return\n  if (node.children.length === 0) return\n  indexedSearch(query, node, state)\n}\n\n/** @type {Handler} */\nfunction adjacentSibling(query, _, index, parent, state) {\n  // Shouldn’t happen.\n  /* c8 ignore next */\n  if (!parent || index === null) return\n  indexedSearch(query, parent, state, index + 1, true)\n}\n\n/** @type {Handler} */\nfunction generalSibling(query, _, index, parent, state) {\n  // Shouldn’t happen.\n  /* c8 ignore next */\n  if (!parent || index === null) return\n  indexedSearch(query, parent, state, index + 1)\n}\n\n/**\n * Handles `typeIndex` and `typeCount` properties for every walker.\n *\n * @param {Rule} query\n * @param {Parent} parent\n * @param {SelectState} state\n * @param {number} [from=0]\n * @param {boolean} [firstElementOnly=false]\n */\nfunction indexedSearch(query, parent, state, from, firstElementOnly) {\n  const handle = state.index ? delay : add\n  const children = parent.children\n  let elements = 0\n  let index = -1\n  /** @type {Record<string, number>} */\n  const types = {}\n  /** @type {Array<Function>} */\n  const delayed = []\n\n  // Start looking at `from`\n  if (from === undefined || from === null) from = 0\n\n  // Exit if there are no further nodes.\n  if (from >= children.length) return\n\n  // If we need to index for types, do so for all elements before `from`.\n  if (state.index) {\n    while (++index < from) {\n      const child = children[index]\n      if (element(child)) count(child.tagName)\n    }\n  }\n\n  index = from - 1\n\n  while (++index < children.length) {\n    const child = children[index]\n    // Only check elements.\n    // Check either all elements, or only check the first sibling\n    if (element(child)) {\n      handle(child, index)\n\n      // Stop if we’re looking for one node and it’s already found.\n      if (state.one && state.found) return\n      if (firstElementOnly) break\n    }\n  }\n\n  if (state.index) {\n    index = -1\n\n    while (++index < delayed.length) {\n      delayed[index]()\n      if (state.one && state.found) return\n    }\n  }\n\n  /**\n   * @param {Element} node\n   * @param {number} childIndex\n   */\n  function delay(node, childIndex) {\n    const elementsBefore = elements\n    const elementsByTypeBefore = own.call(types, node.tagName)\n      ? types[node.tagName]\n      : 0\n\n    count(node.tagName)\n\n    delayed.push(fn)\n\n    function fn() {\n      // Before counting further elements:\n      state.elementIndex = elementsBefore\n      state.typeIndex = elementsByTypeBefore\n\n      // After counting all elements.\n      state.elementCount = elements\n      state.typeCount = types[node.tagName]\n\n      add(node, childIndex)\n    }\n  }\n\n  /**\n   * @param {Element} node\n   * @param {number} childIndex\n   */\n  function add(node, childIndex) {\n    const exit = enterState(state, node)\n\n    // Shouldn’t happen.\n    /* c8 ignore next 3 */\n    if (!state.iterator) {\n      throw new Error('Expected `iterator`')\n    }\n\n    state.iterator(query, node, childIndex, parent, state)\n    exit()\n  }\n\n  /**\n   * @param {string} name\n   */\n  function count(name) {\n    if (!own.call(types, name)) types[name] = 0\n    elements++\n    types[name]++\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}