{"ast":null,"code":"function wordRegexp(words) {\n  return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n}\n\nvar singleOperators = /[\\^@!\\|<>#~\\.\\*\\-\\+\\\\/,=]/;\nvar doubleOperators = /(<-)|(:=)|(=<)|(>=)|(<=)|(<:)|(>:)|(=:)|(\\\\=)|(\\\\=:)|(!!)|(==)|(::)/;\nvar tripleOperators = /(:::)|(\\.\\.\\.)|(=<:)|(>=:)/;\nvar middle = [\"in\", \"then\", \"else\", \"of\", \"elseof\", \"elsecase\", \"elseif\", \"catch\", \"finally\", \"with\", \"require\", \"prepare\", \"import\", \"export\", \"define\", \"do\"];\nvar end = [\"end\"];\nvar atoms = wordRegexp([\"true\", \"false\", \"nil\", \"unit\"]);\nvar commonKeywords = wordRegexp([\"andthen\", \"at\", \"attr\", \"declare\", \"feat\", \"from\", \"lex\", \"mod\", \"div\", \"mode\", \"orelse\", \"parser\", \"prod\", \"prop\", \"scanner\", \"self\", \"syn\", \"token\"]);\nvar openingKeywords = wordRegexp([\"local\", \"proc\", \"fun\", \"case\", \"class\", \"if\", \"cond\", \"or\", \"dis\", \"choice\", \"not\", \"thread\", \"try\", \"raise\", \"lock\", \"for\", \"suchthat\", \"meth\", \"functor\"]);\nvar middleKeywords = wordRegexp(middle);\nvar endKeywords = wordRegexp(end); // Tokenizers\n\nfunction tokenBase(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  } // Brackets\n\n\n  if (stream.match(/[{}]/)) {\n    return \"bracket\";\n  } // Special [] keyword\n\n\n  if (stream.match('[]')) {\n    return \"keyword\";\n  } // Operators\n\n\n  if (stream.match(tripleOperators) || stream.match(doubleOperators)) {\n    return \"operator\";\n  } // Atoms\n\n\n  if (stream.match(atoms)) {\n    return 'atom';\n  } // Opening keywords\n\n\n  var matched = stream.match(openingKeywords);\n\n  if (matched) {\n    if (!state.doInCurrentLine) state.currentIndent++;else state.doInCurrentLine = false; // Special matching for signatures\n\n    if (matched[0] == \"proc\" || matched[0] == \"fun\") state.tokenize = tokenFunProc;else if (matched[0] == \"class\") state.tokenize = tokenClass;else if (matched[0] == \"meth\") state.tokenize = tokenMeth;\n    return 'keyword';\n  } // Middle and other keywords\n\n\n  if (stream.match(middleKeywords) || stream.match(commonKeywords)) {\n    return \"keyword\";\n  } // End keywords\n\n\n  if (stream.match(endKeywords)) {\n    state.currentIndent--;\n    return 'keyword';\n  } // Eat the next char for next comparisons\n\n\n  var ch = stream.next(); // Strings\n\n  if (ch == '\"' || ch == \"'\") {\n    state.tokenize = tokenString(ch);\n    return state.tokenize(stream, state);\n  } // Numbers\n\n\n  if (/[~\\d]/.test(ch)) {\n    if (ch == \"~\") {\n      if (!/^[0-9]/.test(stream.peek())) return null;else if (stream.next() == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/)) return \"number\";\n    }\n\n    if (ch == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/)) return \"number\";\n    return null;\n  } // Comments\n\n\n  if (ch == \"%\") {\n    stream.skipToEnd();\n    return 'comment';\n  } else if (ch == \"/\") {\n    if (stream.eat(\"*\")) {\n      state.tokenize = tokenComment;\n      return tokenComment(stream, state);\n    }\n  } // Single operators\n\n\n  if (singleOperators.test(ch)) {\n    return \"operator\";\n  } // If nothing match, we skip the entire alphanumerical block\n\n\n  stream.eatWhile(/\\w/);\n  return \"variable\";\n}\n\nfunction tokenClass(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)/);\n  state.tokenize = tokenBase;\n  return \"type\";\n}\n\nfunction tokenMeth(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  stream.match(/([a-zA-Z][A-Za-z0-9_]*)|(`.+`)/);\n  state.tokenize = tokenBase;\n  return \"def\";\n}\n\nfunction tokenFunProc(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  if (!state.hasPassedFirstStage && stream.eat(\"{\")) {\n    state.hasPassedFirstStage = true;\n    return \"bracket\";\n  } else if (state.hasPassedFirstStage) {\n    stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)|\\$/);\n    state.hasPassedFirstStage = false;\n    state.tokenize = tokenBase;\n    return \"def\";\n  } else {\n    state.tokenize = tokenBase;\n    return null;\n  }\n}\n\nfunction tokenComment(stream, state) {\n  var maybeEnd = false,\n      ch;\n\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = tokenBase;\n      break;\n    }\n\n    maybeEnd = ch == \"*\";\n  }\n\n  return \"comment\";\n}\n\nfunction tokenString(quote) {\n  return function (stream, state) {\n    var escaped = false,\n        next,\n        end = false;\n\n    while ((next = stream.next()) != null) {\n      if (next == quote && !escaped) {\n        end = true;\n        break;\n      }\n\n      escaped = !escaped && next == \"\\\\\";\n    }\n\n    if (end || !escaped) state.tokenize = tokenBase;\n    return \"string\";\n  };\n}\n\nfunction buildElectricInputRegEx() {\n  // Reindentation should occur on [] or on a match of any of\n  // the block closing keywords, at the end of a line.\n  var allClosings = middle.concat(end);\n  return new RegExp(\"[\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n}\n\nexport const oz = {\n  startState: function () {\n    return {\n      tokenize: tokenBase,\n      currentIndent: 0,\n      doInCurrentLine: false,\n      hasPassedFirstStage: false\n    };\n  },\n  token: function (stream, state) {\n    if (stream.sol()) state.doInCurrentLine = 0;\n    return state.tokenize(stream, state);\n  },\n  indent: function (state, textAfter, cx) {\n    var trueText = textAfter.replace(/^\\s+|\\s+$/g, '');\n    if (trueText.match(endKeywords) || trueText.match(middleKeywords) || trueText.match(/(\\[])/)) return cx.unit * (state.currentIndent - 1);\n    if (state.currentIndent < 0) return 0;\n    return state.currentIndent * cx.unit;\n  },\n  languageData: {\n    indentOnInut: buildElectricInputRegEx(),\n    commentTokens: {\n      line: \"%\",\n      block: {\n        open: \"/*\",\n        close: \"*/\"\n      }\n    }\n  }\n};","map":{"version":3,"names":["wordRegexp","words","RegExp","join","singleOperators","doubleOperators","tripleOperators","middle","end","atoms","commonKeywords","openingKeywords","middleKeywords","endKeywords","tokenBase","stream","state","eatSpace","match","matched","doInCurrentLine","currentIndent","tokenize","tokenFunProc","tokenClass","tokenMeth","ch","next","tokenString","test","peek","skipToEnd","eat","tokenComment","eatWhile","hasPassedFirstStage","maybeEnd","quote","escaped","buildElectricInputRegEx","allClosings","concat","oz","startState","token","sol","indent","textAfter","cx","trueText","replace","unit","languageData","indentOnInut","commentTokens","line","block","open","close"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/@codemirror/legacy-modes/mode/oz.js"],"sourcesContent":["function wordRegexp(words) {\n  return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n}\n\nvar singleOperators = /[\\^@!\\|<>#~\\.\\*\\-\\+\\\\/,=]/;\nvar doubleOperators = /(<-)|(:=)|(=<)|(>=)|(<=)|(<:)|(>:)|(=:)|(\\\\=)|(\\\\=:)|(!!)|(==)|(::)/;\nvar tripleOperators = /(:::)|(\\.\\.\\.)|(=<:)|(>=:)/;\n\nvar middle = [\"in\", \"then\", \"else\", \"of\", \"elseof\", \"elsecase\", \"elseif\", \"catch\",\n              \"finally\", \"with\", \"require\", \"prepare\", \"import\", \"export\", \"define\", \"do\"];\nvar end = [\"end\"];\n\nvar atoms = wordRegexp([\"true\", \"false\", \"nil\", \"unit\"]);\nvar commonKeywords = wordRegexp([\"andthen\", \"at\", \"attr\", \"declare\", \"feat\", \"from\", \"lex\",\n                                 \"mod\", \"div\", \"mode\", \"orelse\", \"parser\", \"prod\", \"prop\", \"scanner\", \"self\", \"syn\", \"token\"]);\nvar openingKeywords = wordRegexp([\"local\", \"proc\", \"fun\", \"case\", \"class\", \"if\", \"cond\", \"or\", \"dis\",\n                                  \"choice\", \"not\", \"thread\", \"try\", \"raise\", \"lock\", \"for\", \"suchthat\", \"meth\", \"functor\"]);\nvar middleKeywords = wordRegexp(middle);\nvar endKeywords = wordRegexp(end);\n\n// Tokenizers\nfunction tokenBase(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  // Brackets\n  if(stream.match(/[{}]/)) {\n    return \"bracket\";\n  }\n\n  // Special [] keyword\n  if (stream.match('[]')) {\n    return \"keyword\"\n  }\n\n  // Operators\n  if (stream.match(tripleOperators) || stream.match(doubleOperators)) {\n    return \"operator\";\n  }\n\n  // Atoms\n  if(stream.match(atoms)) {\n    return 'atom';\n  }\n\n  // Opening keywords\n  var matched = stream.match(openingKeywords);\n  if (matched) {\n    if (!state.doInCurrentLine)\n      state.currentIndent++;\n    else\n      state.doInCurrentLine = false;\n\n    // Special matching for signatures\n    if(matched[0] == \"proc\" || matched[0] == \"fun\")\n      state.tokenize = tokenFunProc;\n    else if(matched[0] == \"class\")\n      state.tokenize = tokenClass;\n    else if(matched[0] == \"meth\")\n      state.tokenize = tokenMeth;\n\n    return 'keyword';\n  }\n\n  // Middle and other keywords\n  if (stream.match(middleKeywords) || stream.match(commonKeywords)) {\n    return \"keyword\"\n  }\n\n  // End keywords\n  if (stream.match(endKeywords)) {\n    state.currentIndent--;\n    return 'keyword';\n  }\n\n  // Eat the next char for next comparisons\n  var ch = stream.next();\n\n  // Strings\n  if (ch == '\"' || ch == \"'\") {\n    state.tokenize = tokenString(ch);\n    return state.tokenize(stream, state);\n  }\n\n  // Numbers\n  if (/[~\\d]/.test(ch)) {\n    if (ch == \"~\") {\n      if(! /^[0-9]/.test(stream.peek()))\n        return null;\n      else if (( stream.next() == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/)) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/))\n        return \"number\";\n    }\n\n    if ((ch == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/)) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/))\n      return \"number\";\n\n    return null;\n  }\n\n  // Comments\n  if (ch == \"%\") {\n    stream.skipToEnd();\n    return 'comment';\n  }\n  else if (ch == \"/\") {\n    if (stream.eat(\"*\")) {\n      state.tokenize = tokenComment;\n      return tokenComment(stream, state);\n    }\n  }\n\n  // Single operators\n  if(singleOperators.test(ch)) {\n    return \"operator\";\n  }\n\n  // If nothing match, we skip the entire alphanumerical block\n  stream.eatWhile(/\\w/);\n\n  return \"variable\";\n}\n\nfunction tokenClass(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n  stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)/);\n  state.tokenize = tokenBase;\n  return \"type\"\n}\n\nfunction tokenMeth(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n  stream.match(/([a-zA-Z][A-Za-z0-9_]*)|(`.+`)/);\n  state.tokenize = tokenBase;\n  return \"def\"\n}\n\nfunction tokenFunProc(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  if(!state.hasPassedFirstStage && stream.eat(\"{\")) {\n    state.hasPassedFirstStage = true;\n    return \"bracket\";\n  }\n  else if(state.hasPassedFirstStage) {\n    stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)|\\$/);\n    state.hasPassedFirstStage = false;\n    state.tokenize = tokenBase;\n    return \"def\"\n  }\n  else {\n    state.tokenize = tokenBase;\n    return null;\n  }\n}\n\nfunction tokenComment(stream, state) {\n  var maybeEnd = false, ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    maybeEnd = (ch == \"*\");\n  }\n  return \"comment\";\n}\n\nfunction tokenString(quote) {\n  return function (stream, state) {\n    var escaped = false, next, end = false;\n    while ((next = stream.next()) != null) {\n      if (next == quote && !escaped) {\n        end = true;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    if (end || !escaped)\n      state.tokenize = tokenBase;\n    return \"string\";\n  };\n}\n\nfunction buildElectricInputRegEx() {\n  // Reindentation should occur on [] or on a match of any of\n  // the block closing keywords, at the end of a line.\n  var allClosings = middle.concat(end);\n  return new RegExp(\"[\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n}\n\nexport const oz = {\n\n  startState: function () {\n    return {\n      tokenize: tokenBase,\n      currentIndent: 0,\n      doInCurrentLine: false,\n      hasPassedFirstStage: false\n    };\n  },\n\n  token: function (stream, state) {\n    if (stream.sol())\n      state.doInCurrentLine = 0;\n\n    return state.tokenize(stream, state);\n  },\n\n  indent: function (state, textAfter, cx) {\n    var trueText = textAfter.replace(/^\\s+|\\s+$/g, '');\n\n    if (trueText.match(endKeywords) || trueText.match(middleKeywords) || trueText.match(/(\\[])/))\n      return cx.unit * (state.currentIndent - 1);\n\n    if (state.currentIndent < 0)\n      return 0;\n\n    return state.currentIndent * cx.unit\n  },\n\n  languageData: {\n    indentOnInut: buildElectricInputRegEx(),\n    commentTokens: {line: \"%\", block: {open: \"/*\", close: \"*/\"}}\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}