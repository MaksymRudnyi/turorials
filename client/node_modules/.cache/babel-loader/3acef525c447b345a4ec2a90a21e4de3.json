{"ast":null,"code":"import boolbase from \"boolbase\";\n/**\n * Returns a function that checks if an elements index matches the given rule\n * highly optimized to return the fastest solution.\n *\n * @param parsed A tuple [a, b], as returned by `parse`.\n * @returns A highly optimized function that returns whether an index matches the nth-check.\n * @example\n *\n * ```js\n * const check = nthCheck.compile([2, 3]);\n *\n * check(0); // `false`\n * check(1); // `false`\n * check(2); // `true`\n * check(3); // `false`\n * check(4); // `true`\n * check(5); // `false`\n * check(6); // `true`\n * ```\n */\n\nexport function compile(parsed) {\n  const a = parsed[0]; // Subtract 1 from `b`, to convert from one- to zero-indexed.\n\n  const b = parsed[1] - 1;\n  /*\n   * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.\n   * Besides, the specification states that no elements are\n   * matched when `a` and `b` are 0.\n   *\n   * `b < 0` here as we subtracted 1 from `b` above.\n   */\n\n  if (b < 0 && a <= 0) return boolbase.falseFunc; // When `a` is in the range -1..1, it matches any element (so only `b` is checked).\n\n  if (a === -1) return index => index <= b;\n  if (a === 0) return index => index === b; // When `b <= 0` and `a === 1`, they match any element.\n\n  if (a === 1) return b < 0 ? boolbase.trueFunc : index => index >= b;\n  /*\n   * Otherwise, modulo can be used to check if there is a match.\n   *\n   * Modulo doesn't care about the sign, so let's use `a`s absolute value.\n   */\n\n  const absA = Math.abs(a); // Get `b mod a`, + a if this is negative.\n\n  const bMod = (b % absA + absA) % absA;\n  return a > 1 ? index => index >= b && index % absA === bMod : index => index <= b && index % absA === bMod;\n}\n/**\n * Returns a function that produces a monotonously increasing sequence of indices.\n *\n * If the sequence has an end, the returned function will return `null` after\n * the last index in the sequence.\n *\n * @param parsed A tuple [a, b], as returned by `parse`.\n * @returns A function that produces a sequence of indices.\n * @example <caption>Always increasing (2n+3)</caption>\n *\n * ```js\n * const gen = nthCheck.generate([2, 3])\n *\n * gen() // `1`\n * gen() // `3`\n * gen() // `5`\n * gen() // `8`\n * gen() // `11`\n * ```\n *\n * @example <caption>With end value (-2n+10)</caption>\n *\n * ```js\n *\n * const gen = nthCheck.generate([-2, 5]);\n *\n * gen() // 0\n * gen() // 2\n * gen() // 4\n * gen() // null\n * ```\n */\n\nexport function generate(parsed) {\n  const a = parsed[0]; // Subtract 1 from `b`, to convert from one- to zero-indexed.\n\n  let b = parsed[1] - 1;\n  let n = 0; // Make sure to always return an increasing sequence\n\n  if (a < 0) {\n    const aPos = -a; // Get `b mod a`\n\n    const minValue = (b % aPos + aPos) % aPos;\n    return () => {\n      const val = minValue + aPos * n++;\n      return val > b ? null : val;\n    };\n  }\n\n  if (a === 0) return b < 0 ? // There are no result — always return `null`\n  () => null : // Return `b` exactly once\n  () => n++ === 0 ? b : null;\n\n  if (b < 0) {\n    b += a * Math.ceil(-b / a);\n  }\n\n  return () => a * n++ + b;\n}","map":{"version":3,"sources":["compile.ts"],"names":[],"mappings":"AAAA,OAAO,QAAP,MAAqB,UAArB;AAEA;;;;;;;;;;;;;;;;;;;AAmBG;;AACH,OAAM,SAAU,OAAV,CACF,MADE,EAC4B;EAE9B,MAAM,CAAC,GAAG,MAAM,CAAC,CAAD,CAAhB,CAF8B,CAG9B;;EACA,MAAM,CAAC,GAAG,MAAM,CAAC,CAAD,CAAN,GAAY,CAAtB;EAEA;;;;;;AAMG;;EACH,IAAI,CAAC,GAAG,CAAJ,IAAS,CAAC,IAAI,CAAlB,EAAqB,OAAO,QAAQ,CAAC,SAAhB,CAbS,CAe9B;;EACA,IAAI,CAAC,KAAK,CAAC,CAAX,EAAc,OAAQ,KAAD,IAAW,KAAK,IAAI,CAA3B;EACd,IAAI,CAAC,KAAK,CAAV,EAAa,OAAQ,KAAD,IAAW,KAAK,KAAK,CAA5B,CAjBiB,CAkB9B;;EACA,IAAI,CAAC,KAAK,CAAV,EAAa,OAAO,CAAC,GAAG,CAAJ,GAAQ,QAAQ,CAAC,QAAjB,GAA6B,KAAD,IAAW,KAAK,IAAI,CAAvD;EAEb;;;;AAIG;;EACH,MAAM,IAAI,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,CAAb,CA1B8B,CA2B9B;;EACA,MAAM,IAAI,GAAG,CAAE,CAAC,GAAG,IAAL,GAAa,IAAd,IAAsB,IAAnC;EAEA,OAAO,CAAC,GAAG,CAAJ,GACA,KAAD,IAAW,KAAK,IAAI,CAAT,IAAc,KAAK,GAAG,IAAR,KAAiB,IADzC,GAEA,KAAD,IAAW,KAAK,IAAI,CAAT,IAAc,KAAK,GAAG,IAAR,KAAiB,IAFhD;AAGH;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BG;;AACH,OAAM,SAAU,QAAV,CAAmB,MAAnB,EAAiD;EACnD,MAAM,CAAC,GAAG,MAAM,CAAC,CAAD,CAAhB,CADmD,CAEnD;;EACA,IAAI,CAAC,GAAG,MAAM,CAAC,CAAD,CAAN,GAAY,CAApB;EAEA,IAAI,CAAC,GAAG,CAAR,CALmD,CAOnD;;EACA,IAAI,CAAC,GAAG,CAAR,EAAW;IACP,MAAM,IAAI,GAAG,CAAC,CAAd,CADO,CAEP;;IACA,MAAM,QAAQ,GAAG,CAAE,CAAC,GAAG,IAAL,GAAa,IAAd,IAAsB,IAAvC;IACA,OAAO,MAAK;MACR,MAAM,GAAG,GAAG,QAAQ,GAAG,IAAI,GAAG,CAAC,EAA/B;MAEA,OAAO,GAAG,GAAG,CAAN,GAAU,IAAV,GAAiB,GAAxB;IACH,CAJD;EAKH;;EAED,IAAI,CAAC,KAAK,CAAV,EACI,OAAO,CAAC,GAAG,CAAJ,GACD;EACA,MAAM,IAFL,GAGD;EACA,MAAO,CAAC,OAAO,CAAR,GAAY,CAAZ,GAAgB,IAJ7B;;EAMJ,IAAI,CAAC,GAAG,CAAR,EAAW;IACP,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,IAAL,CAAU,CAAC,CAAD,GAAK,CAAf,CAAT;EACH;;EAED,OAAO,MAAM,CAAC,GAAG,CAAC,EAAL,GAAU,CAAvB;AACH","sourceRoot":"https://raw.githubusercontent.com/fb55/nth-check/639fd2a4000b69f82350aad8c34cb43f77e483ba/src/","sourcesContent":["import boolbase from \"boolbase\";\n/**\n * Returns a function that checks if an elements index matches the given rule\n * highly optimized to return the fastest solution.\n *\n * @param parsed A tuple [a, b], as returned by `parse`.\n * @returns A highly optimized function that returns whether an index matches the nth-check.\n * @example\n *\n * ```js\n * const check = nthCheck.compile([2, 3]);\n *\n * check(0); // `false`\n * check(1); // `false`\n * check(2); // `true`\n * check(3); // `false`\n * check(4); // `true`\n * check(5); // `false`\n * check(6); // `true`\n * ```\n */\nexport function compile(parsed) {\n    const a = parsed[0];\n    // Subtract 1 from `b`, to convert from one- to zero-indexed.\n    const b = parsed[1] - 1;\n    /*\n     * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.\n     * Besides, the specification states that no elements are\n     * matched when `a` and `b` are 0.\n     *\n     * `b < 0` here as we subtracted 1 from `b` above.\n     */\n    if (b < 0 && a <= 0)\n        return boolbase.falseFunc;\n    // When `a` is in the range -1..1, it matches any element (so only `b` is checked).\n    if (a === -1)\n        return (index) => index <= b;\n    if (a === 0)\n        return (index) => index === b;\n    // When `b <= 0` and `a === 1`, they match any element.\n    if (a === 1)\n        return b < 0 ? boolbase.trueFunc : (index) => index >= b;\n    /*\n     * Otherwise, modulo can be used to check if there is a match.\n     *\n     * Modulo doesn't care about the sign, so let's use `a`s absolute value.\n     */\n    const absA = Math.abs(a);\n    // Get `b mod a`, + a if this is negative.\n    const bMod = ((b % absA) + absA) % absA;\n    return a > 1\n        ? (index) => index >= b && index % absA === bMod\n        : (index) => index <= b && index % absA === bMod;\n}\n/**\n * Returns a function that produces a monotonously increasing sequence of indices.\n *\n * If the sequence has an end, the returned function will return `null` after\n * the last index in the sequence.\n *\n * @param parsed A tuple [a, b], as returned by `parse`.\n * @returns A function that produces a sequence of indices.\n * @example <caption>Always increasing (2n+3)</caption>\n *\n * ```js\n * const gen = nthCheck.generate([2, 3])\n *\n * gen() // `1`\n * gen() // `3`\n * gen() // `5`\n * gen() // `8`\n * gen() // `11`\n * ```\n *\n * @example <caption>With end value (-2n+10)</caption>\n *\n * ```js\n *\n * const gen = nthCheck.generate([-2, 5]);\n *\n * gen() // 0\n * gen() // 2\n * gen() // 4\n * gen() // null\n * ```\n */\nexport function generate(parsed) {\n    const a = parsed[0];\n    // Subtract 1 from `b`, to convert from one- to zero-indexed.\n    let b = parsed[1] - 1;\n    let n = 0;\n    // Make sure to always return an increasing sequence\n    if (a < 0) {\n        const aPos = -a;\n        // Get `b mod a`\n        const minValue = ((b % aPos) + aPos) % aPos;\n        return () => {\n            const val = minValue + aPos * n++;\n            return val > b ? null : val;\n        };\n    }\n    if (a === 0)\n        return b < 0\n            ? // There are no result — always return `null`\n                () => null\n            : // Return `b` exactly once\n                () => (n++ === 0 ? b : null);\n    if (b < 0) {\n        b += a * Math.ceil(-b / a);\n    }\n    return () => a * n++ + b;\n}\n//# sourceMappingURL=compile.js.map"]},"metadata":{},"sourceType":"module"}