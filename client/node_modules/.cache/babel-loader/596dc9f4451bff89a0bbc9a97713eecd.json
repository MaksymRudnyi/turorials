{"ast":null,"code":"'use strict';\n\nconst Mixin = require('../../utils/mixin');\n\nconst Tokenizer = require('../../tokenizer');\n\nconst PositionTrackingPreprocessorMixin = require('../position-tracking/preprocessor-mixin');\n\nclass LocationInfoTokenizerMixin extends Mixin {\n  constructor(tokenizer) {\n    super(tokenizer);\n    this.tokenizer = tokenizer;\n    this.posTracker = Mixin.install(tokenizer.preprocessor, PositionTrackingPreprocessorMixin);\n    this.currentAttrLocation = null;\n    this.ctLoc = null;\n  }\n\n  _getCurrentLocation() {\n    return {\n      startLine: this.posTracker.line,\n      startCol: this.posTracker.col,\n      startOffset: this.posTracker.offset,\n      endLine: -1,\n      endCol: -1,\n      endOffset: -1\n    };\n  }\n\n  _attachCurrentAttrLocationInfo() {\n    this.currentAttrLocation.endLine = this.posTracker.line;\n    this.currentAttrLocation.endCol = this.posTracker.col;\n    this.currentAttrLocation.endOffset = this.posTracker.offset;\n    const currentToken = this.tokenizer.currentToken;\n    const currentAttr = this.tokenizer.currentAttr;\n\n    if (!currentToken.location.attrs) {\n      currentToken.location.attrs = Object.create(null);\n    }\n\n    currentToken.location.attrs[currentAttr.name] = this.currentAttrLocation;\n  }\n\n  _getOverriddenMethods(mxn, orig) {\n    const methods = {\n      _createStartTagToken() {\n        orig._createStartTagToken.call(this);\n\n        this.currentToken.location = mxn.ctLoc;\n      },\n\n      _createEndTagToken() {\n        orig._createEndTagToken.call(this);\n\n        this.currentToken.location = mxn.ctLoc;\n      },\n\n      _createCommentToken() {\n        orig._createCommentToken.call(this);\n\n        this.currentToken.location = mxn.ctLoc;\n      },\n\n      _createDoctypeToken(initialName) {\n        orig._createDoctypeToken.call(this, initialName);\n\n        this.currentToken.location = mxn.ctLoc;\n      },\n\n      _createCharacterToken(type, ch) {\n        orig._createCharacterToken.call(this, type, ch);\n\n        this.currentCharacterToken.location = mxn.ctLoc;\n      },\n\n      _createEOFToken() {\n        orig._createEOFToken.call(this);\n\n        this.currentToken.location = mxn._getCurrentLocation();\n      },\n\n      _createAttr(attrNameFirstCh) {\n        orig._createAttr.call(this, attrNameFirstCh);\n\n        mxn.currentAttrLocation = mxn._getCurrentLocation();\n      },\n\n      _leaveAttrName(toState) {\n        orig._leaveAttrName.call(this, toState);\n\n        mxn._attachCurrentAttrLocationInfo();\n      },\n\n      _leaveAttrValue(toState) {\n        orig._leaveAttrValue.call(this, toState);\n\n        mxn._attachCurrentAttrLocationInfo();\n      },\n\n      _emitCurrentToken() {\n        const ctLoc = this.currentToken.location; //NOTE: if we have pending character token make it's end location equal to the\n        //current token's start location.\n\n        if (this.currentCharacterToken) {\n          this.currentCharacterToken.location.endLine = ctLoc.startLine;\n          this.currentCharacterToken.location.endCol = ctLoc.startCol;\n          this.currentCharacterToken.location.endOffset = ctLoc.startOffset;\n        }\n\n        if (this.currentToken.type === Tokenizer.EOF_TOKEN) {\n          ctLoc.endLine = ctLoc.startLine;\n          ctLoc.endCol = ctLoc.startCol;\n          ctLoc.endOffset = ctLoc.startOffset;\n        } else {\n          ctLoc.endLine = mxn.posTracker.line;\n          ctLoc.endCol = mxn.posTracker.col + 1;\n          ctLoc.endOffset = mxn.posTracker.offset + 1;\n        }\n\n        orig._emitCurrentToken.call(this);\n      },\n\n      _emitCurrentCharacterToken() {\n        const ctLoc = this.currentCharacterToken && this.currentCharacterToken.location; //NOTE: if we have character token and it's location wasn't set in the _emitCurrentToken(),\n        //then set it's location at the current preprocessor position.\n        //We don't need to increment preprocessor position, since character token\n        //emission is always forced by the start of the next character token here.\n        //So, we already have advanced position.\n\n        if (ctLoc && ctLoc.endOffset === -1) {\n          ctLoc.endLine = mxn.posTracker.line;\n          ctLoc.endCol = mxn.posTracker.col;\n          ctLoc.endOffset = mxn.posTracker.offset;\n        }\n\n        orig._emitCurrentCharacterToken.call(this);\n      }\n\n    }; //NOTE: patch initial states for each mode to obtain token start position\n\n    Object.keys(Tokenizer.MODE).forEach(modeName => {\n      const state = Tokenizer.MODE[modeName];\n\n      methods[state] = function (cp) {\n        mxn.ctLoc = mxn._getCurrentLocation();\n        orig[state].call(this, cp);\n      };\n    });\n    return methods;\n  }\n\n}\n\nmodule.exports = LocationInfoTokenizerMixin;","map":{"version":3,"names":["Mixin","require","Tokenizer","PositionTrackingPreprocessorMixin","LocationInfoTokenizerMixin","constructor","tokenizer","posTracker","install","preprocessor","currentAttrLocation","ctLoc","_getCurrentLocation","startLine","line","startCol","col","startOffset","offset","endLine","endCol","endOffset","_attachCurrentAttrLocationInfo","currentToken","currentAttr","location","attrs","Object","create","name","_getOverriddenMethods","mxn","orig","methods","_createStartTagToken","call","_createEndTagToken","_createCommentToken","_createDoctypeToken","initialName","_createCharacterToken","type","ch","currentCharacterToken","_createEOFToken","_createAttr","attrNameFirstCh","_leaveAttrName","toState","_leaveAttrValue","_emitCurrentToken","EOF_TOKEN","_emitCurrentCharacterToken","keys","MODE","forEach","modeName","state","cp","module","exports"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/parse5/lib/extensions/location-info/tokenizer-mixin.js"],"sourcesContent":["'use strict';\n\nconst Mixin = require('../../utils/mixin');\nconst Tokenizer = require('../../tokenizer');\nconst PositionTrackingPreprocessorMixin = require('../position-tracking/preprocessor-mixin');\n\nclass LocationInfoTokenizerMixin extends Mixin {\n    constructor(tokenizer) {\n        super(tokenizer);\n\n        this.tokenizer = tokenizer;\n        this.posTracker = Mixin.install(tokenizer.preprocessor, PositionTrackingPreprocessorMixin);\n        this.currentAttrLocation = null;\n        this.ctLoc = null;\n    }\n\n    _getCurrentLocation() {\n        return {\n            startLine: this.posTracker.line,\n            startCol: this.posTracker.col,\n            startOffset: this.posTracker.offset,\n            endLine: -1,\n            endCol: -1,\n            endOffset: -1\n        };\n    }\n\n    _attachCurrentAttrLocationInfo() {\n        this.currentAttrLocation.endLine = this.posTracker.line;\n        this.currentAttrLocation.endCol = this.posTracker.col;\n        this.currentAttrLocation.endOffset = this.posTracker.offset;\n\n        const currentToken = this.tokenizer.currentToken;\n        const currentAttr = this.tokenizer.currentAttr;\n\n        if (!currentToken.location.attrs) {\n            currentToken.location.attrs = Object.create(null);\n        }\n\n        currentToken.location.attrs[currentAttr.name] = this.currentAttrLocation;\n    }\n\n    _getOverriddenMethods(mxn, orig) {\n        const methods = {\n            _createStartTagToken() {\n                orig._createStartTagToken.call(this);\n                this.currentToken.location = mxn.ctLoc;\n            },\n\n            _createEndTagToken() {\n                orig._createEndTagToken.call(this);\n                this.currentToken.location = mxn.ctLoc;\n            },\n\n            _createCommentToken() {\n                orig._createCommentToken.call(this);\n                this.currentToken.location = mxn.ctLoc;\n            },\n\n            _createDoctypeToken(initialName) {\n                orig._createDoctypeToken.call(this, initialName);\n                this.currentToken.location = mxn.ctLoc;\n            },\n\n            _createCharacterToken(type, ch) {\n                orig._createCharacterToken.call(this, type, ch);\n                this.currentCharacterToken.location = mxn.ctLoc;\n            },\n\n            _createEOFToken() {\n                orig._createEOFToken.call(this);\n                this.currentToken.location = mxn._getCurrentLocation();\n            },\n\n            _createAttr(attrNameFirstCh) {\n                orig._createAttr.call(this, attrNameFirstCh);\n                mxn.currentAttrLocation = mxn._getCurrentLocation();\n            },\n\n            _leaveAttrName(toState) {\n                orig._leaveAttrName.call(this, toState);\n                mxn._attachCurrentAttrLocationInfo();\n            },\n\n            _leaveAttrValue(toState) {\n                orig._leaveAttrValue.call(this, toState);\n                mxn._attachCurrentAttrLocationInfo();\n            },\n\n            _emitCurrentToken() {\n                const ctLoc = this.currentToken.location;\n\n                //NOTE: if we have pending character token make it's end location equal to the\n                //current token's start location.\n                if (this.currentCharacterToken) {\n                    this.currentCharacterToken.location.endLine = ctLoc.startLine;\n                    this.currentCharacterToken.location.endCol = ctLoc.startCol;\n                    this.currentCharacterToken.location.endOffset = ctLoc.startOffset;\n                }\n\n                if (this.currentToken.type === Tokenizer.EOF_TOKEN) {\n                    ctLoc.endLine = ctLoc.startLine;\n                    ctLoc.endCol = ctLoc.startCol;\n                    ctLoc.endOffset = ctLoc.startOffset;\n                } else {\n                    ctLoc.endLine = mxn.posTracker.line;\n                    ctLoc.endCol = mxn.posTracker.col + 1;\n                    ctLoc.endOffset = mxn.posTracker.offset + 1;\n                }\n\n                orig._emitCurrentToken.call(this);\n            },\n\n            _emitCurrentCharacterToken() {\n                const ctLoc = this.currentCharacterToken && this.currentCharacterToken.location;\n\n                //NOTE: if we have character token and it's location wasn't set in the _emitCurrentToken(),\n                //then set it's location at the current preprocessor position.\n                //We don't need to increment preprocessor position, since character token\n                //emission is always forced by the start of the next character token here.\n                //So, we already have advanced position.\n                if (ctLoc && ctLoc.endOffset === -1) {\n                    ctLoc.endLine = mxn.posTracker.line;\n                    ctLoc.endCol = mxn.posTracker.col;\n                    ctLoc.endOffset = mxn.posTracker.offset;\n                }\n\n                orig._emitCurrentCharacterToken.call(this);\n            }\n        };\n\n        //NOTE: patch initial states for each mode to obtain token start position\n        Object.keys(Tokenizer.MODE).forEach(modeName => {\n            const state = Tokenizer.MODE[modeName];\n\n            methods[state] = function(cp) {\n                mxn.ctLoc = mxn._getCurrentLocation();\n                orig[state].call(this, cp);\n            };\n        });\n\n        return methods;\n    }\n}\n\nmodule.exports = LocationInfoTokenizerMixin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}