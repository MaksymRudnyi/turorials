{"ast":null,"code":"/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../types.js').Handle} Handle\n */\nimport { patternCompile } from '../util/pattern-compile.js';\ninlineCode.peek = inlineCodePeek;\n/**\n * @type {Handle}\n * @param {InlineCode} node\n */\n\nexport function inlineCode(node, _, context) {\n  let value = node.value || '';\n  let sequence = '`';\n  let index = -1; // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`';\n  } // If this is not just spaces or eols (tabs don’t count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n\n\n  if (/[^ \\r\\n]/.test(value) && (/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value) || /^`|`$/.test(value))) {\n    value = ' ' + value + ' ';\n  } // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We can’t escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n\n\n  while (++index < context.unsafe.length) {\n    const pattern = context.unsafe[index];\n    const expression = patternCompile(pattern);\n    /** @type {RegExpExecArray|null} */\n\n    let match; // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n\n    if (!pattern.atBreak) continue;\n\n    while (match = expression.exec(value)) {\n      let position = match.index; // Support CRLF (patterns only look for one of the characters).\n\n      if (value.charCodeAt(position) === 10\n      /* `\\n` */\n      && value.charCodeAt(position - 1) === 13\n      /* `\\r` */\n      ) {\n        position--;\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1);\n    }\n  }\n\n  return sequence + value + sequence;\n}\n/**\n * @type {Handle}\n */\n\nfunction inlineCodePeek() {\n  return '`';\n}","map":{"version":3,"names":["patternCompile","inlineCode","peek","inlineCodePeek","node","_","context","value","sequence","index","RegExp","test","unsafe","length","pattern","expression","match","atBreak","exec","position","charCodeAt","slice"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/mdast-util-to-markdown/lib/handle/inline-code.js"],"sourcesContent":["/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../types.js').Handle} Handle\n */\n\nimport {patternCompile} from '../util/pattern-compile.js'\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @type {Handle}\n * @param {InlineCode} node\n */\nexport function inlineCode(node, _, context) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs don’t count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We can’t escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < context.unsafe.length) {\n    const pattern = context.unsafe[index]\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray|null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @type {Handle}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,SAAQA,cAAR,QAA6B,4BAA7B;AAEAC,UAAU,CAACC,IAAX,GAAkBC,cAAlB;AAEA;AACA;AACA;AACA;;AACA,OAAO,SAASF,UAAT,CAAoBG,IAApB,EAA0BC,CAA1B,EAA6BC,OAA7B,EAAsC;EAC3C,IAAIC,KAAK,GAAGH,IAAI,CAACG,KAAL,IAAc,EAA1B;EACA,IAAIC,QAAQ,GAAG,GAAf;EACA,IAAIC,KAAK,GAAG,CAAC,CAAb,CAH2C,CAK3C;EACA;EACA;;EACA,OAAO,IAAIC,MAAJ,CAAW,aAAaF,QAAb,GAAwB,UAAnC,EAA+CG,IAA/C,CAAoDJ,KAApD,CAAP,EAAmE;IACjEC,QAAQ,IAAI,GAAZ;EACD,CAV0C,CAY3C;EACA;;;EACA,IACE,WAAWG,IAAX,CAAgBJ,KAAhB,MACE,WAAWI,IAAX,CAAgBJ,KAAhB,KAA0B,WAAWI,IAAX,CAAgBJ,KAAhB,CAA3B,IAAsD,QAAQI,IAAR,CAAaJ,KAAb,CADvD,CADF,EAGE;IACAA,KAAK,GAAG,MAAMA,KAAN,GAAc,GAAtB;EACD,CAnB0C,CAqB3C;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,OAAO,EAAEE,KAAF,GAAUH,OAAO,CAACM,MAAR,CAAeC,MAAhC,EAAwC;IACtC,MAAMC,OAAO,GAAGR,OAAO,CAACM,MAAR,CAAeH,KAAf,CAAhB;IACA,MAAMM,UAAU,GAAGf,cAAc,CAACc,OAAD,CAAjC;IACA;;IACA,IAAIE,KAAJ,CAJsC,CAMtC;IACA;IACA;;IACA,IAAI,CAACF,OAAO,CAACG,OAAb,EAAsB;;IAEtB,OAAQD,KAAK,GAAGD,UAAU,CAACG,IAAX,CAAgBX,KAAhB,CAAhB,EAAyC;MACvC,IAAIY,QAAQ,GAAGH,KAAK,CAACP,KAArB,CADuC,CAGvC;;MACA,IACEF,KAAK,CAACa,UAAN,CAAiBD,QAAjB,MAA+B;MAAG;MAAlC,GACAZ,KAAK,CAACa,UAAN,CAAiBD,QAAQ,GAAG,CAA5B,MAAmC;MAAG;MAFxC,EAGE;QACAA,QAAQ;MACT;;MAEDZ,KAAK,GAAGA,KAAK,CAACc,KAAN,CAAY,CAAZ,EAAeF,QAAf,IAA2B,GAA3B,GAAiCZ,KAAK,CAACc,KAAN,CAAYL,KAAK,CAACP,KAAN,GAAc,CAA1B,CAAzC;IACD;EACF;;EAED,OAAOD,QAAQ,GAAGD,KAAX,GAAmBC,QAA1B;AACD;AAED;AACA;AACA;;AACA,SAASL,cAAT,GAA0B;EACxB,OAAO,GAAP;AACD"},"metadata":{},"sourceType":"module"}