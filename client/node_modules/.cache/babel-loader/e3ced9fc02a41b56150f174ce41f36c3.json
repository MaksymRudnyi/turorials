{"ast":null,"code":"function mkVerilog(parserConfig) {\n  var statementIndentUnit = parserConfig.statementIndentUnit,\n      dontAlignCalls = parserConfig.dontAlignCalls,\n      noIndentKeywords = parserConfig.noIndentKeywords || [],\n      multiLineStrings = parserConfig.multiLineStrings,\n      hooks = parserConfig.hooks || {};\n\n  function words(str) {\n    var obj = {},\n        words = str.split(\" \");\n\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n\n    return obj;\n  }\n  /**\n   * Keywords from IEEE 1800-2012\n   */\n\n\n  var keywords = words(\"accept_on alias always always_comb always_ff always_latch and assert assign assume automatic before begin bind \" + \"bins binsof bit break buf bufif0 bufif1 byte case casex casez cell chandle checker class clocking cmos config \" + \"const constraint context continue cover covergroup coverpoint cross deassign default defparam design disable \" + \"dist do edge else end endcase endchecker endclass endclocking endconfig endfunction endgenerate endgroup \" + \"endinterface endmodule endpackage endprimitive endprogram endproperty endspecify endsequence endtable endtask \" + \"enum event eventually expect export extends extern final first_match for force foreach forever fork forkjoin \" + \"function generate genvar global highz0 highz1 if iff ifnone ignore_bins illegal_bins implements implies import \" + \"incdir include initial inout input inside instance int integer interconnect interface intersect join join_any \" + \"join_none large let liblist library local localparam logic longint macromodule matches medium modport module \" + \"nand negedge nettype new nexttime nmos nor noshowcancelled not notif0 notif1 null or output package packed \" + \"parameter pmos posedge primitive priority program property protected pull0 pull1 pulldown pullup \" + \"pulsestyle_ondetect pulsestyle_onevent pure rand randc randcase randsequence rcmos real realtime ref reg \" + \"reject_on release repeat restrict return rnmos rpmos rtran rtranif0 rtranif1 s_always s_eventually s_nexttime \" + \"s_until s_until_with scalared sequence shortint shortreal showcancelled signed small soft solve specify \" + \"specparam static string strong strong0 strong1 struct super supply0 supply1 sync_accept_on sync_reject_on \" + \"table tagged task this throughout time timeprecision timeunit tran tranif0 tranif1 tri tri0 tri1 triand trior \" + \"trireg type typedef union unique unique0 unsigned until until_with untyped use uwire var vectored virtual void \" + \"wait wait_order wand weak weak0 weak1 while wildcard wire with within wor xnor xor\");\n  /** Operators from IEEE 1800-2012\n      unary_operator ::=\n      + | - | ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n      binary_operator ::=\n      + | - | * | / | % | == | != | === | !== | ==? | !=? | && | || | **\n      | < | <= | > | >= | & | | | ^ | ^~ | ~^ | >> | << | >>> | <<<\n      | -> | <->\n      inc_or_dec_operator ::= ++ | --\n      unary_module_path_operator ::=\n      ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n      binary_module_path_operator ::=\n      == | != | && | || | & | | | ^ | ^~ | ~^\n  */\n\n  var isOperatorChar = /[\\+\\-\\*\\/!~&|^%=?:]/;\n  var isBracketChar = /[\\[\\]{}()]/;\n  var unsignedNumber = /\\d[0-9_]*/;\n  var decimalLiteral = /\\d*\\s*'s?d\\s*\\d[0-9_]*/i;\n  var binaryLiteral = /\\d*\\s*'s?b\\s*[xz01][xz01_]*/i;\n  var octLiteral = /\\d*\\s*'s?o\\s*[xz0-7][xz0-7_]*/i;\n  var hexLiteral = /\\d*\\s*'s?h\\s*[0-9a-fxz?][0-9a-fxz?_]*/i;\n  var realLiteral = /(\\d[\\d_]*(\\.\\d[\\d_]*)?E-?[\\d_]+)|(\\d[\\d_]*\\.\\d[\\d_]*)/i;\n  var closingBracketOrWord = /^((\\w+)|[)}\\]])/;\n  var closingBracket = /[)}\\]]/;\n  var curPunc;\n  var curKeyword; // Block openings which are closed by a matching keyword in the form of (\"end\" + keyword)\n  // E.g. \"task\" => \"endtask\"\n\n  var blockKeywords = words(\"case checker class clocking config function generate interface module package \" + \"primitive program property specify sequence table task\"); // Opening/closing pairs\n\n  var openClose = {};\n\n  for (var keyword in blockKeywords) {\n    openClose[keyword] = \"end\" + keyword;\n  }\n\n  openClose[\"begin\"] = \"end\";\n  openClose[\"casex\"] = \"endcase\";\n  openClose[\"casez\"] = \"endcase\";\n  openClose[\"do\"] = \"while\";\n  openClose[\"fork\"] = \"join;join_any;join_none\";\n  openClose[\"covergroup\"] = \"endgroup\";\n\n  for (var i in noIndentKeywords) {\n    var keyword = noIndentKeywords[i];\n\n    if (openClose[keyword]) {\n      openClose[keyword] = undefined;\n    }\n  } // Keywords which open statements that are ended with a semi-colon\n\n\n  var statementKeywords = words(\"always always_comb always_ff always_latch assert assign assume else export for foreach forever if import initial repeat while\");\n\n  function tokenBase(stream, state) {\n    var ch = stream.peek(),\n        style;\n    if (hooks[ch] && (style = hooks[ch](stream, state)) != false) return style;\n    if (hooks.tokenBase && (style = hooks.tokenBase(stream, state)) != false) return style;\n\n    if (/[,;:\\.]/.test(ch)) {\n      curPunc = stream.next();\n      return null;\n    }\n\n    if (isBracketChar.test(ch)) {\n      curPunc = stream.next();\n      return \"bracket\";\n    } // Macros (tick-defines)\n\n\n    if (ch == '`') {\n      stream.next();\n\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        return \"def\";\n      } else {\n        return null;\n      }\n    } // System calls\n\n\n    if (ch == '$') {\n      stream.next();\n\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        return \"meta\";\n      } else {\n        return null;\n      }\n    } // Time literals\n\n\n    if (ch == '#') {\n      stream.next();\n      stream.eatWhile(/[\\d_.]/);\n      return \"def\";\n    } // Strings\n\n\n    if (ch == '\"') {\n      stream.next();\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } // Comments\n\n\n    if (ch == \"/\") {\n      stream.next();\n\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      }\n\n      if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n\n      stream.backUp(1);\n    } // Numeric literals\n\n\n    if (stream.match(realLiteral) || stream.match(decimalLiteral) || stream.match(binaryLiteral) || stream.match(octLiteral) || stream.match(hexLiteral) || stream.match(unsignedNumber) || stream.match(realLiteral)) {\n      return \"number\";\n    } // Operators\n\n\n    if (stream.eatWhile(isOperatorChar)) {\n      return \"meta\";\n    } // Keywords / plain variables\n\n\n    if (stream.eatWhile(/[\\w\\$_]/)) {\n      var cur = stream.current();\n\n      if (keywords[cur]) {\n        if (openClose[cur]) {\n          curPunc = \"newblock\";\n        }\n\n        if (statementKeywords[cur]) {\n          curPunc = \"newstatement\";\n        }\n\n        curKeyword = cur;\n        return \"keyword\";\n      }\n\n      return \"variable\";\n    }\n\n    stream.next();\n    return null;\n  }\n\n  function tokenString(quote) {\n    return function (stream, state) {\n      var escaped = false,\n          next,\n          end = false;\n\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) {\n          end = true;\n          break;\n        }\n\n        escaped = !escaped && next == \"\\\\\";\n      }\n\n      if (end || !(escaped || multiLineStrings)) state.tokenize = tokenBase;\n      return \"string\";\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false,\n        ch;\n\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n\n      maybeEnd = ch == \"*\";\n    }\n\n    return \"comment\";\n  }\n\n  function Context(indented, column, type, align, prev) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.align = align;\n    this.prev = prev;\n  }\n\n  function pushContext(state, col, type) {\n    var indent = state.indented;\n    var c = new Context(indent, col, type, null, state.context);\n    return state.context = c;\n  }\n\n  function popContext(state) {\n    var t = state.context.type;\n\n    if (t == \")\" || t == \"]\" || t == \"}\") {\n      state.indented = state.context.indented;\n    }\n\n    return state.context = state.context.prev;\n  }\n\n  function isClosing(text, contextClosing) {\n    if (text == contextClosing) {\n      return true;\n    } else {\n      // contextClosing may be multiple keywords separated by ;\n      var closingKeywords = contextClosing.split(\";\");\n\n      for (var i in closingKeywords) {\n        if (text == closingKeywords[i]) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }\n\n  function buildElectricInputRegEx() {\n    // Reindentation should occur on any bracket char: {}()[]\n    // or on a match of any of the block closing keywords, at\n    // the end of a line\n    var allClosings = [];\n\n    for (var i in openClose) {\n      if (openClose[i]) {\n        var closings = openClose[i].split(\";\");\n\n        for (var j in closings) {\n          allClosings.push(closings[j]);\n        }\n      }\n    }\n\n    var re = new RegExp(\"[{}()\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n    return re;\n  } // Interface\n\n\n  return {\n    startState: function (indentUnit) {\n      var state = {\n        tokenize: null,\n        context: new Context(-indentUnit, 0, \"top\", false),\n        indented: 0,\n        startOfLine: true\n      };\n      if (hooks.startState) hooks.startState(state);\n      return state;\n    },\n    token: function (stream, state) {\n      var ctx = state.context;\n\n      if (stream.sol()) {\n        if (ctx.align == null) ctx.align = false;\n        state.indented = stream.indentation();\n        state.startOfLine = true;\n      }\n\n      if (hooks.token) {\n        // Call hook, with an optional return value of a style to override verilog styling.\n        var style = hooks.token(stream, state);\n\n        if (style !== undefined) {\n          return style;\n        }\n      }\n\n      if (stream.eatSpace()) return null;\n      curPunc = null;\n      curKeyword = null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style == \"comment\" || style == \"meta\" || style == \"variable\") return style;\n      if (ctx.align == null) ctx.align = true;\n\n      if (curPunc == ctx.type) {\n        popContext(state);\n      } else if (curPunc == \";\" && ctx.type == \"statement\" || ctx.type && isClosing(curKeyword, ctx.type)) {\n        ctx = popContext(state);\n\n        while (ctx && ctx.type == \"statement\") ctx = popContext(state);\n      } else if (curPunc == \"{\") {\n        pushContext(state, stream.column(), \"}\");\n      } else if (curPunc == \"[\") {\n        pushContext(state, stream.column(), \"]\");\n      } else if (curPunc == \"(\") {\n        pushContext(state, stream.column(), \")\");\n      } else if (ctx && ctx.type == \"endcase\" && curPunc == \":\") {\n        pushContext(state, stream.column(), \"statement\");\n      } else if (curPunc == \"newstatement\") {\n        pushContext(state, stream.column(), \"statement\");\n      } else if (curPunc == \"newblock\") {\n        if (curKeyword == \"function\" && ctx && (ctx.type == \"statement\" || ctx.type == \"endgroup\")) {// The 'function' keyword can appear in some other contexts where it actually does not\n          // indicate a function (import/export DPI and covergroup definitions).\n          // Do nothing in this case\n        } else if (curKeyword == \"task\" && ctx && ctx.type == \"statement\") {// Same thing for task\n        } else {\n          var close = openClose[curKeyword];\n          pushContext(state, stream.column(), close);\n        }\n      }\n\n      state.startOfLine = false;\n      return style;\n    },\n    indent: function (state, textAfter, cx) {\n      if (state.tokenize != tokenBase && state.tokenize != null) return null;\n\n      if (hooks.indent) {\n        var fromHook = hooks.indent(state);\n        if (fromHook >= 0) return fromHook;\n      }\n\n      var ctx = state.context,\n          firstChar = textAfter && textAfter.charAt(0);\n      if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n      var closing = false;\n      var possibleClosing = textAfter.match(closingBracketOrWord);\n      if (possibleClosing) closing = isClosing(possibleClosing[0], ctx.type);\n      if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit || cx.unit);else if (closingBracket.test(ctx.type) && ctx.align && !dontAlignCalls) return ctx.column + (closing ? 0 : 1);else if (ctx.type == \")\" && !closing) return ctx.indented + (statementIndentUnit || cx.unit);else return ctx.indented + (closing ? 0 : cx.unit);\n    },\n    languageData: {\n      indentOnInput: buildElectricInputRegEx(),\n      commentTokens: {\n        line: \"//\",\n        block: {\n          open: \"/*\",\n          close: \"*/\"\n        }\n      }\n    }\n  };\n}\n\n;\nexport const verilog = mkVerilog({}); // TL-Verilog mode.\n// See tl-x.org for language spec.\n// See the mode in action at makerchip.com.\n// Contact: steve.hoover@redwoodeda.com\n// TLV Identifier prefixes.\n// Note that sign is not treated separately, so \"+/-\" versions of numeric identifiers\n// are included.\n\nvar tlvIdentifierStyle = {\n  \"|\": \"link\",\n  \">\": \"property\",\n  // Should condition this off for > TLV 1c.\n  \"$\": \"variable\",\n  \"$$\": \"variable\",\n  \"?$\": \"qualifier\",\n  \"?*\": \"qualifier\",\n  \"-\": \"contentSeparator\",\n  \"/\": \"property\",\n  \"/-\": \"property\",\n  \"@\": \"variableName.special\",\n  \"@-\": \"variableName.special\",\n  \"@++\": \"variableName.special\",\n  \"@+=\": \"variableName.special\",\n  \"@+=-\": \"variableName.special\",\n  \"@--\": \"variableName.special\",\n  \"@-=\": \"variableName.special\",\n  \"%+\": \"tag\",\n  \"%-\": \"tag\",\n  \"%\": \"tag\",\n  \">>\": \"tag\",\n  \"<<\": \"tag\",\n  \"<>\": \"tag\",\n  \"#\": \"tag\",\n  // Need to choose a style for this.\n  \"^\": \"attribute\",\n  \"^^\": \"attribute\",\n  \"^!\": \"attribute\",\n  \"*\": \"variable\",\n  \"**\": \"variable\",\n  \"\\\\\": \"keyword\",\n  \"\\\"\": \"comment\"\n}; // Lines starting with these characters define scope (result in indentation).\n\nvar tlvScopePrefixChars = {\n  \"/\": \"beh-hier\",\n  \">\": \"beh-hier\",\n  \"-\": \"phys-hier\",\n  \"|\": \"pipe\",\n  \"?\": \"when\",\n  \"@\": \"stage\",\n  \"\\\\\": \"keyword\"\n};\nvar tlvIndentUnit = 3;\nvar tlvTrackStatements = false;\nvar tlvIdentMatch = /^([~!@#\\$%\\^&\\*-\\+=\\?\\/\\\\\\|'\"<>]+)([\\d\\w_]*)/; // Matches an identifier.\n// Note that ':' is excluded, because of it's use in [:].\n\nvar tlvLineIndentationMatch = /^[! ] */;\nvar tlvCommentMatch = /^\\/[\\/\\*]/;\nexport const tlv = mkVerilog({\n  hooks: {\n    electricInput: false,\n    // Return undefined for verilog tokenizing, or style for TLV token (null not used).\n    // Standard CM styles are used for most formatting, but some TL-Verilog-specific highlighting\n    // can be enabled with the definition of cm-tlv-* styles, including highlighting for:\n    //   - M4 tokens\n    //   - TLV scope indentation\n    //   - Statement delimitation (enabled by tlvTrackStatements)\n    token: function (stream, state) {\n      var style = undefined;\n      var match; // Return value of pattern matches.\n      // Set highlighting mode based on code region (TLV or SV).\n\n      if (stream.sol() && !state.tlvInBlockComment) {\n        // Process region.\n        if (stream.peek() == '\\\\') {\n          style = \"def\";\n          stream.skipToEnd();\n\n          if (stream.string.match(/\\\\SV/)) {\n            state.tlvCodeActive = false;\n          } else if (stream.string.match(/\\\\TLV/)) {\n            state.tlvCodeActive = true;\n          }\n        } // Correct indentation in the face of a line prefix char.\n\n\n        if (state.tlvCodeActive && stream.pos == 0 && state.indented == 0 && (match = stream.match(tlvLineIndentationMatch, false))) {\n          state.indented = match[0].length;\n        } // Compute indentation state:\n        //   o Auto indentation on next line\n        //   o Indentation scope styles\n\n\n        var indented = state.indented;\n        var depth = indented / tlvIndentUnit;\n\n        if (depth <= state.tlvIndentationStyle.length) {\n          // not deeper than current scope\n          var blankline = stream.string.length == indented;\n          var chPos = depth * tlvIndentUnit;\n\n          if (chPos < stream.string.length) {\n            var bodyString = stream.string.slice(chPos);\n            var ch = bodyString[0];\n\n            if (tlvScopePrefixChars[ch] && (match = bodyString.match(tlvIdentMatch)) && tlvIdentifierStyle[match[1]]) {\n              // This line begins scope.\n              // Next line gets indented one level.\n              indented += tlvIndentUnit; // Style the next level of indentation (except non-region keyword identifiers,\n              //   which are statements themselves)\n\n              if (!(ch == \"\\\\\" && chPos > 0)) {\n                state.tlvIndentationStyle[depth] = tlvScopePrefixChars[ch];\n\n                if (tlvTrackStatements) {\n                  state.statementComment = false;\n                }\n\n                depth++;\n              }\n            }\n          } // Clear out deeper indentation levels unless line is blank.\n\n\n          if (!blankline) {\n            while (state.tlvIndentationStyle.length > depth) {\n              state.tlvIndentationStyle.pop();\n            }\n          }\n        } // Set next level of indentation.\n\n\n        state.tlvNextIndent = indented;\n      }\n\n      if (state.tlvCodeActive) {\n        // Highlight as TLV.\n        var beginStatement = false;\n\n        if (tlvTrackStatements) {\n          // This starts a statement if the position is at the scope level\n          // and we're not within a statement leading comment.\n          beginStatement = stream.peek() != \" \" && // not a space\n          style === undefined && // not a region identifier\n          !state.tlvInBlockComment && // not in block comment\n          //!stream.match(tlvCommentMatch, false) && // not comment start\n          stream.column() == state.tlvIndentationStyle.length * tlvIndentUnit; // at scope level\n\n          if (beginStatement) {\n            if (state.statementComment) {\n              // statement already started by comment\n              beginStatement = false;\n            }\n\n            state.statementComment = stream.match(tlvCommentMatch, false); // comment start\n          }\n        }\n\n        var match;\n\n        if (style !== undefined) {} else if (state.tlvInBlockComment) {\n          // In a block comment.\n          if (stream.match(/^.*?\\*\\//)) {\n            // Exit block comment.\n            state.tlvInBlockComment = false;\n\n            if (tlvTrackStatements && !stream.eol()) {\n              // Anything after comment is assumed to be real statement content.\n              state.statementComment = false;\n            }\n          } else {\n            stream.skipToEnd();\n          }\n\n          style = \"comment\";\n        } else if ((match = stream.match(tlvCommentMatch)) && !state.tlvInBlockComment) {\n          // Start comment.\n          if (match[0] == \"//\") {\n            // Line comment.\n            stream.skipToEnd();\n          } else {\n            // Block comment.\n            state.tlvInBlockComment = true;\n          }\n\n          style = \"comment\";\n        } else if (match = stream.match(tlvIdentMatch)) {\n          // looks like an identifier (or identifier prefix)\n          var prefix = match[1];\n          var mnemonic = match[2];\n\n          if ( // is identifier prefix\n          tlvIdentifierStyle.hasOwnProperty(prefix) && ( // has mnemonic or we're at the end of the line (maybe it hasn't been typed yet)\n          mnemonic.length > 0 || stream.eol())) {\n            style = tlvIdentifierStyle[prefix];\n          } else {\n            // Just swallow one character and try again.\n            // This enables subsequent identifier match with preceding symbol character, which\n            //   is legal within a statement.  (Eg, !$reset).  It also enables detection of\n            //   comment start with preceding symbols.\n            stream.backUp(stream.current().length - 1);\n          }\n        } else if (stream.match(/^\\t+/)) {\n          // Highlight tabs, which are illegal.\n          style = \"invalid\";\n        } else if (stream.match(/^[\\[\\]{}\\(\\);\\:]+/)) {\n          // [:], (), {}, ;.\n          style = \"meta\";\n        } else if (match = stream.match(/^[mM]4([\\+_])?[\\w\\d_]*/)) {\n          // m4 pre proc\n          style = match[1] == \"+\" ? \"keyword.special\" : \"keyword\";\n        } else if (stream.match(/^ +/)) {\n          // Skip over spaces.\n          if (stream.eol()) {\n            // Trailing spaces.\n            style = \"error\";\n          }\n        } else if (stream.match(/^[\\w\\d_]+/)) {\n          // alpha-numeric token.\n          style = \"number\";\n        } else {\n          // Eat the next char w/ no formatting.\n          stream.next();\n        }\n      } else {\n        if (stream.match(/^[mM]4([\\w\\d_]*)/)) {\n          // m4 pre proc\n          style = \"keyword\";\n        }\n      }\n\n      return style;\n    },\n    indent: function (state) {\n      return state.tlvCodeActive == true ? state.tlvNextIndent : -1;\n    },\n    startState: function (state) {\n      state.tlvIndentationStyle = []; // Styles to use for each level of indentation.\n\n      state.tlvCodeActive = true; // True when we're in a TLV region (and at beginning of file).\n\n      state.tlvNextIndent = -1; // The number of spaces to autoindent the next line if tlvCodeActive.\n\n      state.tlvInBlockComment = false; // True inside /**/ comment.\n\n      if (tlvTrackStatements) {\n        state.statementComment = false; // True inside a statement's header comment.\n      }\n    }\n  }\n});","map":{"version":3,"names":["mkVerilog","parserConfig","statementIndentUnit","dontAlignCalls","noIndentKeywords","multiLineStrings","hooks","words","str","obj","split","i","length","keywords","isOperatorChar","isBracketChar","unsignedNumber","decimalLiteral","binaryLiteral","octLiteral","hexLiteral","realLiteral","closingBracketOrWord","closingBracket","curPunc","curKeyword","blockKeywords","openClose","keyword","undefined","statementKeywords","tokenBase","stream","state","ch","peek","style","test","next","eatWhile","tokenize","tokenString","eat","tokenComment","skipToEnd","backUp","match","cur","current","quote","escaped","end","maybeEnd","Context","indented","column","type","align","prev","pushContext","col","indent","c","context","popContext","t","isClosing","text","contextClosing","closingKeywords","buildElectricInputRegEx","allClosings","closings","j","push","re","RegExp","join","startState","indentUnit","startOfLine","token","ctx","sol","indentation","eatSpace","close","textAfter","cx","fromHook","firstChar","charAt","closing","possibleClosing","unit","languageData","indentOnInput","commentTokens","line","block","open","verilog","tlvIdentifierStyle","tlvScopePrefixChars","tlvIndentUnit","tlvTrackStatements","tlvIdentMatch","tlvLineIndentationMatch","tlvCommentMatch","tlv","electricInput","tlvInBlockComment","string","tlvCodeActive","pos","depth","tlvIndentationStyle","blankline","chPos","bodyString","slice","statementComment","pop","tlvNextIndent","beginStatement","eol","prefix","mnemonic","hasOwnProperty"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/@codemirror/legacy-modes/mode/verilog.js"],"sourcesContent":["function mkVerilog(parserConfig) {\n\n  var statementIndentUnit = parserConfig.statementIndentUnit,\n      dontAlignCalls = parserConfig.dontAlignCalls,\n      noIndentKeywords = parserConfig.noIndentKeywords || [],\n      multiLineStrings = parserConfig.multiLineStrings,\n      hooks = parserConfig.hooks || {};\n\n  function words(str) {\n    var obj = {}, words = str.split(\" \");\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n    return obj;\n  }\n\n  /**\n   * Keywords from IEEE 1800-2012\n   */\n  var keywords = words(\n    \"accept_on alias always always_comb always_ff always_latch and assert assign assume automatic before begin bind \" +\n      \"bins binsof bit break buf bufif0 bufif1 byte case casex casez cell chandle checker class clocking cmos config \" +\n      \"const constraint context continue cover covergroup coverpoint cross deassign default defparam design disable \" +\n      \"dist do edge else end endcase endchecker endclass endclocking endconfig endfunction endgenerate endgroup \" +\n      \"endinterface endmodule endpackage endprimitive endprogram endproperty endspecify endsequence endtable endtask \" +\n      \"enum event eventually expect export extends extern final first_match for force foreach forever fork forkjoin \" +\n      \"function generate genvar global highz0 highz1 if iff ifnone ignore_bins illegal_bins implements implies import \" +\n      \"incdir include initial inout input inside instance int integer interconnect interface intersect join join_any \" +\n      \"join_none large let liblist library local localparam logic longint macromodule matches medium modport module \" +\n      \"nand negedge nettype new nexttime nmos nor noshowcancelled not notif0 notif1 null or output package packed \" +\n      \"parameter pmos posedge primitive priority program property protected pull0 pull1 pulldown pullup \" +\n      \"pulsestyle_ondetect pulsestyle_onevent pure rand randc randcase randsequence rcmos real realtime ref reg \" +\n      \"reject_on release repeat restrict return rnmos rpmos rtran rtranif0 rtranif1 s_always s_eventually s_nexttime \" +\n      \"s_until s_until_with scalared sequence shortint shortreal showcancelled signed small soft solve specify \" +\n      \"specparam static string strong strong0 strong1 struct super supply0 supply1 sync_accept_on sync_reject_on \" +\n      \"table tagged task this throughout time timeprecision timeunit tran tranif0 tranif1 tri tri0 tri1 triand trior \" +\n      \"trireg type typedef union unique unique0 unsigned until until_with untyped use uwire var vectored virtual void \" +\n      \"wait wait_order wand weak weak0 weak1 while wildcard wire with within wor xnor xor\");\n\n  /** Operators from IEEE 1800-2012\n      unary_operator ::=\n      + | - | ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n      binary_operator ::=\n      + | - | * | / | % | == | != | === | !== | ==? | !=? | && | || | **\n      | < | <= | > | >= | & | | | ^ | ^~ | ~^ | >> | << | >>> | <<<\n      | -> | <->\n      inc_or_dec_operator ::= ++ | --\n      unary_module_path_operator ::=\n      ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n      binary_module_path_operator ::=\n      == | != | && | || | & | | | ^ | ^~ | ~^\n  */\n  var isOperatorChar = /[\\+\\-\\*\\/!~&|^%=?:]/;\n  var isBracketChar = /[\\[\\]{}()]/;\n\n  var unsignedNumber = /\\d[0-9_]*/;\n  var decimalLiteral = /\\d*\\s*'s?d\\s*\\d[0-9_]*/i;\n  var binaryLiteral = /\\d*\\s*'s?b\\s*[xz01][xz01_]*/i;\n  var octLiteral = /\\d*\\s*'s?o\\s*[xz0-7][xz0-7_]*/i;\n  var hexLiteral = /\\d*\\s*'s?h\\s*[0-9a-fxz?][0-9a-fxz?_]*/i;\n  var realLiteral = /(\\d[\\d_]*(\\.\\d[\\d_]*)?E-?[\\d_]+)|(\\d[\\d_]*\\.\\d[\\d_]*)/i;\n\n  var closingBracketOrWord = /^((\\w+)|[)}\\]])/;\n  var closingBracket = /[)}\\]]/;\n\n  var curPunc;\n  var curKeyword;\n\n  // Block openings which are closed by a matching keyword in the form of (\"end\" + keyword)\n  // E.g. \"task\" => \"endtask\"\n  var blockKeywords = words(\n    \"case checker class clocking config function generate interface module package \" +\n      \"primitive program property specify sequence table task\"\n  );\n\n  // Opening/closing pairs\n  var openClose = {};\n  for (var keyword in blockKeywords) {\n    openClose[keyword] = \"end\" + keyword;\n  }\n  openClose[\"begin\"] = \"end\";\n  openClose[\"casex\"] = \"endcase\";\n  openClose[\"casez\"] = \"endcase\";\n  openClose[\"do\"   ] = \"while\";\n  openClose[\"fork\" ] = \"join;join_any;join_none\";\n  openClose[\"covergroup\"] = \"endgroup\";\n\n  for (var i in noIndentKeywords) {\n    var keyword = noIndentKeywords[i];\n    if (openClose[keyword]) {\n      openClose[keyword] = undefined;\n    }\n  }\n\n  // Keywords which open statements that are ended with a semi-colon\n  var statementKeywords = words(\"always always_comb always_ff always_latch assert assign assume else export for foreach forever if import initial repeat while\");\n\n  function tokenBase(stream, state) {\n    var ch = stream.peek(), style;\n    if (hooks[ch] && (style = hooks[ch](stream, state)) != false) return style;\n    if (hooks.tokenBase && (style = hooks.tokenBase(stream, state)) != false)\n      return style;\n\n    if (/[,;:\\.]/.test(ch)) {\n      curPunc = stream.next();\n      return null;\n    }\n    if (isBracketChar.test(ch)) {\n      curPunc = stream.next();\n      return \"bracket\";\n    }\n    // Macros (tick-defines)\n    if (ch == '`') {\n      stream.next();\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        return \"def\";\n      } else {\n        return null;\n      }\n    }\n    // System calls\n    if (ch == '$') {\n      stream.next();\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        return \"meta\";\n      } else {\n        return null;\n      }\n    }\n    // Time literals\n    if (ch == '#') {\n      stream.next();\n      stream.eatWhile(/[\\d_.]/);\n      return \"def\";\n    }\n    // Strings\n    if (ch == '\"') {\n      stream.next();\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    }\n    // Comments\n    if (ch == \"/\") {\n      stream.next();\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      }\n      if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n      stream.backUp(1);\n    }\n\n    // Numeric literals\n    if (stream.match(realLiteral) ||\n        stream.match(decimalLiteral) ||\n        stream.match(binaryLiteral) ||\n        stream.match(octLiteral) ||\n        stream.match(hexLiteral) ||\n        stream.match(unsignedNumber) ||\n        stream.match(realLiteral)) {\n      return \"number\";\n    }\n\n    // Operators\n    if (stream.eatWhile(isOperatorChar)) {\n      return \"meta\";\n    }\n\n    // Keywords / plain variables\n    if (stream.eatWhile(/[\\w\\$_]/)) {\n      var cur = stream.current();\n      if (keywords[cur]) {\n        if (openClose[cur]) {\n          curPunc = \"newblock\";\n        }\n        if (statementKeywords[cur]) {\n          curPunc = \"newstatement\";\n        }\n        curKeyword = cur;\n        return \"keyword\";\n      }\n      return \"variable\";\n    }\n\n    stream.next();\n    return null;\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next, end = false;\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) {end = true; break;}\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (end || !(escaped || multiLineStrings))\n        state.tokenize = tokenBase;\n      return \"string\";\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return \"comment\";\n  }\n\n  function Context(indented, column, type, align, prev) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.align = align;\n    this.prev = prev;\n  }\n  function pushContext(state, col, type) {\n    var indent = state.indented;\n    var c = new Context(indent, col, type, null, state.context);\n    return state.context = c;\n  }\n  function popContext(state) {\n    var t = state.context.type;\n    if (t == \")\" || t == \"]\" || t == \"}\") {\n      state.indented = state.context.indented;\n    }\n    return state.context = state.context.prev;\n  }\n\n  function isClosing(text, contextClosing) {\n    if (text == contextClosing) {\n      return true;\n    } else {\n      // contextClosing may be multiple keywords separated by ;\n      var closingKeywords = contextClosing.split(\";\");\n      for (var i in closingKeywords) {\n        if (text == closingKeywords[i]) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  function buildElectricInputRegEx() {\n    // Reindentation should occur on any bracket char: {}()[]\n    // or on a match of any of the block closing keywords, at\n    // the end of a line\n    var allClosings = [];\n    for (var i in openClose) {\n      if (openClose[i]) {\n        var closings = openClose[i].split(\";\");\n        for (var j in closings) {\n          allClosings.push(closings[j]);\n        }\n      }\n    }\n    var re = new RegExp(\"[{}()\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n    return re;\n  }\n\n  // Interface\n  return {\n    startState: function(indentUnit) {\n      var state = {\n        tokenize: null,\n        context: new Context(-indentUnit, 0, \"top\", false),\n        indented: 0,\n        startOfLine: true\n      };\n      if (hooks.startState) hooks.startState(state);\n      return state;\n    },\n\n    token: function(stream, state) {\n      var ctx = state.context;\n      if (stream.sol()) {\n        if (ctx.align == null) ctx.align = false;\n        state.indented = stream.indentation();\n        state.startOfLine = true;\n      }\n      if (hooks.token) {\n        // Call hook, with an optional return value of a style to override verilog styling.\n        var style = hooks.token(stream, state);\n        if (style !== undefined) {\n          return style;\n        }\n      }\n      if (stream.eatSpace()) return null;\n      curPunc = null;\n      curKeyword = null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style == \"comment\" || style == \"meta\" || style == \"variable\") return style;\n      if (ctx.align == null) ctx.align = true;\n\n      if (curPunc == ctx.type) {\n        popContext(state);\n      } else if ((curPunc == \";\" && ctx.type == \"statement\") ||\n                 (ctx.type && isClosing(curKeyword, ctx.type))) {\n        ctx = popContext(state);\n        while (ctx && ctx.type == \"statement\") ctx = popContext(state);\n      } else if (curPunc == \"{\") {\n        pushContext(state, stream.column(), \"}\");\n      } else if (curPunc == \"[\") {\n        pushContext(state, stream.column(), \"]\");\n      } else if (curPunc == \"(\") {\n        pushContext(state, stream.column(), \")\");\n      } else if (ctx && ctx.type == \"endcase\" && curPunc == \":\") {\n        pushContext(state, stream.column(), \"statement\");\n      } else if (curPunc == \"newstatement\") {\n        pushContext(state, stream.column(), \"statement\");\n      } else if (curPunc == \"newblock\") {\n        if (curKeyword == \"function\" && ctx && (ctx.type == \"statement\" || ctx.type == \"endgroup\")) {\n          // The 'function' keyword can appear in some other contexts where it actually does not\n          // indicate a function (import/export DPI and covergroup definitions).\n          // Do nothing in this case\n        } else if (curKeyword == \"task\" && ctx && ctx.type == \"statement\") {\n          // Same thing for task\n        } else {\n          var close = openClose[curKeyword];\n          pushContext(state, stream.column(), close);\n        }\n      }\n\n      state.startOfLine = false;\n      return style;\n    },\n\n    indent: function(state, textAfter, cx) {\n      if (state.tokenize != tokenBase && state.tokenize != null) return null;\n      if (hooks.indent) {\n        var fromHook = hooks.indent(state);\n        if (fromHook >= 0) return fromHook;\n      }\n      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);\n      if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n      var closing = false;\n      var possibleClosing = textAfter.match(closingBracketOrWord);\n      if (possibleClosing)\n        closing = isClosing(possibleClosing[0], ctx.type);\n      if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit || cx.unit);\n      else if (closingBracket.test(ctx.type) && ctx.align && !dontAlignCalls) return ctx.column + (closing ? 0 : 1);\n      else if (ctx.type == \")\" && !closing) return ctx.indented + (statementIndentUnit || cx.unit);\n      else return ctx.indented + (closing ? 0 : cx.unit);\n    },\n\n    languageData: {\n      indentOnInput: buildElectricInputRegEx(),\n      commentTokens: {line: \"//\", block: {open: \"/*\", close: \"*/\"}}\n    }\n  };\n};\n\nexport const verilog = mkVerilog({})\n\n// TL-Verilog mode.\n// See tl-x.org for language spec.\n// See the mode in action at makerchip.com.\n// Contact: steve.hoover@redwoodeda.com\n\n// TLV Identifier prefixes.\n// Note that sign is not treated separately, so \"+/-\" versions of numeric identifiers\n// are included.\nvar tlvIdentifierStyle = {\n  \"|\": \"link\",\n  \">\": \"property\",  // Should condition this off for > TLV 1c.\n  \"$\": \"variable\",\n  \"$$\": \"variable\",\n  \"?$\": \"qualifier\",\n  \"?*\": \"qualifier\",\n  \"-\": \"contentSeparator\",\n  \"/\": \"property\",\n  \"/-\": \"property\",\n  \"@\": \"variableName.special\",\n  \"@-\": \"variableName.special\",\n  \"@++\": \"variableName.special\",\n  \"@+=\": \"variableName.special\",\n  \"@+=-\": \"variableName.special\",\n  \"@--\": \"variableName.special\",\n  \"@-=\": \"variableName.special\",\n  \"%+\": \"tag\",\n  \"%-\": \"tag\",\n  \"%\": \"tag\",\n  \">>\": \"tag\",\n  \"<<\": \"tag\",\n  \"<>\": \"tag\",\n  \"#\": \"tag\",  // Need to choose a style for this.\n  \"^\": \"attribute\",\n  \"^^\": \"attribute\",\n  \"^!\": \"attribute\",\n  \"*\": \"variable\",\n  \"**\": \"variable\",\n  \"\\\\\": \"keyword\",\n  \"\\\"\": \"comment\"\n};\n\n// Lines starting with these characters define scope (result in indentation).\nvar tlvScopePrefixChars = {\n  \"/\": \"beh-hier\",\n  \">\": \"beh-hier\",\n  \"-\": \"phys-hier\",\n  \"|\": \"pipe\",\n  \"?\": \"when\",\n  \"@\": \"stage\",\n  \"\\\\\": \"keyword\"\n};\nvar tlvIndentUnit = 3;\nvar tlvTrackStatements = false;\nvar tlvIdentMatch = /^([~!@#\\$%\\^&\\*-\\+=\\?\\/\\\\\\|'\"<>]+)([\\d\\w_]*)/;  // Matches an identifier.\n// Note that ':' is excluded, because of it's use in [:].\nvar tlvLineIndentationMatch = /^[! ] */;\nvar tlvCommentMatch = /^\\/[\\/\\*]/;\n\nexport const tlv = mkVerilog({\n  hooks: {\n    electricInput: false,\n\n    // Return undefined for verilog tokenizing, or style for TLV token (null not used).\n    // Standard CM styles are used for most formatting, but some TL-Verilog-specific highlighting\n    // can be enabled with the definition of cm-tlv-* styles, including highlighting for:\n    //   - M4 tokens\n    //   - TLV scope indentation\n    //   - Statement delimitation (enabled by tlvTrackStatements)\n    token: function(stream, state) {\n      var style = undefined;\n      var match;  // Return value of pattern matches.\n\n      // Set highlighting mode based on code region (TLV or SV).\n      if (stream.sol() && ! state.tlvInBlockComment) {\n        // Process region.\n        if (stream.peek() == '\\\\') {\n          style = \"def\";\n          stream.skipToEnd();\n          if (stream.string.match(/\\\\SV/)) {\n            state.tlvCodeActive = false;\n          } else if (stream.string.match(/\\\\TLV/)){\n            state.tlvCodeActive = true;\n          }\n        }\n        // Correct indentation in the face of a line prefix char.\n        if (state.tlvCodeActive && stream.pos == 0 &&\n            (state.indented == 0) && (match = stream.match(tlvLineIndentationMatch, false))) {\n          state.indented = match[0].length;\n        }\n\n        // Compute indentation state:\n        //   o Auto indentation on next line\n        //   o Indentation scope styles\n        var indented = state.indented;\n        var depth = indented / tlvIndentUnit;\n        if (depth <= state.tlvIndentationStyle.length) {\n          // not deeper than current scope\n\n          var blankline = stream.string.length == indented;\n          var chPos = depth * tlvIndentUnit;\n          if (chPos < stream.string.length) {\n            var bodyString = stream.string.slice(chPos);\n            var ch = bodyString[0];\n            if (tlvScopePrefixChars[ch] && ((match = bodyString.match(tlvIdentMatch)) &&\n                                            tlvIdentifierStyle[match[1]])) {\n              // This line begins scope.\n              // Next line gets indented one level.\n              indented += tlvIndentUnit;\n              // Style the next level of indentation (except non-region keyword identifiers,\n              //   which are statements themselves)\n              if (!(ch == \"\\\\\" && chPos > 0)) {\n                state.tlvIndentationStyle[depth] = tlvScopePrefixChars[ch];\n                if (tlvTrackStatements) {state.statementComment = false;}\n                depth++;\n              }\n            }\n          }\n          // Clear out deeper indentation levels unless line is blank.\n          if (!blankline) {\n            while (state.tlvIndentationStyle.length > depth) {\n              state.tlvIndentationStyle.pop();\n            }\n          }\n        }\n        // Set next level of indentation.\n        state.tlvNextIndent = indented;\n      }\n\n      if (state.tlvCodeActive) {\n        // Highlight as TLV.\n\n        var beginStatement = false;\n        if (tlvTrackStatements) {\n          // This starts a statement if the position is at the scope level\n          // and we're not within a statement leading comment.\n          beginStatement =\n            (stream.peek() != \" \") &&   // not a space\n            (style === undefined) &&    // not a region identifier\n            !state.tlvInBlockComment && // not in block comment\n            //!stream.match(tlvCommentMatch, false) && // not comment start\n          (stream.column() == state.tlvIndentationStyle.length * tlvIndentUnit);  // at scope level\n          if (beginStatement) {\n            if (state.statementComment) {\n              // statement already started by comment\n              beginStatement = false;\n            }\n            state.statementComment =\n              stream.match(tlvCommentMatch, false); // comment start\n          }\n        }\n\n        var match;\n        if (style !== undefined) {\n        } else if (state.tlvInBlockComment) {\n          // In a block comment.\n          if (stream.match(/^.*?\\*\\//)) {\n            // Exit block comment.\n            state.tlvInBlockComment = false;\n            if (tlvTrackStatements && !stream.eol()) {\n              // Anything after comment is assumed to be real statement content.\n              state.statementComment = false;\n            }\n          } else {\n            stream.skipToEnd();\n          }\n          style = \"comment\";\n        } else if ((match = stream.match(tlvCommentMatch)) && !state.tlvInBlockComment) {\n          // Start comment.\n          if (match[0] == \"//\") {\n            // Line comment.\n            stream.skipToEnd();\n          } else {\n            // Block comment.\n            state.tlvInBlockComment = true;\n          }\n          style = \"comment\";\n        } else if (match = stream.match(tlvIdentMatch)) {\n          // looks like an identifier (or identifier prefix)\n          var prefix = match[1];\n          var mnemonic = match[2];\n          if (// is identifier prefix\n            tlvIdentifierStyle.hasOwnProperty(prefix) &&\n              // has mnemonic or we're at the end of the line (maybe it hasn't been typed yet)\n            (mnemonic.length > 0 || stream.eol())) {\n            style = tlvIdentifierStyle[prefix];\n          } else {\n            // Just swallow one character and try again.\n            // This enables subsequent identifier match with preceding symbol character, which\n            //   is legal within a statement.  (Eg, !$reset).  It also enables detection of\n            //   comment start with preceding symbols.\n            stream.backUp(stream.current().length - 1);\n          }\n        } else if (stream.match(/^\\t+/)) {\n          // Highlight tabs, which are illegal.\n          style = \"invalid\";\n        } else if (stream.match(/^[\\[\\]{}\\(\\);\\:]+/)) {\n          // [:], (), {}, ;.\n          style = \"meta\";\n        } else if (match = stream.match(/^[mM]4([\\+_])?[\\w\\d_]*/)) {\n          // m4 pre proc\n          style = (match[1] == \"+\") ? \"keyword.special\" : \"keyword\";\n        } else if (stream.match(/^ +/)){\n          // Skip over spaces.\n          if (stream.eol()) {\n            // Trailing spaces.\n            style = \"error\";\n          }\n        } else if (stream.match(/^[\\w\\d_]+/)) {\n          // alpha-numeric token.\n          style = \"number\";\n        } else {\n          // Eat the next char w/ no formatting.\n          stream.next();\n        }\n      } else {\n        if (stream.match(/^[mM]4([\\w\\d_]*)/)) {\n          // m4 pre proc\n          style = \"keyword\";\n        }\n      }\n      return style;\n    },\n\n    indent: function(state) {\n      return (state.tlvCodeActive == true) ? state.tlvNextIndent : -1;\n    },\n\n    startState: function(state) {\n      state.tlvIndentationStyle = [];  // Styles to use for each level of indentation.\n      state.tlvCodeActive = true;  // True when we're in a TLV region (and at beginning of file).\n      state.tlvNextIndent = -1;    // The number of spaces to autoindent the next line if tlvCodeActive.\n      state.tlvInBlockComment = false;  // True inside /**/ comment.\n      if (tlvTrackStatements) {\n        state.statementComment = false;  // True inside a statement's header comment.\n      }\n    }\n\n  }\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}