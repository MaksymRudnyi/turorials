{"ast":null,"code":"export function selectWord(_ref) {\n  var {\n    text,\n    selection\n  } = _ref;\n\n  if (text && text.length && selection.start === selection.end) {\n    // the user is pointing to a word\n    return getSurroundingWord(text, selection.start);\n  }\n\n  return selection;\n}\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\n\nexport function getBreaksNeededForEmptyLineBefore(text, startPosition) {\n  if (text === void 0) {\n    text = '';\n  }\n\n  if (startPosition === 0) return 0; // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInFirstLine = true;\n\n  for (var i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        // blank space\n        continue;\n\n      case 10:\n        // line break\n        neededBreaks--;\n        isInFirstLine = false;\n        break;\n\n      default:\n        return neededBreaks;\n    }\n  }\n\n  return isInFirstLine ? 0 : neededBreaks;\n}\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\n\nexport function getBreaksNeededForEmptyLineAfter(text, startPosition) {\n  if (text === void 0) {\n    text = '';\n  }\n\n  if (startPosition === text.length - 1) return 0; // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInLastLine = true;\n\n  for (var i = startPosition; i < text.length && neededBreaks >= 0; i++) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        continue;\n\n      case 10:\n        {\n          neededBreaks--;\n          isInLastLine = false;\n          break;\n        }\n\n      default:\n        return neededBreaks;\n    }\n  }\n\n  return isInLastLine ? 0 : neededBreaks;\n}\nexport function getSurroundingWord(text, position) {\n  if (!text) throw Error(\"Argument 'text' should be truthy\");\n\n  var isWordDelimiter = c => c === ' ' || c.charCodeAt(0) === 10; // leftIndex is initialized to 0 because if selection is 0, it won't even enter the iteration\n\n\n  var start = 0; // rightIndex is initialized to text.length because if selection is equal to text.length it won't even enter the interation\n\n  var end = text.length; // iterate to the left\n\n  for (var i = position; i - 1 > -1; i--) {\n    if (isWordDelimiter(text[i - 1])) {\n      start = i;\n      break;\n    }\n  } // iterate to the right\n\n\n  for (var _i = position; _i < text.length; _i++) {\n    if (isWordDelimiter(text[_i])) {\n      end = _i;\n      break;\n    }\n  }\n\n  return {\n    start,\n    end\n  };\n}","map":{"version":3,"sources":["../../src/utils/markdownUtils.ts"],"names":["selection","text","getSurroundingWord","startPosition","neededBreaks","isInFirstLine","i","isInLastLine","Error","isWordDelimiter","c","start","end"],"mappings":"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","sourcesContent":["import { TextRange } from '../commands';\n\nexport interface TextSection {\n  text: string;\n  selection: TextRange;\n}\n\nexport function selectWord({ text, selection }: TextSection): TextRange {\n  if (text && text.length && selection.start === selection.end) {\n    // the user is pointing to a word\n    return getSurroundingWord(text, selection.start);\n  }\n  return selection;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\nexport function getBreaksNeededForEmptyLineBefore(text = '', startPosition: number): number {\n  if (startPosition === 0) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  let neededBreaks = 2;\n  let isInFirstLine = true;\n  for (let i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\n    switch (text.charCodeAt(i)) {\n      case 32: // blank space\n        continue;\n      case 10: // line break\n        neededBreaks--;\n        isInFirstLine = false;\n        break;\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInFirstLine ? 0 : neededBreaks;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\nexport function getBreaksNeededForEmptyLineAfter(text = '', startPosition: number): number {\n  if (startPosition === text.length - 1) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  let neededBreaks = 2;\n  let isInLastLine = true;\n  for (let i = startPosition; i < text.length && neededBreaks >= 0; i++) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        continue;\n      case 10: {\n        neededBreaks--;\n        isInLastLine = false;\n        break;\n      }\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInLastLine ? 0 : neededBreaks;\n}\n\nexport function getSurroundingWord(text: string, position: number): TextRange {\n  if (!text) throw Error(\"Argument 'text' should be truthy\");\n\n  const isWordDelimiter = (c: string) => c === ' ' || c.charCodeAt(0) === 10;\n\n  // leftIndex is initialized to 0 because if selection is 0, it won't even enter the iteration\n  let start = 0;\n  // rightIndex is initialized to text.length because if selection is equal to text.length it won't even enter the interation\n  let end = text.length;\n\n  // iterate to the left\n  for (let i = position; i - 1 > -1; i--) {\n    if (isWordDelimiter(text[i - 1])) {\n      start = i;\n      break;\n    }\n  }\n\n  // iterate to the right\n  for (let i = position; i < text.length; i++) {\n    if (isWordDelimiter(text[i])) {\n      end = i;\n      break;\n    }\n  }\n\n  return { start, end };\n}\n"]},"metadata":{},"sourceType":"module"}