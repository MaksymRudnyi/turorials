{"ast":null,"code":"/**\n * The MIT License\n * Copyright (c) 2018 Dmitriy Kubyshkin\n * Copied from https://github.com/grassator/insert-text-at-cursor\n */\nvar browserSupportsTextareaTextNodes;\n/**\n * @param {HTMLElement} input\n * @return {boolean}\n */\n\nfunction canManipulateViaTextNodes(input) {\n  if (input.nodeName !== 'TEXTAREA') {\n    return false;\n  }\n\n  if (typeof browserSupportsTextareaTextNodes === 'undefined') {\n    var textarea = document.createElement('textarea');\n    textarea.value = '1';\n    browserSupportsTextareaTextNodes = !!textarea.firstChild;\n  }\n\n  return browserSupportsTextareaTextNodes;\n}\n/**\n * @param {string} val\n * @param {number} cursorIdx\n * @param {HTMLTextAreaElement|HTMLInputElement} input\n * @return {void}\n */\n\n\nexport var insertAtLineStart = (val, cursorIdx, input) => {\n  var content = input.value;\n  var startIdx = 0;\n\n  while (cursorIdx--) {\n    var char = content[cursorIdx];\n\n    if (char === '\\n') {\n      startIdx = cursorIdx + 1;\n      break;\n    }\n  }\n\n  input.focus();\n  input.setRangeText(val, startIdx, startIdx);\n  input.dispatchEvent(new Event('input', {\n    bubbles: true\n  }));\n};\n/**\n * @param {HTMLTextAreaElement|HTMLInputElement} input\n * @param {string} text\n * @returns {void}\n */\n\nexport function insertTextAtPosition(input, text) {\n  // Most of the used APIs only work with the field selected\n  input.focus(); // IE 8-10\n\n  if (document.selection) {\n    var ieRange = document.selection.createRange();\n    ieRange.text = text; // Move cursor after the inserted text\n\n    ieRange.collapse(false\n    /* to the end */\n    );\n    ieRange.select();\n    return;\n  } // Webkit + Edge\n\n\n  var isSuccess = document.execCommand && document.execCommand('insertText', false, text);\n\n  if (!isSuccess) {\n    var start = input.selectionStart;\n    var end = input.selectionEnd; // Firefox (non-standard method)\n\n    if (typeof input.setRangeText === 'function') {\n      input.setRangeText(text);\n    } else {\n      // To make a change we just need a Range, not a Selection\n      var range = document.createRange();\n      var textNode = document.createTextNode(text);\n\n      if (canManipulateViaTextNodes(input)) {\n        var node = input.firstChild; // If textarea is empty, just insert the text\n\n        if (!node) {\n          input.appendChild(textNode);\n        } else {\n          // Otherwise we need to find a nodes for start and end\n          var offset = 0;\n          var startNode = null;\n          var endNode = null;\n\n          while (node && (startNode === null || endNode === null)) {\n            var nodeLength = node.nodeValue.length; // if start of the selection falls into current node\n\n            if (start >= offset && start <= offset + nodeLength) {\n              range.setStart(startNode = node, start - offset);\n            } // if end of the selection falls into current node\n\n\n            if (end >= offset && end <= offset + nodeLength) {\n              range.setEnd(endNode = node, end - offset);\n            }\n\n            offset += nodeLength;\n            node = node.nextSibling;\n          } // If there is some text selected, remove it as we should replace it\n\n\n          if (start !== end) {\n            range.deleteContents();\n          }\n        }\n      } // If the node is a textarea and the range doesn't span outside the element\n      //\n      // Get the commonAncestorContainer of the selected range and test its type\n      // If the node is of type `#text` it means that we're still working with text nodes within our textarea element\n      // otherwise, if it's of type `#document` for example it means our selection spans outside the textarea.\n\n\n      if (canManipulateViaTextNodes(input) && range.commonAncestorContainer.nodeName === '#text') {\n        // Finally insert a new node. The browser will automatically split start and end nodes into two if necessary\n        range.insertNode(textNode);\n      } else {\n        // If the node is not a textarea or the range spans outside a textarea the only way is to replace the whole value\n        var value = input.value;\n        input.value = value.slice(0, start) + text + value.slice(end);\n      }\n    } // Correct the cursor position to be at the end of the insertion\n\n\n    input.setSelectionRange(start + text.length, start + text.length); // Notify any possible listeners of the change\n\n    var e = document.createEvent('UIEvent');\n    e.initEvent('input', true, false);\n    input.dispatchEvent(e);\n  }\n}","map":{"version":3,"sources":["../../src/utils/InsertTextAtPosition.ts"],"names":["input","textarea","document","browserSupportsTextareaTextNodes","insertAtLineStart","content","startIdx","cursorIdx","char","bubbles","ieRange","isSuccess","start","end","range","textNode","canManipulateViaTextNodes","node","offset","startNode","endNode","nodeLength","value","text","e"],"mappings":"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","sourcesContent":["/**\n * The MIT License\n * Copyright (c) 2018 Dmitriy Kubyshkin\n * Copied from https://github.com/grassator/insert-text-at-cursor\n */\n\nlet browserSupportsTextareaTextNodes: any;\n\n/**\n * @param {HTMLElement} input\n * @return {boolean}\n */\nfunction canManipulateViaTextNodes(input: HTMLTextAreaElement | HTMLInputElement): boolean {\n  if (input.nodeName !== 'TEXTAREA') {\n    return false;\n  }\n  if (typeof browserSupportsTextareaTextNodes === 'undefined') {\n    const textarea: HTMLTextAreaElement = document.createElement('textarea');\n    textarea.value = '1';\n    browserSupportsTextareaTextNodes = !!textarea.firstChild;\n  }\n  return browserSupportsTextareaTextNodes;\n}\n\n/**\n * @param {string} val\n * @param {number} cursorIdx\n * @param {HTMLTextAreaElement|HTMLInputElement} input\n * @return {void}\n */\nexport const insertAtLineStart = (\n  val: string,\n  cursorIdx: number,\n  input: HTMLTextAreaElement | HTMLInputElement,\n): void => {\n  const content = input.value;\n  let startIdx = 0;\n\n  while (cursorIdx--) {\n    let char = content[cursorIdx];\n    if (char === '\\n') {\n      startIdx = cursorIdx + 1;\n      break;\n    }\n  }\n\n  input.focus();\n  input.setRangeText(val, startIdx, startIdx);\n  input.dispatchEvent(new Event('input', { bubbles: true }));\n};\n\n/**\n * @param {HTMLTextAreaElement|HTMLInputElement} input\n * @param {string} text\n * @returns {void}\n */\nexport function insertTextAtPosition(input: HTMLTextAreaElement | HTMLInputElement, text: string): void {\n  // Most of the used APIs only work with the field selected\n  input.focus();\n\n  // IE 8-10\n  if ((document as any).selection) {\n    const ieRange = (document as any).selection.createRange();\n    ieRange.text = text;\n\n    // Move cursor after the inserted text\n    ieRange.collapse(false /* to the end */);\n    ieRange.select();\n\n    return;\n  }\n\n  // Webkit + Edge\n  const isSuccess = document.execCommand && document.execCommand('insertText', false, text);\n  if (!isSuccess) {\n    const start = input.selectionStart!;\n    const end = input.selectionEnd!;\n    // Firefox (non-standard method)\n    if (typeof input.setRangeText === 'function') {\n      input.setRangeText(text);\n    } else {\n      // To make a change we just need a Range, not a Selection\n      const range = document.createRange();\n      const textNode = document.createTextNode(text);\n\n      if (canManipulateViaTextNodes(input)) {\n        let node = input.firstChild;\n\n        // If textarea is empty, just insert the text\n        if (!node) {\n          input.appendChild(textNode);\n        } else {\n          // Otherwise we need to find a nodes for start and end\n          let offset = 0;\n          let startNode = null;\n          let endNode = null;\n\n          while (node && (startNode === null || endNode === null)) {\n            const nodeLength = node.nodeValue!.length;\n\n            // if start of the selection falls into current node\n            if (start >= offset && start <= offset + nodeLength) {\n              range.setStart((startNode = node), start - offset);\n            }\n\n            // if end of the selection falls into current node\n            if (end >= offset && end <= offset + nodeLength) {\n              range.setEnd((endNode = node), end - offset);\n            }\n\n            offset += nodeLength;\n            node = node.nextSibling;\n          }\n\n          // If there is some text selected, remove it as we should replace it\n          if (start !== end) {\n            range.deleteContents();\n          }\n        }\n      }\n\n      // If the node is a textarea and the range doesn't span outside the element\n      //\n      // Get the commonAncestorContainer of the selected range and test its type\n      // If the node is of type `#text` it means that we're still working with text nodes within our textarea element\n      // otherwise, if it's of type `#document` for example it means our selection spans outside the textarea.\n      if (canManipulateViaTextNodes(input) && range.commonAncestorContainer.nodeName === '#text') {\n        // Finally insert a new node. The browser will automatically split start and end nodes into two if necessary\n        range.insertNode(textNode);\n      } else {\n        // If the node is not a textarea or the range spans outside a textarea the only way is to replace the whole value\n        const value = input.value;\n        input.value = value.slice(0, start) + text + value.slice(end);\n      }\n    }\n\n    // Correct the cursor position to be at the end of the insertion\n    input.setSelectionRange(start + text.length, start + text.length);\n\n    // Notify any possible listeners of the change\n    const e = document.createEvent('UIEvent');\n    e.initEvent('input', true, false);\n    input.dispatchEvent(e);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}