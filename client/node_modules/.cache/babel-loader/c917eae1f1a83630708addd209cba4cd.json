{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('./syntax.js').Align} Align\n */\nconst alignment = {\n  none: '',\n  left: ' align=\"left\"',\n  right: ' align=\"right\"',\n  center: ' align=\"center\"'\n};\n/** @type {HtmlExtension} */\n\nexport const gfmTableHtml = {\n  enter: {\n    table(token) {\n      /** @type {Array<Align>} */\n      // @ts-expect-error Custom.\n      const tableAlign = token._align;\n      this.lineEndingIfNeeded();\n      this.tag('<table>');\n      this.setData('tableAlign', tableAlign);\n    },\n\n    tableBody() {\n      // Clear slurping line ending from the delimiter row.\n      this.setData('slurpOneLineEnding');\n      this.tag('<tbody>');\n    },\n\n    tableData() {\n      const tableAlign =\n      /** @type {Array<Align>} */\n      this.getData('tableAlign');\n      const tableColumn =\n      /** @type {number} */\n      this.getData('tableColumn');\n      const align = alignment[tableAlign[tableColumn]];\n\n      if (align === undefined) {\n        // Capture results to ignore them.\n        this.buffer();\n      } else {\n        this.lineEndingIfNeeded();\n        this.tag('<td' + align + '>');\n      }\n    },\n\n    tableHead() {\n      this.lineEndingIfNeeded();\n      this.tag('<thead>');\n    },\n\n    tableHeader() {\n      const tableAlign =\n      /** @type {Array<Align>} */\n      this.getData('tableAlign');\n      const tableColumn =\n      /** @type {number} */\n      this.getData('tableColumn');\n      const align = alignment[tableAlign[tableColumn]];\n      this.lineEndingIfNeeded();\n      this.tag('<th' + align + '>');\n    },\n\n    tableRow() {\n      this.setData('tableColumn', 0);\n      this.lineEndingIfNeeded();\n      this.tag('<tr>');\n    }\n\n  },\n  exit: {\n    // Overwrite the default code text data handler to unescape escaped pipes when\n    // they are in tables.\n    codeTextData(token) {\n      let value = this.sliceSerialize(token);\n\n      if (this.getData('tableAlign')) {\n        value = value.replace(/\\\\([\\\\|])/g, replace);\n      }\n\n      this.raw(this.encode(value));\n    },\n\n    table() {\n      this.setData('tableAlign'); // If there was no table body, make sure the slurping from the delimiter row\n      // is cleared.\n\n      this.setData('slurpAllLineEndings');\n      this.lineEndingIfNeeded();\n      this.tag('</table>');\n    },\n\n    tableBody() {\n      this.lineEndingIfNeeded();\n      this.tag('</tbody>');\n    },\n\n    tableData() {\n      const tableAlign =\n      /** @type {Array<Align>} */\n      this.getData('tableAlign');\n      const tableColumn =\n      /** @type {number} */\n      this.getData('tableColumn');\n\n      if (tableColumn in tableAlign) {\n        this.tag('</td>');\n        this.setData('tableColumn', tableColumn + 1);\n      } else {\n        // Stop capturing.\n        this.resume();\n      }\n    },\n\n    tableHead() {\n      this.lineEndingIfNeeded();\n      this.tag('</thead>');\n      this.setData('slurpOneLineEnding', true); // Slurp the line ending from the delimiter row.\n    },\n\n    tableHeader() {\n      const tableColumn =\n      /** @type {number} */\n      this.getData('tableColumn');\n      this.tag('</th>');\n      this.setData('tableColumn', tableColumn + 1);\n    },\n\n    tableRow() {\n      const tableAlign =\n      /** @type {Array<Align>} */\n      this.getData('tableAlign');\n      let tableColumn =\n      /** @type {number} */\n      this.getData('tableColumn');\n\n      while (tableColumn < tableAlign.length) {\n        this.lineEndingIfNeeded();\n        this.tag('<td' + alignment[tableAlign[tableColumn]] + '></td>');\n        tableColumn++;\n      }\n\n      this.setData('tableColumn', tableColumn);\n      this.lineEndingIfNeeded();\n      this.tag('</tr>');\n    }\n\n  }\n};\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\n\nfunction replace($0, $1) {\n  // Pipes work, backslashes don’t (but can’t escape pipes).\n  return $1 === '|' ? $1 : $0;\n}","map":{"version":3,"names":["alignment","none","left","right","center","gfmTableHtml","enter","table","token","tableAlign","_align","lineEndingIfNeeded","tag","setData","tableBody","tableData","getData","tableColumn","align","undefined","buffer","tableHead","tableHeader","tableRow","exit","codeTextData","value","sliceSerialize","replace","raw","encode","resume","length","$0","$1"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/micromark-extension-gfm-table/lib/html.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('./syntax.js').Align} Align\n */\nconst alignment = {\n  none: '',\n  left: ' align=\"left\"',\n  right: ' align=\"right\"',\n  center: ' align=\"center\"'\n}\n/** @type {HtmlExtension} */\n\nexport const gfmTableHtml = {\n  enter: {\n    table(token) {\n      /** @type {Array<Align>} */\n      // @ts-expect-error Custom.\n      const tableAlign = token._align\n      this.lineEndingIfNeeded()\n      this.tag('<table>')\n      this.setData('tableAlign', tableAlign)\n    },\n\n    tableBody() {\n      // Clear slurping line ending from the delimiter row.\n      this.setData('slurpOneLineEnding')\n      this.tag('<tbody>')\n    },\n\n    tableData() {\n      const tableAlign =\n        /** @type {Array<Align>} */\n        this.getData('tableAlign')\n      const tableColumn =\n        /** @type {number} */\n        this.getData('tableColumn')\n      const align = alignment[tableAlign[tableColumn]]\n\n      if (align === undefined) {\n        // Capture results to ignore them.\n        this.buffer()\n      } else {\n        this.lineEndingIfNeeded()\n        this.tag('<td' + align + '>')\n      }\n    },\n\n    tableHead() {\n      this.lineEndingIfNeeded()\n      this.tag('<thead>')\n    },\n\n    tableHeader() {\n      const tableAlign =\n        /** @type {Array<Align>} */\n        this.getData('tableAlign')\n      const tableColumn =\n        /** @type {number} */\n        this.getData('tableColumn')\n      const align = alignment[tableAlign[tableColumn]]\n      this.lineEndingIfNeeded()\n      this.tag('<th' + align + '>')\n    },\n\n    tableRow() {\n      this.setData('tableColumn', 0)\n      this.lineEndingIfNeeded()\n      this.tag('<tr>')\n    }\n  },\n  exit: {\n    // Overwrite the default code text data handler to unescape escaped pipes when\n    // they are in tables.\n    codeTextData(token) {\n      let value = this.sliceSerialize(token)\n\n      if (this.getData('tableAlign')) {\n        value = value.replace(/\\\\([\\\\|])/g, replace)\n      }\n\n      this.raw(this.encode(value))\n    },\n\n    table() {\n      this.setData('tableAlign') // If there was no table body, make sure the slurping from the delimiter row\n      // is cleared.\n\n      this.setData('slurpAllLineEndings')\n      this.lineEndingIfNeeded()\n      this.tag('</table>')\n    },\n\n    tableBody() {\n      this.lineEndingIfNeeded()\n      this.tag('</tbody>')\n    },\n\n    tableData() {\n      const tableAlign =\n        /** @type {Array<Align>} */\n        this.getData('tableAlign')\n      const tableColumn =\n        /** @type {number} */\n        this.getData('tableColumn')\n\n      if (tableColumn in tableAlign) {\n        this.tag('</td>')\n        this.setData('tableColumn', tableColumn + 1)\n      } else {\n        // Stop capturing.\n        this.resume()\n      }\n    },\n\n    tableHead() {\n      this.lineEndingIfNeeded()\n      this.tag('</thead>')\n      this.setData('slurpOneLineEnding', true) // Slurp the line ending from the delimiter row.\n    },\n\n    tableHeader() {\n      const tableColumn =\n        /** @type {number} */\n        this.getData('tableColumn')\n      this.tag('</th>')\n      this.setData('tableColumn', tableColumn + 1)\n    },\n\n    tableRow() {\n      const tableAlign =\n        /** @type {Array<Align>} */\n        this.getData('tableAlign')\n      let tableColumn =\n        /** @type {number} */\n        this.getData('tableColumn')\n\n      while (tableColumn < tableAlign.length) {\n        this.lineEndingIfNeeded()\n        this.tag('<td' + alignment[tableAlign[tableColumn]] + '></td>')\n        tableColumn++\n      }\n\n      this.setData('tableColumn', tableColumn)\n      this.lineEndingIfNeeded()\n      this.tag('</tr>')\n    }\n  }\n}\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\n\nfunction replace($0, $1) {\n  // Pipes work, backslashes don’t (but can’t escape pipes).\n  return $1 === '|' ? $1 : $0\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}