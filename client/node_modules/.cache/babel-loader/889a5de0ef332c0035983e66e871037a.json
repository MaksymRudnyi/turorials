{"ast":null,"code":"/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * Options for unist util filter\n *\n * @typedef {Object} FilterOptions\n * @property {boolean} [cascade=true] Whether to drop parent nodes if they had children, but all their children were filtered out.\n */\nimport { convert } from 'unist-util-is';\nconst own = {}.hasOwnProperty;\n/**\n * Create a new tree consisting of copies of all nodes that pass test.\n * The tree is walked in preorder (NLR), visiting the node itself, then its head, etc.\n *\n * @param tree Tree to filter.\n * @param options Configuration (optional).\n * @param test is-compatible test (such as a type).\n * @returns Given `tree` or `null` if it didn’t pass `test`.\n */\n\nexport const filter =\n/**\n * @type {(\n *  (<Tree extends Node, Check extends Test>(node: Tree, options: FilterOptions, test: Check) => import('./complex-types').Matches<Tree, Check>) &\n *  (<Tree extends Node, Check extends Test>(node: Tree, test: Check) => import('./complex-types').Matches<Tree, Check>) &\n *  (<Tree extends Node>(node: Tree, options?: FilterOptions) => Tree)\n * )}\n */\n\n/**\n * @param {Node} tree\n * @param {FilterOptions} options\n * @param {Test} test\n * @returns {Node|null}\n */\nfunction (tree, options, test) {\n  const is = convert(test || options);\n  const cascade = options.cascade === undefined || options.cascade === null ? true : options.cascade;\n  return preorder(tree);\n  /**\n   * @param {Node} node\n   * @param {number|undefined} [index]\n   * @param {Parent|undefined} [parent]\n   * @returns {Node|null}\n   */\n\n  function preorder(node, index, parent) {\n    /** @type {Array.<Node>} */\n    const children = [];\n    /** @type {number} */\n\n    let childIndex;\n    /** @type {Node} */\n\n    let result;\n    /** @type {string} */\n\n    let key;\n    if (!is(node, index, parent)) return null; // @ts-expect-error: Looks like a parent.\n\n    if (node.children) {\n      childIndex = -1; // @ts-expect-error Looks like a parent.\n\n      while (++childIndex < node.children.length) {\n        // @ts-expect-error Looks like a parent.\n        result = preorder(node.children[childIndex], childIndex, node);\n\n        if (result) {\n          children.push(result);\n        }\n      } // @ts-expect-error Looks like a parent.\n\n\n      if (cascade && node.children.length > 0 && children.length === 0) return null;\n    } // Create a shallow clone, using the new children.\n\n    /** @type {typeof node} */\n    // @ts-expect-error all the fields will be copied over.\n\n\n    const next = {};\n\n    for (key in node) {\n      if (own.call(node, key)) {\n        // @ts-expect-error: Looks like a record.\n        next[key] = key === 'children' ? children : node[key];\n      }\n    }\n\n    return next;\n  }\n};","map":{"version":3,"names":["convert","own","hasOwnProperty","filter","tree","options","test","is","cascade","undefined","preorder","node","index","parent","children","childIndex","result","key","length","push","next","call"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/unist-util-filter/index.js"],"sourcesContent":["/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * Options for unist util filter\n *\n * @typedef {Object} FilterOptions\n * @property {boolean} [cascade=true] Whether to drop parent nodes if they had children, but all their children were filtered out.\n */\n\nimport {convert} from 'unist-util-is'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Create a new tree consisting of copies of all nodes that pass test.\n * The tree is walked in preorder (NLR), visiting the node itself, then its head, etc.\n *\n * @param tree Tree to filter.\n * @param options Configuration (optional).\n * @param test is-compatible test (such as a type).\n * @returns Given `tree` or `null` if it didn’t pass `test`.\n */\nexport const filter =\n  /**\n   * @type {(\n   *  (<Tree extends Node, Check extends Test>(node: Tree, options: FilterOptions, test: Check) => import('./complex-types').Matches<Tree, Check>) &\n   *  (<Tree extends Node, Check extends Test>(node: Tree, test: Check) => import('./complex-types').Matches<Tree, Check>) &\n   *  (<Tree extends Node>(node: Tree, options?: FilterOptions) => Tree)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {FilterOptions} options\n     * @param {Test} test\n     * @returns {Node|null}\n     */\n    function (tree, options, test) {\n      const is = convert(test || options)\n      const cascade =\n        options.cascade === undefined || options.cascade === null\n          ? true\n          : options.cascade\n\n      return preorder(tree)\n\n      /**\n       * @param {Node} node\n       * @param {number|undefined} [index]\n       * @param {Parent|undefined} [parent]\n       * @returns {Node|null}\n       */\n      function preorder(node, index, parent) {\n        /** @type {Array.<Node>} */\n        const children = []\n        /** @type {number} */\n        let childIndex\n        /** @type {Node} */\n        let result\n        /** @type {string} */\n        let key\n\n        if (!is(node, index, parent)) return null\n\n        // @ts-expect-error: Looks like a parent.\n        if (node.children) {\n          childIndex = -1\n\n          // @ts-expect-error Looks like a parent.\n          while (++childIndex < node.children.length) {\n            // @ts-expect-error Looks like a parent.\n            result = preorder(node.children[childIndex], childIndex, node)\n\n            if (result) {\n              children.push(result)\n            }\n          }\n\n          // @ts-expect-error Looks like a parent.\n          if (cascade && node.children.length > 0 && children.length === 0)\n            return null\n        }\n\n        // Create a shallow clone, using the new children.\n        /** @type {typeof node} */\n        // @ts-expect-error all the fields will be copied over.\n        const next = {}\n\n        for (key in node) {\n          if (own.call(node, key)) {\n            // @ts-expect-error: Looks like a record.\n            next[key] = key === 'children' ? children : node[key]\n          }\n        }\n\n        return next\n      }\n    }\n  )\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA,SAAQA,OAAR,QAAsB,eAAtB;AAEA,MAAMC,GAAG,GAAG,GAAGC,cAAf;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,MAAM;AACjB;AACF;AACA;AACA;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACI,UAAUC,IAAV,EAAgBC,OAAhB,EAAyBC,IAAzB,EAA+B;EAC7B,MAAMC,EAAE,GAAGP,OAAO,CAACM,IAAI,IAAID,OAAT,CAAlB;EACA,MAAMG,OAAO,GACXH,OAAO,CAACG,OAAR,KAAoBC,SAApB,IAAiCJ,OAAO,CAACG,OAAR,KAAoB,IAArD,GACI,IADJ,GAEIH,OAAO,CAACG,OAHd;EAKA,OAAOE,QAAQ,CAACN,IAAD,CAAf;EAEA;AACN;AACA;AACA;AACA;AACA;;EACM,SAASM,QAAT,CAAkBC,IAAlB,EAAwBC,KAAxB,EAA+BC,MAA/B,EAAuC;IACrC;IACA,MAAMC,QAAQ,GAAG,EAAjB;IACA;;IACA,IAAIC,UAAJ;IACA;;IACA,IAAIC,MAAJ;IACA;;IACA,IAAIC,GAAJ;IAEA,IAAI,CAACV,EAAE,CAACI,IAAD,EAAOC,KAAP,EAAcC,MAAd,CAAP,EAA8B,OAAO,IAAP,CAVO,CAYrC;;IACA,IAAIF,IAAI,CAACG,QAAT,EAAmB;MACjBC,UAAU,GAAG,CAAC,CAAd,CADiB,CAGjB;;MACA,OAAO,EAAEA,UAAF,GAAeJ,IAAI,CAACG,QAAL,CAAcI,MAApC,EAA4C;QAC1C;QACAF,MAAM,GAAGN,QAAQ,CAACC,IAAI,CAACG,QAAL,CAAcC,UAAd,CAAD,EAA4BA,UAA5B,EAAwCJ,IAAxC,CAAjB;;QAEA,IAAIK,MAAJ,EAAY;UACVF,QAAQ,CAACK,IAAT,CAAcH,MAAd;QACD;MACF,CAXgB,CAajB;;;MACA,IAAIR,OAAO,IAAIG,IAAI,CAACG,QAAL,CAAcI,MAAd,GAAuB,CAAlC,IAAuCJ,QAAQ,CAACI,MAAT,KAAoB,CAA/D,EACE,OAAO,IAAP;IACH,CA7BoC,CA+BrC;;IACA;IACA;;;IACA,MAAME,IAAI,GAAG,EAAb;;IAEA,KAAKH,GAAL,IAAYN,IAAZ,EAAkB;MAChB,IAAIV,GAAG,CAACoB,IAAJ,CAASV,IAAT,EAAeM,GAAf,CAAJ,EAAyB;QACvB;QACAG,IAAI,CAACH,GAAD,CAAJ,GAAYA,GAAG,KAAK,UAAR,GAAqBH,QAArB,GAAgCH,IAAI,CAACM,GAAD,CAAhD;MACD;IACF;;IAED,OAAOG,IAAP;EACD;AACF,CA3EE"},"metadata":{},"sourceType":"module"}