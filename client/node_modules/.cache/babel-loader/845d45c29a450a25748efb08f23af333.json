{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\nimport { splice } from 'micromark-util-chunked';\n/** @type {Construct} */\n\nexport const headingAtx = {\n  name: 'headingAtx',\n  tokenize: tokenizeHeadingAtx,\n  resolve: resolveHeadingAtx\n};\n/** @type {Resolver} */\n\nfunction resolveHeadingAtx(events, context) {\n  let contentEnd = events.length - 2;\n  let contentStart = 3;\n  /** @type {Token} */\n\n  let content;\n  /** @type {Token} */\n\n  let text; // Prefix whitespace, part of the opening.\n\n  if (events[contentStart][1].type === 'whitespace') {\n    contentStart += 2;\n  } // Suffix whitespace, part of the closing.\n\n\n  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === 'whitespace') {\n    contentEnd -= 2;\n  }\n\n  if (events[contentEnd][1].type === 'atxHeadingSequence' && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === 'whitespace')) {\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;\n  }\n\n  if (contentEnd > contentStart) {\n    content = {\n      type: 'atxHeadingText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end\n    };\n    text = {\n      type: 'chunkText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end,\n      // @ts-expect-error Constants are fine to assign.\n      contentType: 'text'\n    };\n    splice(events, contentStart, contentEnd - contentStart + 1, [['enter', content, context], ['enter', text, context], ['exit', text, context], ['exit', content, context]]);\n  }\n\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeHeadingAtx(effects, ok, nok) {\n  const self = this;\n  let size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('atxHeading');\n    effects.enter('atxHeadingSequence');\n    return fenceOpenInside(code);\n  }\n  /** @type {State} */\n\n\n  function fenceOpenInside(code) {\n    if (code === 35 && size++ < 6) {\n      effects.consume(code);\n      return fenceOpenInside;\n    }\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingSequence');\n      return self.interrupt ? ok(code) : headingBreak(code);\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function headingBreak(code) {\n    if (code === 35) {\n      effects.enter('atxHeadingSequence');\n      return sequence(code);\n    }\n\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('atxHeading');\n      return ok(code);\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(effects, headingBreak, 'whitespace')(code);\n    }\n\n    effects.enter('atxHeadingText');\n    return data(code);\n  }\n  /** @type {State} */\n\n\n  function sequence(code) {\n    if (code === 35) {\n      effects.consume(code);\n      return sequence;\n    }\n\n    effects.exit('atxHeadingSequence');\n    return headingBreak(code);\n  }\n  /** @type {State} */\n\n\n  function data(code) {\n    if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingText');\n      return headingBreak(code);\n    }\n\n    effects.consume(code);\n    return data;\n  }\n}","map":{"version":3,"names":["factorySpace","markdownLineEnding","markdownLineEndingOrSpace","markdownSpace","splice","headingAtx","name","tokenize","tokenizeHeadingAtx","resolve","resolveHeadingAtx","events","context","contentEnd","length","contentStart","content","text","type","start","end","contentType","effects","ok","nok","self","size","code","enter","fenceOpenInside","consume","exit","interrupt","headingBreak","sequence","data"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/micromark-core-commonmark/lib/heading-atx.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {splice} from 'micromark-util-chunked'\n\n/** @type {Construct} */\nexport const headingAtx = {\n  name: 'headingAtx',\n  tokenize: tokenizeHeadingAtx,\n  resolve: resolveHeadingAtx\n}\n/** @type {Resolver} */\n\nfunction resolveHeadingAtx(events, context) {\n  let contentEnd = events.length - 2\n  let contentStart = 3\n  /** @type {Token} */\n\n  let content\n  /** @type {Token} */\n\n  let text // Prefix whitespace, part of the opening.\n\n  if (events[contentStart][1].type === 'whitespace') {\n    contentStart += 2\n  } // Suffix whitespace, part of the closing.\n\n  if (\n    contentEnd - 2 > contentStart &&\n    events[contentEnd][1].type === 'whitespace'\n  ) {\n    contentEnd -= 2\n  }\n\n  if (\n    events[contentEnd][1].type === 'atxHeadingSequence' &&\n    (contentStart === contentEnd - 1 ||\n      (contentEnd - 4 > contentStart &&\n        events[contentEnd - 2][1].type === 'whitespace'))\n  ) {\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4\n  }\n\n  if (contentEnd > contentStart) {\n    content = {\n      type: 'atxHeadingText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end\n    }\n    text = {\n      type: 'chunkText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end,\n      // @ts-expect-error Constants are fine to assign.\n      contentType: 'text'\n    }\n    splice(events, contentStart, contentEnd - contentStart + 1, [\n      ['enter', content, context],\n      ['enter', text, context],\n      ['exit', text, context],\n      ['exit', content, context]\n    ])\n  }\n\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeHeadingAtx(effects, ok, nok) {\n  const self = this\n  let size = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('atxHeading')\n    effects.enter('atxHeadingSequence')\n    return fenceOpenInside(code)\n  }\n  /** @type {State} */\n\n  function fenceOpenInside(code) {\n    if (code === 35 && size++ < 6) {\n      effects.consume(code)\n      return fenceOpenInside\n    }\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingSequence')\n      return self.interrupt ? ok(code) : headingBreak(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function headingBreak(code) {\n    if (code === 35) {\n      effects.enter('atxHeadingSequence')\n      return sequence(code)\n    }\n\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('atxHeading')\n      return ok(code)\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(effects, headingBreak, 'whitespace')(code)\n    }\n\n    effects.enter('atxHeadingText')\n    return data(code)\n  }\n  /** @type {State} */\n\n  function sequence(code) {\n    if (code === 35) {\n      effects.consume(code)\n      return sequence\n    }\n\n    effects.exit('atxHeadingSequence')\n    return headingBreak(code)\n  }\n  /** @type {State} */\n\n  function data(code) {\n    if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingText')\n      return headingBreak(code)\n    }\n\n    effects.consume(code)\n    return data\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}