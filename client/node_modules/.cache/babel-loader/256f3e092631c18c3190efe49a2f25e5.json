{"ast":null,"code":"/**\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Element} Element\n */\nvar search = /[#.]/g;\n/**\n * Create a hast element from a simple CSS selector.\n *\n * @param selector A simple CSS selector.\n *   Can contain a tag-name (`foo`), classes (`.bar`), and an ID (`#baz`).\n *   Multiple classes are allowed.\n *   Uses the last ID if multiple IDs are found.\n * @param [defaultTagName='div'] Tag name to use if `selector` does not specify one.\n */\n\nexport const parseSelector =\n/**\n * @type {(\n *  <Selector extends string, DefaultTagName extends string = 'div'>(selector?: Selector, defaultTagName?: DefaultTagName) => Element & {tagName: import('./extract.js').ExtractTagName<Selector, DefaultTagName>}\n * )}\n */\n\n/**\n * @param {string} [selector]\n * @param {string} [defaultTagName='div']\n * @returns {Element}\n */\nfunction (selector) {\n  let defaultTagName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'div';\n  var value = selector || '';\n  /** @type {Properties} */\n\n  var props = {};\n  var start = 0;\n  /** @type {string} */\n\n  var subvalue;\n  /** @type {string} */\n\n  var previous;\n  /** @type {RegExpMatchArray} */\n\n  var match;\n\n  while (start < value.length) {\n    search.lastIndex = start;\n    match = search.exec(value);\n    subvalue = value.slice(start, match ? match.index : value.length);\n\n    if (subvalue) {\n      if (!previous) {\n        defaultTagName = subvalue;\n      } else if (previous === '#') {\n        props.id = subvalue;\n      } else if (Array.isArray(props.className)) {\n        props.className.push(subvalue);\n      } else {\n        props.className = [subvalue];\n      }\n\n      start += subvalue.length;\n    }\n\n    if (match) {\n      previous = match[0];\n      start++;\n    }\n  }\n\n  return {\n    type: 'element',\n    tagName: defaultTagName,\n    properties: props,\n    children: []\n  };\n};","map":{"version":3,"names":["search","parseSelector","selector","defaultTagName","value","props","start","subvalue","previous","match","length","lastIndex","exec","slice","index","id","Array","isArray","className","push","type","tagName","properties","children"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/hast-util-parse-selector/index.js"],"sourcesContent":["/**\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Element} Element\n */\n\nvar search = /[#.]/g\n\n/**\n * Create a hast element from a simple CSS selector.\n *\n * @param selector A simple CSS selector.\n *   Can contain a tag-name (`foo`), classes (`.bar`), and an ID (`#baz`).\n *   Multiple classes are allowed.\n *   Uses the last ID if multiple IDs are found.\n * @param [defaultTagName='div'] Tag name to use if `selector` does not specify one.\n */\nexport const parseSelector =\n  /**\n   * @type {(\n   *  <Selector extends string, DefaultTagName extends string = 'div'>(selector?: Selector, defaultTagName?: DefaultTagName) => Element & {tagName: import('./extract.js').ExtractTagName<Selector, DefaultTagName>}\n   * )}\n   */\n  (\n    /**\n     * @param {string} [selector]\n     * @param {string} [defaultTagName='div']\n     * @returns {Element}\n     */\n    function (selector, defaultTagName = 'div') {\n      var value = selector || ''\n      /** @type {Properties} */\n      var props = {}\n      var start = 0\n      /** @type {string} */\n      var subvalue\n      /** @type {string} */\n      var previous\n      /** @type {RegExpMatchArray} */\n      var match\n\n      while (start < value.length) {\n        search.lastIndex = start\n        match = search.exec(value)\n        subvalue = value.slice(start, match ? match.index : value.length)\n\n        if (subvalue) {\n          if (!previous) {\n            defaultTagName = subvalue\n          } else if (previous === '#') {\n            props.id = subvalue\n          } else if (Array.isArray(props.className)) {\n            props.className.push(subvalue)\n          } else {\n            props.className = [subvalue]\n          }\n\n          start += subvalue.length\n        }\n\n        if (match) {\n          previous = match[0]\n          start++\n        }\n      }\n\n      return {\n        type: 'element',\n        tagName: defaultTagName,\n        properties: props,\n        children: []\n      }\n    }\n  )\n"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,IAAIA,MAAM,GAAG,OAAb;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,aAAa;AACxB;AACF;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACI,UAAUC,QAAV,EAA4C;EAAA,IAAxBC,cAAwB,uEAAP,KAAO;EAC1C,IAAIC,KAAK,GAAGF,QAAQ,IAAI,EAAxB;EACA;;EACA,IAAIG,KAAK,GAAG,EAAZ;EACA,IAAIC,KAAK,GAAG,CAAZ;EACA;;EACA,IAAIC,QAAJ;EACA;;EACA,IAAIC,QAAJ;EACA;;EACA,IAAIC,KAAJ;;EAEA,OAAOH,KAAK,GAAGF,KAAK,CAACM,MAArB,EAA6B;IAC3BV,MAAM,CAACW,SAAP,GAAmBL,KAAnB;IACAG,KAAK,GAAGT,MAAM,CAACY,IAAP,CAAYR,KAAZ,CAAR;IACAG,QAAQ,GAAGH,KAAK,CAACS,KAAN,CAAYP,KAAZ,EAAmBG,KAAK,GAAGA,KAAK,CAACK,KAAT,GAAiBV,KAAK,CAACM,MAA/C,CAAX;;IAEA,IAAIH,QAAJ,EAAc;MACZ,IAAI,CAACC,QAAL,EAAe;QACbL,cAAc,GAAGI,QAAjB;MACD,CAFD,MAEO,IAAIC,QAAQ,KAAK,GAAjB,EAAsB;QAC3BH,KAAK,CAACU,EAAN,GAAWR,QAAX;MACD,CAFM,MAEA,IAAIS,KAAK,CAACC,OAAN,CAAcZ,KAAK,CAACa,SAApB,CAAJ,EAAoC;QACzCb,KAAK,CAACa,SAAN,CAAgBC,IAAhB,CAAqBZ,QAArB;MACD,CAFM,MAEA;QACLF,KAAK,CAACa,SAAN,GAAkB,CAACX,QAAD,CAAlB;MACD;;MAEDD,KAAK,IAAIC,QAAQ,CAACG,MAAlB;IACD;;IAED,IAAID,KAAJ,EAAW;MACTD,QAAQ,GAAGC,KAAK,CAAC,CAAD,CAAhB;MACAH,KAAK;IACN;EACF;;EAED,OAAO;IACLc,IAAI,EAAE,SADD;IAELC,OAAO,EAAElB,cAFJ;IAGLmB,UAAU,EAAEjB,KAHP;IAILkB,QAAQ,EAAE;EAJL,CAAP;AAMD,CAvDE"},"metadata":{},"sourceType":"module"}