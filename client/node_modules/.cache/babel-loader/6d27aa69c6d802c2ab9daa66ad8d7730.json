{"ast":null,"code":"import { parser } from '@lezer/xml';\nimport { syntaxTree, LRLanguage, indentNodeProp, foldNodeProp, LanguageSupport } from '@codemirror/language';\n\nfunction tagName(doc, tag) {\n  let name = tag && tag.getChild(\"TagName\");\n  return name ? doc.sliceString(name.from, name.to) : \"\";\n}\n\nfunction elementName(doc, tree) {\n  let tag = tree && tree.firstChild;\n  return !tag || tag.name != \"OpenTag\" ? \"\" : tagName(doc, tag);\n}\n\nfunction attrName(doc, tag, pos) {\n  let attr = tag && tag.getChildren(\"Attribute\").find(a => a.from <= pos && a.to >= pos);\n  let name = attr && attr.getChild(\"AttributeName\");\n  return name ? doc.sliceString(name.from, name.to) : \"\";\n}\n\nfunction findParentElement(tree) {\n  for (let cur = tree && tree.parent; cur; cur = cur.parent) if (cur.name == \"Element\") return cur;\n\n  return null;\n}\n\nfunction findLocation(state, pos) {\n  var _a;\n\n  let at = syntaxTree(state).resolveInner(pos, -1),\n      inTag = null;\n\n  for (let cur = at; !inTag && cur.parent; cur = cur.parent) if (cur.name == \"OpenTag\" || cur.name == \"CloseTag\" || cur.name == \"SelfClosingTag\" || cur.name == \"MismatchedCloseTag\") inTag = cur;\n\n  if (inTag && (inTag.to > pos || inTag.lastChild.type.isError)) {\n    let elt = inTag.parent;\n    if (at.name == \"TagName\") return inTag.name == \"CloseTag\" || inTag.name == \"MismatchedCloseTag\" ? {\n      type: \"closeTag\",\n      from: at.from,\n      context: elt\n    } : {\n      type: \"openTag\",\n      from: at.from,\n      context: findParentElement(elt)\n    };\n    if (at.name == \"AttributeName\") return {\n      type: \"attrName\",\n      from: at.from,\n      context: inTag\n    };\n    if (at.name == \"AttributeValue\") return {\n      type: \"attrValue\",\n      from: at.from,\n      context: inTag\n    };\n    let before = at == inTag || at.name == \"Attribute\" ? at.childBefore(pos) : at;\n    if ((before === null || before === void 0 ? void 0 : before.name) == \"StartTag\") return {\n      type: \"openTag\",\n      from: pos,\n      context: findParentElement(elt)\n    };\n    if ((before === null || before === void 0 ? void 0 : before.name) == \"StartCloseTag\" && before.to <= pos) return {\n      type: \"closeTag\",\n      from: pos,\n      context: elt\n    };\n    if ((before === null || before === void 0 ? void 0 : before.name) == \"Is\") return {\n      type: \"attrValue\",\n      from: pos,\n      context: inTag\n    };\n    if (before) return {\n      type: \"attrName\",\n      from: pos,\n      context: inTag\n    };\n    return null;\n  } else if (at.name == \"StartCloseTag\") {\n    return {\n      type: \"closeTag\",\n      from: pos,\n      context: at.parent\n    };\n  }\n\n  while (at.parent && at.to == pos && !((_a = at.lastChild) === null || _a === void 0 ? void 0 : _a.type.isError)) at = at.parent;\n\n  if (at.name == \"Element\" || at.name == \"Text\" || at.name == \"Document\") return {\n    type: \"tag\",\n    from: pos,\n    context: at.name == \"Element\" ? at : findParentElement(at)\n  };\n  return null;\n}\n\nclass Element {\n  constructor(spec, attrs, attrValues) {\n    this.attrs = attrs;\n    this.attrValues = attrValues;\n    this.children = [];\n    this.name = spec.name;\n    this.completion = Object.assign(Object.assign({\n      type: \"type\"\n    }, spec.completion || {}), {\n      label: this.name\n    });\n    this.openCompletion = Object.assign(Object.assign({}, this.completion), {\n      label: \"<\" + this.name\n    });\n    this.closeCompletion = Object.assign(Object.assign({}, this.completion), {\n      label: \"</\" + this.name + \">\",\n      boost: 2\n    });\n    this.closeNameCompletion = Object.assign(Object.assign({}, this.completion), {\n      label: this.name + \">\"\n    });\n    this.text = spec.textContent ? spec.textContent.map(s => ({\n      label: s,\n      type: \"text\"\n    })) : [];\n  }\n\n}\n\nconst Identifier = /^[:\\-\\.\\w\\u00b7-\\uffff]*$/;\n\nfunction attrCompletion(spec) {\n  return Object.assign(Object.assign({\n    type: \"property\"\n  }, spec.completion || {}), {\n    label: spec.name\n  });\n}\n\nfunction valueCompletion(spec) {\n  return typeof spec == \"string\" ? {\n    label: `\"${spec}\"`,\n    type: \"constant\"\n  } : /^\"/.test(spec.label) ? spec : Object.assign(Object.assign({}, spec), {\n    label: `\"${spec.label}\"`\n  });\n}\n/**\nCreate a completion source for the given schema.\n*/\n\n\nfunction completeFromSchema(eltSpecs, attrSpecs) {\n  let allAttrs = [],\n      globalAttrs = [];\n  let attrValues = Object.create(null);\n\n  for (let s of attrSpecs) {\n    let completion = attrCompletion(s);\n    allAttrs.push(completion);\n    if (s.global) globalAttrs.push(completion);\n    if (s.values) attrValues[s.name] = s.values.map(valueCompletion);\n  }\n\n  let allElements = [],\n      topElements = [];\n  let byName = Object.create(null);\n\n  for (let s of eltSpecs) {\n    let attrs = globalAttrs,\n        attrVals = attrValues;\n    if (s.attributes) attrs = attrs.concat(s.attributes.map(s => {\n      if (typeof s == \"string\") return allAttrs.find(a => a.label == s) || {\n        label: s,\n        type: \"property\"\n      };\n\n      if (s.values) {\n        if (attrVals == attrValues) attrVals = Object.create(attrVals);\n        attrVals[s.name] = s.values.map(valueCompletion);\n      }\n\n      return attrCompletion(s);\n    }));\n    let elt = new Element(s, attrs, attrVals);\n    byName[elt.name] = elt;\n    allElements.push(elt);\n    if (s.top) topElements.push(elt);\n  }\n\n  if (!topElements.length) topElements = allElements;\n\n  for (let i = 0; i < allElements.length; i++) {\n    let s = eltSpecs[i],\n        elt = allElements[i];\n\n    if (s.children) {\n      for (let ch of s.children) if (byName[ch]) elt.children.push(byName[ch]);\n    } else {\n      elt.children = allElements;\n    }\n  }\n\n  return cx => {\n    var _a;\n\n    let {\n      doc\n    } = cx.state,\n        loc = findLocation(cx.state, cx.pos);\n    if (!loc || loc.type == \"tag\" && !cx.explicit) return null;\n    let {\n      type,\n      from,\n      context\n    } = loc;\n\n    if (type == \"openTag\") {\n      let children = topElements;\n      let parentName = elementName(doc, context);\n\n      if (parentName) {\n        let parent = byName[parentName];\n        children = (parent === null || parent === void 0 ? void 0 : parent.children) || allElements;\n      }\n\n      return {\n        from,\n        options: children.map(ch => ch.completion),\n        validFor: Identifier\n      };\n    } else if (type == \"closeTag\") {\n      let parentName = elementName(doc, context);\n      return parentName ? {\n        from,\n        to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == \">\" ? 1 : 0),\n        options: [((_a = byName[parentName]) === null || _a === void 0 ? void 0 : _a.closeNameCompletion) || {\n          label: parentName + \">\",\n          type: \"type\"\n        }],\n        validFor: Identifier\n      } : null;\n    } else if (type == \"attrName\") {\n      let parent = byName[tagName(doc, context)];\n      return {\n        from,\n        options: (parent === null || parent === void 0 ? void 0 : parent.attrs) || globalAttrs,\n        validFor: Identifier\n      };\n    } else if (type == \"attrValue\") {\n      let attr = attrName(doc, context, from);\n      if (!attr) return null;\n      let parent = byName[tagName(doc, context)];\n      let values = ((parent === null || parent === void 0 ? void 0 : parent.attrValues) || attrValues)[attr];\n      if (!values || !values.length) return null;\n      return {\n        from,\n        to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == '\"' ? 1 : 0),\n        options: values,\n        validFor: /^\"[^\"]*\"?$/\n      };\n    } else if (type == \"tag\") {\n      let parentName = elementName(doc, context),\n          parent = byName[parentName];\n      let closing = [],\n          last = context && context.lastChild;\n      if (parentName && (!last || last.name != \"CloseTag\" || tagName(doc, last) != parentName)) closing.push(parent ? parent.closeCompletion : {\n        label: \"</\" + parentName + \">\",\n        type: \"type\",\n        boost: 2\n      });\n      let options = closing.concat(((parent === null || parent === void 0 ? void 0 : parent.children) || (context ? allElements : topElements)).map(e => e.openCompletion));\n\n      if (context && (parent === null || parent === void 0 ? void 0 : parent.text.length)) {\n        let openTag = context.firstChild;\n        if (openTag.to > cx.pos - 20 && !/\\S/.test(cx.state.sliceDoc(openTag.to, cx.pos))) options = options.concat(parent.text);\n      }\n\n      return {\n        from,\n        options,\n        validFor: /^<\\/?[:\\-\\.\\w\\u00b7-\\uffff]*$/\n      };\n    } else {\n      return null;\n    }\n  };\n}\n/**\nA language provider based on the [Lezer XML\nparser](https://github.com/lezer-parser/xml), extended with\nhighlighting and indentation information.\n*/\n\n\nconst xmlLanguage = /*@__PURE__*/LRLanguage.define({\n  parser: /*@__PURE__*/parser.configure({\n    props: [/*@__PURE__*/indentNodeProp.add({\n      Element(context) {\n        let closed = /^\\s*<\\//.test(context.textAfter);\n        return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n      },\n\n      \"OpenTag CloseTag SelfClosingTag\"(context) {\n        return context.column(context.node.from) + context.unit;\n      }\n\n    }), /*@__PURE__*/foldNodeProp.add({\n      Element(subtree) {\n        let first = subtree.firstChild,\n            last = subtree.lastChild;\n        if (!first || first.name != \"OpenTag\") return null;\n        return {\n          from: first.to,\n          to: last.name == \"CloseTag\" ? last.from : subtree.to\n        };\n      }\n\n    })]\n  }),\n  languageData: {\n    commentTokens: {\n      block: {\n        open: \"<!--\",\n        close: \"-->\"\n      }\n    },\n    indentOnInput: /^\\s*<\\/$/\n  }\n});\n/**\nXML language support. Includes schema-based autocompletion when\nconfigured.\n*/\n\nfunction xml() {\n  let conf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return new LanguageSupport(xmlLanguage, xmlLanguage.data.of({\n    autocomplete: completeFromSchema(conf.elements || [], conf.attributes || [])\n  }));\n}\n\nexport { completeFromSchema, xml, xmlLanguage };","map":{"version":3,"names":["parser","syntaxTree","LRLanguage","indentNodeProp","foldNodeProp","LanguageSupport","tagName","doc","tag","name","getChild","sliceString","from","to","elementName","tree","firstChild","attrName","pos","attr","getChildren","find","a","findParentElement","cur","parent","findLocation","state","_a","at","resolveInner","inTag","lastChild","type","isError","elt","context","before","childBefore","Element","constructor","spec","attrs","attrValues","children","completion","Object","assign","label","openCompletion","closeCompletion","boost","closeNameCompletion","text","textContent","map","s","Identifier","attrCompletion","valueCompletion","test","completeFromSchema","eltSpecs","attrSpecs","allAttrs","globalAttrs","create","push","global","values","allElements","topElements","byName","attrVals","attributes","concat","top","length","i","ch","cx","loc","explicit","parentName","options","validFor","closing","last","e","openTag","sliceDoc","xmlLanguage","define","configure","props","add","closed","textAfter","lineIndent","node","unit","column","subtree","first","languageData","commentTokens","block","open","close","indentOnInput","xml","conf","data","of","autocomplete","elements"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/@codemirror/lang-xml/dist/index.js"],"sourcesContent":["import { parser } from '@lezer/xml';\nimport { syntaxTree, LRLanguage, indentNodeProp, foldNodeProp, LanguageSupport } from '@codemirror/language';\n\nfunction tagName(doc, tag) {\n    let name = tag && tag.getChild(\"TagName\");\n    return name ? doc.sliceString(name.from, name.to) : \"\";\n}\nfunction elementName(doc, tree) {\n    let tag = tree && tree.firstChild;\n    return !tag || tag.name != \"OpenTag\" ? \"\" : tagName(doc, tag);\n}\nfunction attrName(doc, tag, pos) {\n    let attr = tag && tag.getChildren(\"Attribute\").find(a => a.from <= pos && a.to >= pos);\n    let name = attr && attr.getChild(\"AttributeName\");\n    return name ? doc.sliceString(name.from, name.to) : \"\";\n}\nfunction findParentElement(tree) {\n    for (let cur = tree && tree.parent; cur; cur = cur.parent)\n        if (cur.name == \"Element\")\n            return cur;\n    return null;\n}\nfunction findLocation(state, pos) {\n    var _a;\n    let at = syntaxTree(state).resolveInner(pos, -1), inTag = null;\n    for (let cur = at; !inTag && cur.parent; cur = cur.parent)\n        if (cur.name == \"OpenTag\" || cur.name == \"CloseTag\" || cur.name == \"SelfClosingTag\" || cur.name == \"MismatchedCloseTag\")\n            inTag = cur;\n    if (inTag && (inTag.to > pos || inTag.lastChild.type.isError)) {\n        let elt = inTag.parent;\n        if (at.name == \"TagName\")\n            return inTag.name == \"CloseTag\" || inTag.name == \"MismatchedCloseTag\"\n                ? { type: \"closeTag\", from: at.from, context: elt }\n                : { type: \"openTag\", from: at.from, context: findParentElement(elt) };\n        if (at.name == \"AttributeName\")\n            return { type: \"attrName\", from: at.from, context: inTag };\n        if (at.name == \"AttributeValue\")\n            return { type: \"attrValue\", from: at.from, context: inTag };\n        let before = at == inTag || at.name == \"Attribute\" ? at.childBefore(pos) : at;\n        if ((before === null || before === void 0 ? void 0 : before.name) == \"StartTag\")\n            return { type: \"openTag\", from: pos, context: findParentElement(elt) };\n        if ((before === null || before === void 0 ? void 0 : before.name) == \"StartCloseTag\" && before.to <= pos)\n            return { type: \"closeTag\", from: pos, context: elt };\n        if ((before === null || before === void 0 ? void 0 : before.name) == \"Is\")\n            return { type: \"attrValue\", from: pos, context: inTag };\n        if (before)\n            return { type: \"attrName\", from: pos, context: inTag };\n        return null;\n    }\n    else if (at.name == \"StartCloseTag\") {\n        return { type: \"closeTag\", from: pos, context: at.parent };\n    }\n    while (at.parent && at.to == pos && !((_a = at.lastChild) === null || _a === void 0 ? void 0 : _a.type.isError))\n        at = at.parent;\n    if (at.name == \"Element\" || at.name == \"Text\" || at.name == \"Document\")\n        return { type: \"tag\", from: pos, context: at.name == \"Element\" ? at : findParentElement(at) };\n    return null;\n}\nclass Element {\n    constructor(spec, attrs, attrValues) {\n        this.attrs = attrs;\n        this.attrValues = attrValues;\n        this.children = [];\n        this.name = spec.name;\n        this.completion = Object.assign(Object.assign({ type: \"type\" }, spec.completion || {}), { label: this.name });\n        this.openCompletion = Object.assign(Object.assign({}, this.completion), { label: \"<\" + this.name });\n        this.closeCompletion = Object.assign(Object.assign({}, this.completion), { label: \"</\" + this.name + \">\", boost: 2 });\n        this.closeNameCompletion = Object.assign(Object.assign({}, this.completion), { label: this.name + \">\" });\n        this.text = spec.textContent ? spec.textContent.map(s => ({ label: s, type: \"text\" })) : [];\n    }\n}\nconst Identifier = /^[:\\-\\.\\w\\u00b7-\\uffff]*$/;\nfunction attrCompletion(spec) {\n    return Object.assign(Object.assign({ type: \"property\" }, spec.completion || {}), { label: spec.name });\n}\nfunction valueCompletion(spec) {\n    return typeof spec == \"string\" ? { label: `\"${spec}\"`, type: \"constant\" }\n        : /^\"/.test(spec.label) ? spec\n            : Object.assign(Object.assign({}, spec), { label: `\"${spec.label}\"` });\n}\n/**\nCreate a completion source for the given schema.\n*/\nfunction completeFromSchema(eltSpecs, attrSpecs) {\n    let allAttrs = [], globalAttrs = [];\n    let attrValues = Object.create(null);\n    for (let s of attrSpecs) {\n        let completion = attrCompletion(s);\n        allAttrs.push(completion);\n        if (s.global)\n            globalAttrs.push(completion);\n        if (s.values)\n            attrValues[s.name] = s.values.map(valueCompletion);\n    }\n    let allElements = [], topElements = [];\n    let byName = Object.create(null);\n    for (let s of eltSpecs) {\n        let attrs = globalAttrs, attrVals = attrValues;\n        if (s.attributes)\n            attrs = attrs.concat(s.attributes.map(s => {\n                if (typeof s == \"string\")\n                    return allAttrs.find(a => a.label == s) || { label: s, type: \"property\" };\n                if (s.values) {\n                    if (attrVals == attrValues)\n                        attrVals = Object.create(attrVals);\n                    attrVals[s.name] = s.values.map(valueCompletion);\n                }\n                return attrCompletion(s);\n            }));\n        let elt = new Element(s, attrs, attrVals);\n        byName[elt.name] = elt;\n        allElements.push(elt);\n        if (s.top)\n            topElements.push(elt);\n    }\n    if (!topElements.length)\n        topElements = allElements;\n    for (let i = 0; i < allElements.length; i++) {\n        let s = eltSpecs[i], elt = allElements[i];\n        if (s.children) {\n            for (let ch of s.children)\n                if (byName[ch])\n                    elt.children.push(byName[ch]);\n        }\n        else {\n            elt.children = allElements;\n        }\n    }\n    return cx => {\n        var _a;\n        let { doc } = cx.state, loc = findLocation(cx.state, cx.pos);\n        if (!loc || (loc.type == \"tag\" && !cx.explicit))\n            return null;\n        let { type, from, context } = loc;\n        if (type == \"openTag\") {\n            let children = topElements;\n            let parentName = elementName(doc, context);\n            if (parentName) {\n                let parent = byName[parentName];\n                children = (parent === null || parent === void 0 ? void 0 : parent.children) || allElements;\n            }\n            return {\n                from,\n                options: children.map(ch => ch.completion),\n                validFor: Identifier\n            };\n        }\n        else if (type == \"closeTag\") {\n            let parentName = elementName(doc, context);\n            return parentName ? {\n                from,\n                to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == \">\" ? 1 : 0),\n                options: [((_a = byName[parentName]) === null || _a === void 0 ? void 0 : _a.closeNameCompletion) || { label: parentName + \">\", type: \"type\" }],\n                validFor: Identifier\n            } : null;\n        }\n        else if (type == \"attrName\") {\n            let parent = byName[tagName(doc, context)];\n            return {\n                from,\n                options: (parent === null || parent === void 0 ? void 0 : parent.attrs) || globalAttrs,\n                validFor: Identifier\n            };\n        }\n        else if (type == \"attrValue\") {\n            let attr = attrName(doc, context, from);\n            if (!attr)\n                return null;\n            let parent = byName[tagName(doc, context)];\n            let values = ((parent === null || parent === void 0 ? void 0 : parent.attrValues) || attrValues)[attr];\n            if (!values || !values.length)\n                return null;\n            return {\n                from,\n                to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == '\"' ? 1 : 0),\n                options: values,\n                validFor: /^\"[^\"]*\"?$/\n            };\n        }\n        else if (type == \"tag\") {\n            let parentName = elementName(doc, context), parent = byName[parentName];\n            let closing = [], last = context && context.lastChild;\n            if (parentName && (!last || last.name != \"CloseTag\" || tagName(doc, last) != parentName))\n                closing.push(parent ? parent.closeCompletion : { label: \"</\" + parentName + \">\", type: \"type\", boost: 2 });\n            let options = closing.concat(((parent === null || parent === void 0 ? void 0 : parent.children) || (context ? allElements : topElements)).map(e => e.openCompletion));\n            if (context && (parent === null || parent === void 0 ? void 0 : parent.text.length)) {\n                let openTag = context.firstChild;\n                if (openTag.to > cx.pos - 20 && !/\\S/.test(cx.state.sliceDoc(openTag.to, cx.pos)))\n                    options = options.concat(parent.text);\n            }\n            return {\n                from,\n                options,\n                validFor: /^<\\/?[:\\-\\.\\w\\u00b7-\\uffff]*$/\n            };\n        }\n        else {\n            return null;\n        }\n    };\n}\n\n/**\nA language provider based on the [Lezer XML\nparser](https://github.com/lezer-parser/xml), extended with\nhighlighting and indentation information.\n*/\nconst xmlLanguage = /*@__PURE__*/LRLanguage.define({\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/indentNodeProp.add({\n                Element(context) {\n                    let closed = /^\\s*<\\//.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                \"OpenTag CloseTag SelfClosingTag\"(context) {\n                    return context.column(context.node.from) + context.unit;\n                }\n            }),\n            /*@__PURE__*/foldNodeProp.add({\n                Element(subtree) {\n                    let first = subtree.firstChild, last = subtree.lastChild;\n                    if (!first || first.name != \"OpenTag\")\n                        return null;\n                    return { from: first.to, to: last.name == \"CloseTag\" ? last.from : subtree.to };\n                }\n            })\n        ]\n    }),\n    languageData: {\n        commentTokens: { block: { open: \"<!--\", close: \"-->\" } },\n        indentOnInput: /^\\s*<\\/$/\n    }\n});\n/**\nXML language support. Includes schema-based autocompletion when\nconfigured.\n*/\nfunction xml(conf = {}) {\n    return new LanguageSupport(xmlLanguage, xmlLanguage.data.of({\n        autocomplete: completeFromSchema(conf.elements || [], conf.attributes || [])\n    }));\n}\n\nexport { completeFromSchema, xml, xmlLanguage };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}