{"ast":null,"code":"/**\n * See <https://tools.ietf.org/html/rfc4647#section-3.1>\n * for more information on the algorithms.\n */\n\n/**\n * @typedef {string} Tag\n * @typedef {Array<Tag>} Tags\n * @typedef {string} Range\n * @typedef {Array<Range>} Ranges\n *\n * @callback Check\n * @param {Tag} tag\n * @param {Range} range\n * @returns {boolean}\n *\n * @typedef {FilterOrLookup<true>} Filter\n * @typedef {FilterOrLookup<false>} Lookup\n */\n\n/**\n * @template {boolean} IsFilter\n * @callback FilterOrLookup\n * @param {Tag|Tags} tags\n * @param {Range|Ranges} [ranges='*']\n * @returns {IsFilter extends true ? Tags : Tag|undefined}\n */\n\n/**\n * Factory to perform a filter or a lookup.\n * This factory creates a function that accepts a list of tags and a list of\n * ranges, and contains logic to exit early for lookups.\n * `check` just has to deal with one tag and one range.\n * This match function iterates over ranges, and for each range,\n * iterates over tags.  That way, earlier ranges matching any tag have\n * precedence over later ranges.\n *\n * @template {boolean} IsFilter\n * @param {Check} check\n * @param {IsFilter} filter\n * @returns {FilterOrLookup<IsFilter>}\n */\nfunction factory(check, filter) {\n  return function (tags, ranges) {\n    let left = cast(tags, 'tag');\n    const right = cast(ranges === null || ranges === undefined ? '*' : ranges, 'range');\n    /** @type {Tags} */\n\n    const matches = [];\n    let rightIndex = -1;\n\n    while (++rightIndex < right.length) {\n      const range = right[rightIndex].toLowerCase(); // Ignore wildcards in lookup mode.\n\n      if (!filter && range === '*') continue;\n      let leftIndex = -1;\n      /** @type {Tags} */\n\n      const next = [];\n\n      while (++leftIndex < left.length) {\n        if (check(left[leftIndex].toLowerCase(), range)) {\n          // Exit if this is a lookup and we have a match.\n          if (!filter) {\n            return (\n              /** @type {IsFilter extends true ? Tags : Tag|undefined} */\n              left[leftIndex]\n            );\n          }\n\n          matches.push(left[leftIndex]);\n        } else {\n          next.push(left[leftIndex]);\n        }\n      }\n\n      left = next;\n    } // If this is a filter, return the list.  If it’s a lookup, we didn’t find\n    // a match, so return `undefined`.\n\n\n    return (\n      /** @type {IsFilter extends true ? Tags : Tag|undefined} */\n      filter ? matches : undefined\n    );\n  };\n}\n/**\n * Basic Filtering (Section 3.3.1) matches a language priority list consisting\n * of basic language ranges (Section 2.1) to sets of language tags.\n */\n\n\nexport const basicFilter = factory(function (tag, range) {\n  return range === '*' || tag === range || tag.includes(range + '-');\n}, true);\n/**\n * Extended Filtering (Section 3.3.2) matches a language priority list\n * consisting of extended language ranges (Section 2.2) to sets of language\n * tags.\n */\n\nexport const extendedFilter = factory(function (tag, range) {\n  // 3.3.2.1\n  const left = tag.split('-');\n  const right = range.split('-');\n  let leftIndex = 0;\n  let rightIndex = 0; // 3.3.2.2\n\n  if (right[rightIndex] !== '*' && left[leftIndex] !== right[rightIndex]) {\n    return false;\n  }\n\n  leftIndex++;\n  rightIndex++; // 3.3.2.3\n\n  while (rightIndex < right.length) {\n    // 3.3.2.3.A\n    if (right[rightIndex] === '*') {\n      rightIndex++;\n      continue;\n    } // 3.3.2.3.B\n\n\n    if (!left[leftIndex]) return false; // 3.3.2.3.C\n\n    if (left[leftIndex] === right[rightIndex]) {\n      leftIndex++;\n      rightIndex++;\n      continue;\n    } // 3.3.2.3.D\n\n\n    if (left[leftIndex].length === 1) return false; // 3.3.2.3.E\n\n    leftIndex++;\n  } // 3.3.2.4\n\n\n  return true;\n}, true);\n/**\n * Lookup (Section 3.4) matches a language priority list consisting of basic\n * language ranges to sets of language tags to find the one exact language tag\n * that best matches the range.\n */\n\nexport const lookup = factory(function (tag, range) {\n  let right = range;\n  /* eslint-disable-next-line no-constant-condition */\n\n  while (true) {\n    if (right === '*' || tag === right) return true;\n    let index = right.lastIndexOf('-');\n    if (index < 0) return false;\n    if (right.charAt(index - 2) === '-') index -= 2;\n    right = right.slice(0, index);\n  }\n}, false);\n/**\n * Validate tags or ranges, and cast them to arrays.\n *\n * @param {string|Array<string>} values\n * @param {string} name\n * @returns {Array<string>}\n */\n\nfunction cast(values, name) {\n  const value = values && typeof values === 'string' ? [values] : values;\n\n  if (!value || typeof value !== 'object' || !('length' in value)) {\n    throw new Error('Invalid ' + name + ' `' + value + '`, expected non-empty string');\n  }\n\n  return value;\n}","map":{"version":3,"names":["factory","check","filter","tags","ranges","left","cast","right","undefined","matches","rightIndex","length","range","toLowerCase","leftIndex","next","push","basicFilter","tag","includes","extendedFilter","split","lookup","index","lastIndexOf","charAt","slice","values","name","value","Error"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/bcp-47-match/index.js"],"sourcesContent":["/**\n * See <https://tools.ietf.org/html/rfc4647#section-3.1>\n * for more information on the algorithms.\n */\n\n/**\n * @typedef {string} Tag\n * @typedef {Array<Tag>} Tags\n * @typedef {string} Range\n * @typedef {Array<Range>} Ranges\n *\n * @callback Check\n * @param {Tag} tag\n * @param {Range} range\n * @returns {boolean}\n *\n * @typedef {FilterOrLookup<true>} Filter\n * @typedef {FilterOrLookup<false>} Lookup\n */\n\n/**\n * @template {boolean} IsFilter\n * @callback FilterOrLookup\n * @param {Tag|Tags} tags\n * @param {Range|Ranges} [ranges='*']\n * @returns {IsFilter extends true ? Tags : Tag|undefined}\n */\n\n/**\n * Factory to perform a filter or a lookup.\n * This factory creates a function that accepts a list of tags and a list of\n * ranges, and contains logic to exit early for lookups.\n * `check` just has to deal with one tag and one range.\n * This match function iterates over ranges, and for each range,\n * iterates over tags.  That way, earlier ranges matching any tag have\n * precedence over later ranges.\n *\n * @template {boolean} IsFilter\n * @param {Check} check\n * @param {IsFilter} filter\n * @returns {FilterOrLookup<IsFilter>}\n */\nfunction factory(check, filter) {\n  return function (tags, ranges) {\n    let left = cast(tags, 'tag')\n    const right = cast(\n      ranges === null || ranges === undefined ? '*' : ranges,\n      'range'\n    )\n    /** @type {Tags} */\n    const matches = []\n    let rightIndex = -1\n\n    while (++rightIndex < right.length) {\n      const range = right[rightIndex].toLowerCase()\n\n      // Ignore wildcards in lookup mode.\n      if (!filter && range === '*') continue\n\n      let leftIndex = -1\n      /** @type {Tags} */\n      const next = []\n\n      while (++leftIndex < left.length) {\n        if (check(left[leftIndex].toLowerCase(), range)) {\n          // Exit if this is a lookup and we have a match.\n          if (!filter) {\n            return /** @type {IsFilter extends true ? Tags : Tag|undefined} */ (\n              left[leftIndex]\n            )\n          }\n\n          matches.push(left[leftIndex])\n        } else {\n          next.push(left[leftIndex])\n        }\n      }\n\n      left = next\n    }\n\n    // If this is a filter, return the list.  If it’s a lookup, we didn’t find\n    // a match, so return `undefined`.\n    return /** @type {IsFilter extends true ? Tags : Tag|undefined} */ (\n      filter ? matches : undefined\n    )\n  }\n}\n\n/**\n * Basic Filtering (Section 3.3.1) matches a language priority list consisting\n * of basic language ranges (Section 2.1) to sets of language tags.\n */\nexport const basicFilter = factory(function (tag, range) {\n  return range === '*' || tag === range || tag.includes(range + '-')\n}, true)\n\n/**\n * Extended Filtering (Section 3.3.2) matches a language priority list\n * consisting of extended language ranges (Section 2.2) to sets of language\n * tags.\n */\nexport const extendedFilter = factory(function (tag, range) {\n  // 3.3.2.1\n  const left = tag.split('-')\n  const right = range.split('-')\n  let leftIndex = 0\n  let rightIndex = 0\n\n  // 3.3.2.2\n  if (right[rightIndex] !== '*' && left[leftIndex] !== right[rightIndex]) {\n    return false\n  }\n\n  leftIndex++\n  rightIndex++\n\n  // 3.3.2.3\n  while (rightIndex < right.length) {\n    // 3.3.2.3.A\n    if (right[rightIndex] === '*') {\n      rightIndex++\n      continue\n    }\n\n    // 3.3.2.3.B\n    if (!left[leftIndex]) return false\n\n    // 3.3.2.3.C\n    if (left[leftIndex] === right[rightIndex]) {\n      leftIndex++\n      rightIndex++\n      continue\n    }\n\n    // 3.3.2.3.D\n    if (left[leftIndex].length === 1) return false\n\n    // 3.3.2.3.E\n    leftIndex++\n  }\n\n  // 3.3.2.4\n  return true\n}, true)\n\n/**\n * Lookup (Section 3.4) matches a language priority list consisting of basic\n * language ranges to sets of language tags to find the one exact language tag\n * that best matches the range.\n */\nexport const lookup = factory(function (tag, range) {\n  let right = range\n\n  /* eslint-disable-next-line no-constant-condition */\n  while (true) {\n    if (right === '*' || tag === right) return true\n\n    let index = right.lastIndexOf('-')\n\n    if (index < 0) return false\n\n    if (right.charAt(index - 2) === '-') index -= 2\n\n    right = right.slice(0, index)\n  }\n}, false)\n\n/**\n * Validate tags or ranges, and cast them to arrays.\n *\n * @param {string|Array<string>} values\n * @param {string} name\n * @returns {Array<string>}\n */\nfunction cast(values, name) {\n  const value = values && typeof values === 'string' ? [values] : values\n\n  if (!value || typeof value !== 'object' || !('length' in value)) {\n    throw new Error(\n      'Invalid ' + name + ' `' + value + '`, expected non-empty string'\n    )\n  }\n\n  return value\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}