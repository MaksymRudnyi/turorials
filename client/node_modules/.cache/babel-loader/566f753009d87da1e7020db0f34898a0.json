{"ast":null,"code":"function wordRegExp(words, end) {\n  return new RegExp((end ? \"\" : \"^\") + \"(?:\" + words.join(\"|\") + \")\" + (end ? \"$\" : \"\\\\b\"));\n}\n\nfunction chain(tokenize, stream, state) {\n  state.tokenize.push(tokenize);\n  return tokenize(stream, state);\n}\n\nvar operators = /^(?:[-+/%|&^]|\\*\\*?|[<>]{2})/;\nvar conditionalOperators = /^(?:[=!]~|===|<=>|[<>=!]=?|[|&]{2}|~)/;\nvar indexingOperators = /^(?:\\[\\][?=]?)/;\nvar anotherOperators = /^(?:\\.(?:\\.{2})?|->|[?:])/;\nvar idents = /^[a-z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\nvar types = /^[A-Z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\nvar keywords = wordRegExp([\"abstract\", \"alias\", \"as\", \"asm\", \"begin\", \"break\", \"case\", \"class\", \"def\", \"do\", \"else\", \"elsif\", \"end\", \"ensure\", \"enum\", \"extend\", \"for\", \"fun\", \"if\", \"include\", \"instance_sizeof\", \"lib\", \"macro\", \"module\", \"next\", \"of\", \"out\", \"pointerof\", \"private\", \"protected\", \"rescue\", \"return\", \"require\", \"select\", \"sizeof\", \"struct\", \"super\", \"then\", \"type\", \"typeof\", \"uninitialized\", \"union\", \"unless\", \"until\", \"when\", \"while\", \"with\", \"yield\", \"__DIR__\", \"__END_LINE__\", \"__FILE__\", \"__LINE__\"]);\nvar atomWords = wordRegExp([\"true\", \"false\", \"nil\", \"self\"]);\nvar indentKeywordsArray = [\"def\", \"fun\", \"macro\", \"class\", \"module\", \"struct\", \"lib\", \"enum\", \"union\", \"do\", \"for\"];\nvar indentKeywords = wordRegExp(indentKeywordsArray);\nvar indentExpressionKeywordsArray = [\"if\", \"unless\", \"case\", \"while\", \"until\", \"begin\", \"then\"];\nvar indentExpressionKeywords = wordRegExp(indentExpressionKeywordsArray);\nvar dedentKeywordsArray = [\"end\", \"else\", \"elsif\", \"rescue\", \"ensure\"];\nvar dedentKeywords = wordRegExp(dedentKeywordsArray);\nvar dedentPunctualsArray = [\"\\\\)\", \"\\\\}\", \"\\\\]\"];\nvar dedentPunctuals = new RegExp(\"^(?:\" + dedentPunctualsArray.join(\"|\") + \")$\");\nvar nextTokenizer = {\n  \"def\": tokenFollowIdent,\n  \"fun\": tokenFollowIdent,\n  \"macro\": tokenMacroDef,\n  \"class\": tokenFollowType,\n  \"module\": tokenFollowType,\n  \"struct\": tokenFollowType,\n  \"lib\": tokenFollowType,\n  \"enum\": tokenFollowType,\n  \"union\": tokenFollowType\n};\nvar matching = {\n  \"[\": \"]\",\n  \"{\": \"}\",\n  \"(\": \")\",\n  \"<\": \">\"\n};\n\nfunction tokenBase(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  } // Macros\n\n\n  if (state.lastToken != \"\\\\\" && stream.match(\"{%\", false)) {\n    return chain(tokenMacro(\"%\", \"%\"), stream, state);\n  }\n\n  if (state.lastToken != \"\\\\\" && stream.match(\"{{\", false)) {\n    return chain(tokenMacro(\"{\", \"}\"), stream, state);\n  } // Comments\n\n\n  if (stream.peek() == \"#\") {\n    stream.skipToEnd();\n    return \"comment\";\n  } // Variables and keywords\n\n\n  var matched;\n\n  if (stream.match(idents)) {\n    stream.eat(/[?!]/);\n    matched = stream.current();\n\n    if (stream.eat(\":\")) {\n      return \"atom\";\n    } else if (state.lastToken == \".\") {\n      return \"property\";\n    } else if (keywords.test(matched)) {\n      if (indentKeywords.test(matched)) {\n        if (!(matched == \"fun\" && state.blocks.indexOf(\"lib\") >= 0) && !(matched == \"def\" && state.lastToken == \"abstract\")) {\n          state.blocks.push(matched);\n          state.currentIndent += 1;\n        }\n      } else if ((state.lastStyle == \"operator\" || !state.lastStyle) && indentExpressionKeywords.test(matched)) {\n        state.blocks.push(matched);\n        state.currentIndent += 1;\n      } else if (matched == \"end\") {\n        state.blocks.pop();\n        state.currentIndent -= 1;\n      }\n\n      if (nextTokenizer.hasOwnProperty(matched)) {\n        state.tokenize.push(nextTokenizer[matched]);\n      }\n\n      return \"keyword\";\n    } else if (atomWords.test(matched)) {\n      return \"atom\";\n    }\n\n    return \"variable\";\n  } // Class variables and instance variables\n  // or attributes\n\n\n  if (stream.eat(\"@\")) {\n    if (stream.peek() == \"[\") {\n      return chain(tokenNest(\"[\", \"]\", \"meta\"), stream, state);\n    }\n\n    stream.eat(\"@\");\n    stream.match(idents) || stream.match(types);\n    return \"propertyName\";\n  } // Constants and types\n\n\n  if (stream.match(types)) {\n    return \"tag\";\n  } // Symbols or ':' operator\n\n\n  if (stream.eat(\":\")) {\n    if (stream.eat(\"\\\"\")) {\n      return chain(tokenQuote(\"\\\"\", \"atom\", false), stream, state);\n    } else if (stream.match(idents) || stream.match(types) || stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators)) {\n      return \"atom\";\n    }\n\n    stream.eat(\":\");\n    return \"operator\";\n  } // Strings\n\n\n  if (stream.eat(\"\\\"\")) {\n    return chain(tokenQuote(\"\\\"\", \"string\", true), stream, state);\n  } // Strings or regexps or macro variables or '%' operator\n\n\n  if (stream.peek() == \"%\") {\n    var style = \"string\";\n    var embed = true;\n    var delim;\n\n    if (stream.match(\"%r\")) {\n      // Regexps\n      style = \"string.special\";\n      delim = stream.next();\n    } else if (stream.match(\"%w\")) {\n      embed = false;\n      delim = stream.next();\n    } else if (stream.match(\"%q\")) {\n      embed = false;\n      delim = stream.next();\n    } else {\n      if (delim = stream.match(/^%([^\\w\\s=])/)) {\n        delim = delim[1];\n      } else if (stream.match(/^%[a-zA-Z_\\u009F-\\uFFFF][\\w\\u009F-\\uFFFF]*/)) {\n        // Macro variables\n        return \"meta\";\n      } else if (stream.eat('%')) {\n        // '%' operator\n        return \"operator\";\n      }\n    }\n\n    if (matching.hasOwnProperty(delim)) {\n      delim = matching[delim];\n    }\n\n    return chain(tokenQuote(delim, style, embed), stream, state);\n  } // Here Docs\n\n\n  if (matched = stream.match(/^<<-('?)([A-Z]\\w*)\\1/)) {\n    return chain(tokenHereDoc(matched[2], !matched[1]), stream, state);\n  } // Characters\n\n\n  if (stream.eat(\"'\")) {\n    stream.match(/^(?:[^']|\\\\(?:[befnrtv0'\"]|[0-7]{3}|u(?:[0-9a-fA-F]{4}|\\{[0-9a-fA-F]{1,6}\\})))/);\n    stream.eat(\"'\");\n    return \"atom\";\n  } // Numbers\n\n\n  if (stream.eat(\"0\")) {\n    if (stream.eat(\"x\")) {\n      stream.match(/^[0-9a-fA-F_]+/);\n    } else if (stream.eat(\"o\")) {\n      stream.match(/^[0-7_]+/);\n    } else if (stream.eat(\"b\")) {\n      stream.match(/^[01_]+/);\n    }\n\n    return \"number\";\n  }\n\n  if (stream.eat(/^\\d/)) {\n    stream.match(/^[\\d_]*(?:\\.[\\d_]+)?(?:[eE][+-]?\\d+)?/);\n    return \"number\";\n  } // Operators\n\n\n  if (stream.match(operators)) {\n    stream.eat(\"=\"); // Operators can follow assign symbol.\n\n    return \"operator\";\n  }\n\n  if (stream.match(conditionalOperators) || stream.match(anotherOperators)) {\n    return \"operator\";\n  } // Parens and braces\n\n\n  if (matched = stream.match(/[({[]/, false)) {\n    matched = matched[0];\n    return chain(tokenNest(matched, matching[matched], null), stream, state);\n  } // Escapes\n\n\n  if (stream.eat(\"\\\\\")) {\n    stream.next();\n    return \"meta\";\n  }\n\n  stream.next();\n  return null;\n}\n\nfunction tokenNest(begin, end, style, started) {\n  return function (stream, state) {\n    if (!started && stream.match(begin)) {\n      state.tokenize[state.tokenize.length - 1] = tokenNest(begin, end, style, true);\n      state.currentIndent += 1;\n      return style;\n    }\n\n    var nextStyle = tokenBase(stream, state);\n\n    if (stream.current() === end) {\n      state.tokenize.pop();\n      state.currentIndent -= 1;\n      nextStyle = style;\n    }\n\n    return nextStyle;\n  };\n}\n\nfunction tokenMacro(begin, end, started) {\n  return function (stream, state) {\n    if (!started && stream.match(\"{\" + begin)) {\n      state.currentIndent += 1;\n      state.tokenize[state.tokenize.length - 1] = tokenMacro(begin, end, true);\n      return \"meta\";\n    }\n\n    if (stream.match(end + \"}\")) {\n      state.currentIndent -= 1;\n      state.tokenize.pop();\n      return \"meta\";\n    }\n\n    return tokenBase(stream, state);\n  };\n}\n\nfunction tokenMacroDef(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  var matched;\n\n  if (matched = stream.match(idents)) {\n    if (matched == \"def\") {\n      return \"keyword\";\n    }\n\n    stream.eat(/[?!]/);\n  }\n\n  state.tokenize.pop();\n  return \"def\";\n}\n\nfunction tokenFollowIdent(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  if (stream.match(idents)) {\n    stream.eat(/[!?]/);\n  } else {\n    stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators);\n  }\n\n  state.tokenize.pop();\n  return \"def\";\n}\n\nfunction tokenFollowType(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  stream.match(types);\n  state.tokenize.pop();\n  return \"def\";\n}\n\nfunction tokenQuote(end, style, embed) {\n  return function (stream, state) {\n    var escaped = false;\n\n    while (stream.peek()) {\n      if (!escaped) {\n        if (stream.match(\"{%\", false)) {\n          state.tokenize.push(tokenMacro(\"%\", \"%\"));\n          return style;\n        }\n\n        if (stream.match(\"{{\", false)) {\n          state.tokenize.push(tokenMacro(\"{\", \"}\"));\n          return style;\n        }\n\n        if (embed && stream.match(\"#{\", false)) {\n          state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n          return style;\n        }\n\n        var ch = stream.next();\n\n        if (ch == end) {\n          state.tokenize.pop();\n          return style;\n        }\n\n        escaped = embed && ch == \"\\\\\";\n      } else {\n        stream.next();\n        escaped = false;\n      }\n    }\n\n    return style;\n  };\n}\n\nfunction tokenHereDoc(phrase, embed) {\n  return function (stream, state) {\n    if (stream.sol()) {\n      stream.eatSpace();\n\n      if (stream.match(phrase)) {\n        state.tokenize.pop();\n        return \"string\";\n      }\n    }\n\n    var escaped = false;\n\n    while (stream.peek()) {\n      if (!escaped) {\n        if (stream.match(\"{%\", false)) {\n          state.tokenize.push(tokenMacro(\"%\", \"%\"));\n          return \"string\";\n        }\n\n        if (stream.match(\"{{\", false)) {\n          state.tokenize.push(tokenMacro(\"{\", \"}\"));\n          return \"string\";\n        }\n\n        if (embed && stream.match(\"#{\", false)) {\n          state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n          return \"string\";\n        }\n\n        escaped = embed && stream.next() == \"\\\\\";\n      } else {\n        stream.next();\n        escaped = false;\n      }\n    }\n\n    return \"string\";\n  };\n}\n\nexport const crystal = {\n  startState: function () {\n    return {\n      tokenize: [tokenBase],\n      currentIndent: 0,\n      lastToken: null,\n      lastStyle: null,\n      blocks: []\n    };\n  },\n  token: function (stream, state) {\n    var style = state.tokenize[state.tokenize.length - 1](stream, state);\n    var token = stream.current();\n\n    if (style && style != \"comment\") {\n      state.lastToken = token;\n      state.lastStyle = style;\n    }\n\n    return style;\n  },\n  indent: function (state, textAfter, cx) {\n    textAfter = textAfter.replace(/^\\s*(?:\\{%)?\\s*|\\s*(?:%\\})?\\s*$/g, \"\");\n\n    if (dedentKeywords.test(textAfter) || dedentPunctuals.test(textAfter)) {\n      return cx.unit * (state.currentIndent - 1);\n    }\n\n    return cx.unit * state.currentIndent;\n  },\n  languageData: {\n    indentOnInput: wordRegExp(dedentPunctualsArray.concat(dedentKeywordsArray), true),\n    commentTokens: {\n      line: \"#\"\n    }\n  }\n};","map":{"version":3,"names":["wordRegExp","words","end","RegExp","join","chain","tokenize","stream","state","push","operators","conditionalOperators","indexingOperators","anotherOperators","idents","types","keywords","atomWords","indentKeywordsArray","indentKeywords","indentExpressionKeywordsArray","indentExpressionKeywords","dedentKeywordsArray","dedentKeywords","dedentPunctualsArray","dedentPunctuals","nextTokenizer","tokenFollowIdent","tokenMacroDef","tokenFollowType","matching","tokenBase","eatSpace","lastToken","match","tokenMacro","peek","skipToEnd","matched","eat","current","test","blocks","indexOf","currentIndent","lastStyle","pop","hasOwnProperty","tokenNest","tokenQuote","style","embed","delim","next","tokenHereDoc","begin","started","length","nextStyle","escaped","ch","phrase","sol","crystal","startState","token","indent","textAfter","cx","replace","unit","languageData","indentOnInput","concat","commentTokens","line"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/@codemirror/legacy-modes/mode/crystal.js"],"sourcesContent":["function wordRegExp(words, end) {\n  return new RegExp((end ? \"\" : \"^\") + \"(?:\" + words.join(\"|\") + \")\" + (end ? \"$\" : \"\\\\b\"));\n}\n\nfunction chain(tokenize, stream, state) {\n  state.tokenize.push(tokenize);\n  return tokenize(stream, state);\n}\n\nvar operators = /^(?:[-+/%|&^]|\\*\\*?|[<>]{2})/;\nvar conditionalOperators = /^(?:[=!]~|===|<=>|[<>=!]=?|[|&]{2}|~)/;\nvar indexingOperators = /^(?:\\[\\][?=]?)/;\nvar anotherOperators = /^(?:\\.(?:\\.{2})?|->|[?:])/;\nvar idents = /^[a-z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\nvar types = /^[A-Z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\nvar keywords = wordRegExp([\n  \"abstract\", \"alias\", \"as\", \"asm\", \"begin\", \"break\", \"case\", \"class\", \"def\", \"do\",\n  \"else\", \"elsif\", \"end\", \"ensure\", \"enum\", \"extend\", \"for\", \"fun\", \"if\",\n  \"include\", \"instance_sizeof\", \"lib\", \"macro\", \"module\", \"next\", \"of\", \"out\", \"pointerof\",\n  \"private\", \"protected\", \"rescue\", \"return\", \"require\", \"select\", \"sizeof\", \"struct\",\n  \"super\", \"then\", \"type\", \"typeof\", \"uninitialized\", \"union\", \"unless\", \"until\", \"when\", \"while\", \"with\",\n  \"yield\", \"__DIR__\", \"__END_LINE__\", \"__FILE__\", \"__LINE__\"\n]);\nvar atomWords = wordRegExp([\"true\", \"false\", \"nil\", \"self\"]);\nvar indentKeywordsArray = [\n  \"def\", \"fun\", \"macro\",\n  \"class\", \"module\", \"struct\", \"lib\", \"enum\", \"union\",\n  \"do\", \"for\"\n];\nvar indentKeywords = wordRegExp(indentKeywordsArray);\nvar indentExpressionKeywordsArray = [\"if\", \"unless\", \"case\", \"while\", \"until\", \"begin\", \"then\"];\nvar indentExpressionKeywords = wordRegExp(indentExpressionKeywordsArray);\nvar dedentKeywordsArray = [\"end\", \"else\", \"elsif\", \"rescue\", \"ensure\"];\nvar dedentKeywords = wordRegExp(dedentKeywordsArray);\nvar dedentPunctualsArray = [\"\\\\)\", \"\\\\}\", \"\\\\]\"];\nvar dedentPunctuals = new RegExp(\"^(?:\" + dedentPunctualsArray.join(\"|\") + \")$\");\nvar nextTokenizer = {\n  \"def\": tokenFollowIdent, \"fun\": tokenFollowIdent, \"macro\": tokenMacroDef,\n  \"class\": tokenFollowType, \"module\": tokenFollowType, \"struct\": tokenFollowType,\n  \"lib\": tokenFollowType, \"enum\": tokenFollowType, \"union\": tokenFollowType\n};\nvar matching = {\"[\": \"]\", \"{\": \"}\", \"(\": \")\", \"<\": \">\"};\n\nfunction tokenBase(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  // Macros\n  if (state.lastToken != \"\\\\\" && stream.match(\"{%\", false)) {\n    return chain(tokenMacro(\"%\", \"%\"), stream, state);\n  }\n\n  if (state.lastToken != \"\\\\\" && stream.match(\"{{\", false)) {\n    return chain(tokenMacro(\"{\", \"}\"), stream, state);\n  }\n\n  // Comments\n  if (stream.peek() == \"#\") {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  // Variables and keywords\n  var matched;\n  if (stream.match(idents)) {\n    stream.eat(/[?!]/);\n\n    matched = stream.current();\n    if (stream.eat(\":\")) {\n      return \"atom\";\n    } else if (state.lastToken == \".\") {\n      return \"property\";\n    } else if (keywords.test(matched)) {\n      if (indentKeywords.test(matched)) {\n        if (!(matched == \"fun\" && state.blocks.indexOf(\"lib\") >= 0) && !(matched == \"def\" && state.lastToken == \"abstract\")) {\n          state.blocks.push(matched);\n          state.currentIndent += 1;\n        }\n      } else if ((state.lastStyle == \"operator\" || !state.lastStyle) && indentExpressionKeywords.test(matched)) {\n        state.blocks.push(matched);\n        state.currentIndent += 1;\n      } else if (matched == \"end\") {\n        state.blocks.pop();\n        state.currentIndent -= 1;\n      }\n\n      if (nextTokenizer.hasOwnProperty(matched)) {\n        state.tokenize.push(nextTokenizer[matched]);\n      }\n\n      return \"keyword\";\n    } else if (atomWords.test(matched)) {\n      return \"atom\";\n    }\n\n    return \"variable\";\n  }\n\n  // Class variables and instance variables\n  // or attributes\n  if (stream.eat(\"@\")) {\n    if (stream.peek() == \"[\") {\n      return chain(tokenNest(\"[\", \"]\", \"meta\"), stream, state);\n    }\n\n    stream.eat(\"@\");\n    stream.match(idents) || stream.match(types);\n    return \"propertyName\";\n  }\n\n  // Constants and types\n  if (stream.match(types)) {\n    return \"tag\";\n  }\n\n  // Symbols or ':' operator\n  if (stream.eat(\":\")) {\n    if (stream.eat(\"\\\"\")) {\n      return chain(tokenQuote(\"\\\"\", \"atom\", false), stream, state);\n    } else if (stream.match(idents) || stream.match(types) ||\n               stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators)) {\n      return \"atom\";\n    }\n    stream.eat(\":\");\n    return \"operator\";\n  }\n\n  // Strings\n  if (stream.eat(\"\\\"\")) {\n    return chain(tokenQuote(\"\\\"\", \"string\", true), stream, state);\n  }\n\n  // Strings or regexps or macro variables or '%' operator\n  if (stream.peek() == \"%\") {\n    var style = \"string\";\n    var embed = true;\n    var delim;\n\n    if (stream.match(\"%r\")) {\n      // Regexps\n      style = \"string.special\";\n      delim = stream.next();\n    } else if (stream.match(\"%w\")) {\n      embed = false;\n      delim = stream.next();\n    } else if (stream.match(\"%q\")) {\n      embed = false;\n      delim = stream.next();\n    } else {\n      if(delim = stream.match(/^%([^\\w\\s=])/)) {\n        delim = delim[1];\n      } else if (stream.match(/^%[a-zA-Z_\\u009F-\\uFFFF][\\w\\u009F-\\uFFFF]*/)) {\n        // Macro variables\n        return \"meta\";\n      } else if (stream.eat('%')) {\n        // '%' operator\n        return \"operator\";\n      }\n    }\n\n    if (matching.hasOwnProperty(delim)) {\n      delim = matching[delim];\n    }\n    return chain(tokenQuote(delim, style, embed), stream, state);\n  }\n\n  // Here Docs\n  if (matched = stream.match(/^<<-('?)([A-Z]\\w*)\\1/)) {\n    return chain(tokenHereDoc(matched[2], !matched[1]), stream, state)\n  }\n\n  // Characters\n  if (stream.eat(\"'\")) {\n    stream.match(/^(?:[^']|\\\\(?:[befnrtv0'\"]|[0-7]{3}|u(?:[0-9a-fA-F]{4}|\\{[0-9a-fA-F]{1,6}\\})))/);\n    stream.eat(\"'\");\n    return \"atom\";\n  }\n\n  // Numbers\n  if (stream.eat(\"0\")) {\n    if (stream.eat(\"x\")) {\n      stream.match(/^[0-9a-fA-F_]+/);\n    } else if (stream.eat(\"o\")) {\n      stream.match(/^[0-7_]+/);\n    } else if (stream.eat(\"b\")) {\n      stream.match(/^[01_]+/);\n    }\n    return \"number\";\n  }\n\n  if (stream.eat(/^\\d/)) {\n    stream.match(/^[\\d_]*(?:\\.[\\d_]+)?(?:[eE][+-]?\\d+)?/);\n    return \"number\";\n  }\n\n  // Operators\n  if (stream.match(operators)) {\n    stream.eat(\"=\"); // Operators can follow assign symbol.\n    return \"operator\";\n  }\n\n  if (stream.match(conditionalOperators) || stream.match(anotherOperators)) {\n    return \"operator\";\n  }\n\n  // Parens and braces\n  if (matched = stream.match(/[({[]/, false)) {\n    matched = matched[0];\n    return chain(tokenNest(matched, matching[matched], null), stream, state);\n  }\n\n  // Escapes\n  if (stream.eat(\"\\\\\")) {\n    stream.next();\n    return \"meta\";\n  }\n\n  stream.next();\n  return null;\n}\n\nfunction tokenNest(begin, end, style, started) {\n  return function (stream, state) {\n    if (!started && stream.match(begin)) {\n      state.tokenize[state.tokenize.length - 1] = tokenNest(begin, end, style, true);\n      state.currentIndent += 1;\n      return style;\n    }\n\n    var nextStyle = tokenBase(stream, state);\n    if (stream.current() === end) {\n      state.tokenize.pop();\n      state.currentIndent -= 1;\n      nextStyle = style;\n    }\n\n    return nextStyle;\n  };\n}\n\nfunction tokenMacro(begin, end, started) {\n  return function (stream, state) {\n    if (!started && stream.match(\"{\" + begin)) {\n      state.currentIndent += 1;\n      state.tokenize[state.tokenize.length - 1] = tokenMacro(begin, end, true);\n      return \"meta\";\n    }\n\n    if (stream.match(end + \"}\")) {\n      state.currentIndent -= 1;\n      state.tokenize.pop();\n      return \"meta\";\n    }\n\n    return tokenBase(stream, state);\n  };\n}\n\nfunction tokenMacroDef(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  var matched;\n  if (matched = stream.match(idents)) {\n    if (matched == \"def\") {\n      return \"keyword\";\n    }\n    stream.eat(/[?!]/);\n  }\n\n  state.tokenize.pop();\n  return \"def\";\n}\n\nfunction tokenFollowIdent(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  if (stream.match(idents)) {\n    stream.eat(/[!?]/);\n  } else {\n    stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators);\n  }\n  state.tokenize.pop();\n  return \"def\";\n}\n\nfunction tokenFollowType(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  stream.match(types);\n  state.tokenize.pop();\n  return \"def\";\n}\n\nfunction tokenQuote(end, style, embed) {\n  return function (stream, state) {\n    var escaped = false;\n\n    while (stream.peek()) {\n      if (!escaped) {\n        if (stream.match(\"{%\", false)) {\n          state.tokenize.push(tokenMacro(\"%\", \"%\"));\n          return style;\n        }\n\n        if (stream.match(\"{{\", false)) {\n          state.tokenize.push(tokenMacro(\"{\", \"}\"));\n          return style;\n        }\n\n        if (embed && stream.match(\"#{\", false)) {\n          state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n          return style;\n        }\n\n        var ch = stream.next();\n\n        if (ch == end) {\n          state.tokenize.pop();\n          return style;\n        }\n\n        escaped = embed && ch == \"\\\\\";\n      } else {\n        stream.next();\n        escaped = false;\n      }\n    }\n\n    return style;\n  };\n}\n\nfunction tokenHereDoc(phrase, embed) {\n  return function (stream, state) {\n    if (stream.sol()) {\n      stream.eatSpace()\n      if (stream.match(phrase)) {\n        state.tokenize.pop();\n        return \"string\";\n      }\n    }\n\n    var escaped = false;\n    while (stream.peek()) {\n      if (!escaped) {\n        if (stream.match(\"{%\", false)) {\n          state.tokenize.push(tokenMacro(\"%\", \"%\"));\n          return \"string\";\n        }\n\n        if (stream.match(\"{{\", false)) {\n          state.tokenize.push(tokenMacro(\"{\", \"}\"));\n          return \"string\";\n        }\n\n        if (embed && stream.match(\"#{\", false)) {\n          state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n          return \"string\";\n        }\n\n        escaped = embed && stream.next() == \"\\\\\";\n      } else {\n        stream.next();\n        escaped = false;\n      }\n    }\n\n    return \"string\";\n  }\n}\n\nexport const crystal = {\n  startState: function () {\n    return {\n      tokenize: [tokenBase],\n      currentIndent: 0,\n      lastToken: null,\n      lastStyle: null,\n      blocks: []\n    };\n  },\n\n  token: function (stream, state) {\n    var style = state.tokenize[state.tokenize.length - 1](stream, state);\n    var token = stream.current();\n\n    if (style && style != \"comment\") {\n      state.lastToken = token;\n      state.lastStyle = style;\n    }\n\n    return style;\n  },\n\n  indent: function (state, textAfter, cx) {\n    textAfter = textAfter.replace(/^\\s*(?:\\{%)?\\s*|\\s*(?:%\\})?\\s*$/g, \"\");\n\n    if (dedentKeywords.test(textAfter) || dedentPunctuals.test(textAfter)) {\n      return cx.unit * (state.currentIndent - 1);\n    }\n\n    return cx.unit * state.currentIndent;\n  },\n\n  languageData: {\n    indentOnInput: wordRegExp(dedentPunctualsArray.concat(dedentKeywordsArray), true),\n    commentTokens: {line: \"#\"}\n  }\n};\n"],"mappings":"AAAA,SAASA,UAAT,CAAoBC,KAApB,EAA2BC,GAA3B,EAAgC;EAC9B,OAAO,IAAIC,MAAJ,CAAW,CAACD,GAAG,GAAG,EAAH,GAAQ,GAAZ,IAAmB,KAAnB,GAA2BD,KAAK,CAACG,IAAN,CAAW,GAAX,CAA3B,GAA6C,GAA7C,IAAoDF,GAAG,GAAG,GAAH,GAAS,KAAhE,CAAX,CAAP;AACD;;AAED,SAASG,KAAT,CAAeC,QAAf,EAAyBC,MAAzB,EAAiCC,KAAjC,EAAwC;EACtCA,KAAK,CAACF,QAAN,CAAeG,IAAf,CAAoBH,QAApB;EACA,OAAOA,QAAQ,CAACC,MAAD,EAASC,KAAT,CAAf;AACD;;AAED,IAAIE,SAAS,GAAG,8BAAhB;AACA,IAAIC,oBAAoB,GAAG,uCAA3B;AACA,IAAIC,iBAAiB,GAAG,gBAAxB;AACA,IAAIC,gBAAgB,GAAG,2BAAvB;AACA,IAAIC,MAAM,GAAG,gDAAb;AACA,IAAIC,KAAK,GAAG,gDAAZ;AACA,IAAIC,QAAQ,GAAGhB,UAAU,CAAC,CACxB,UADwB,EACZ,OADY,EACH,IADG,EACG,KADH,EACU,OADV,EACmB,OADnB,EAC4B,MAD5B,EACoC,OADpC,EAC6C,KAD7C,EACoD,IADpD,EAExB,MAFwB,EAEhB,OAFgB,EAEP,KAFO,EAEA,QAFA,EAEU,MAFV,EAEkB,QAFlB,EAE4B,KAF5B,EAEmC,KAFnC,EAE0C,IAF1C,EAGxB,SAHwB,EAGb,iBAHa,EAGM,KAHN,EAGa,OAHb,EAGsB,QAHtB,EAGgC,MAHhC,EAGwC,IAHxC,EAG8C,KAH9C,EAGqD,WAHrD,EAIxB,SAJwB,EAIb,WAJa,EAIA,QAJA,EAIU,QAJV,EAIoB,SAJpB,EAI+B,QAJ/B,EAIyC,QAJzC,EAImD,QAJnD,EAKxB,OALwB,EAKf,MALe,EAKP,MALO,EAKC,QALD,EAKW,eALX,EAK4B,OAL5B,EAKqC,QALrC,EAK+C,OAL/C,EAKwD,MALxD,EAKgE,OALhE,EAKyE,MALzE,EAMxB,OANwB,EAMf,SANe,EAMJ,cANI,EAMY,UANZ,EAMwB,UANxB,CAAD,CAAzB;AAQA,IAAIiB,SAAS,GAAGjB,UAAU,CAAC,CAAC,MAAD,EAAS,OAAT,EAAkB,KAAlB,EAAyB,MAAzB,CAAD,CAA1B;AACA,IAAIkB,mBAAmB,GAAG,CACxB,KADwB,EACjB,KADiB,EACV,OADU,EAExB,OAFwB,EAEf,QAFe,EAEL,QAFK,EAEK,KAFL,EAEY,MAFZ,EAEoB,OAFpB,EAGxB,IAHwB,EAGlB,KAHkB,CAA1B;AAKA,IAAIC,cAAc,GAAGnB,UAAU,CAACkB,mBAAD,CAA/B;AACA,IAAIE,6BAA6B,GAAG,CAAC,IAAD,EAAO,QAAP,EAAiB,MAAjB,EAAyB,OAAzB,EAAkC,OAAlC,EAA2C,OAA3C,EAAoD,MAApD,CAApC;AACA,IAAIC,wBAAwB,GAAGrB,UAAU,CAACoB,6BAAD,CAAzC;AACA,IAAIE,mBAAmB,GAAG,CAAC,KAAD,EAAQ,MAAR,EAAgB,OAAhB,EAAyB,QAAzB,EAAmC,QAAnC,CAA1B;AACA,IAAIC,cAAc,GAAGvB,UAAU,CAACsB,mBAAD,CAA/B;AACA,IAAIE,oBAAoB,GAAG,CAAC,KAAD,EAAQ,KAAR,EAAe,KAAf,CAA3B;AACA,IAAIC,eAAe,GAAG,IAAItB,MAAJ,CAAW,SAASqB,oBAAoB,CAACpB,IAArB,CAA0B,GAA1B,CAAT,GAA0C,IAArD,CAAtB;AACA,IAAIsB,aAAa,GAAG;EAClB,OAAOC,gBADW;EACO,OAAOA,gBADd;EACgC,SAASC,aADzC;EAElB,SAASC,eAFS;EAEQ,UAAUA,eAFlB;EAEmC,UAAUA,eAF7C;EAGlB,OAAOA,eAHW;EAGM,QAAQA,eAHd;EAG+B,SAASA;AAHxC,CAApB;AAKA,IAAIC,QAAQ,GAAG;EAAC,KAAK,GAAN;EAAW,KAAK,GAAhB;EAAqB,KAAK,GAA1B;EAA+B,KAAK;AAApC,CAAf;;AAEA,SAASC,SAAT,CAAmBxB,MAAnB,EAA2BC,KAA3B,EAAkC;EAChC,IAAID,MAAM,CAACyB,QAAP,EAAJ,EAAuB;IACrB,OAAO,IAAP;EACD,CAH+B,CAKhC;;;EACA,IAAIxB,KAAK,CAACyB,SAAN,IAAmB,IAAnB,IAA2B1B,MAAM,CAAC2B,KAAP,CAAa,IAAb,EAAmB,KAAnB,CAA/B,EAA0D;IACxD,OAAO7B,KAAK,CAAC8B,UAAU,CAAC,GAAD,EAAM,GAAN,CAAX,EAAuB5B,MAAvB,EAA+BC,KAA/B,CAAZ;EACD;;EAED,IAAIA,KAAK,CAACyB,SAAN,IAAmB,IAAnB,IAA2B1B,MAAM,CAAC2B,KAAP,CAAa,IAAb,EAAmB,KAAnB,CAA/B,EAA0D;IACxD,OAAO7B,KAAK,CAAC8B,UAAU,CAAC,GAAD,EAAM,GAAN,CAAX,EAAuB5B,MAAvB,EAA+BC,KAA/B,CAAZ;EACD,CAZ+B,CAchC;;;EACA,IAAID,MAAM,CAAC6B,IAAP,MAAiB,GAArB,EAA0B;IACxB7B,MAAM,CAAC8B,SAAP;IACA,OAAO,SAAP;EACD,CAlB+B,CAoBhC;;;EACA,IAAIC,OAAJ;;EACA,IAAI/B,MAAM,CAAC2B,KAAP,CAAapB,MAAb,CAAJ,EAA0B;IACxBP,MAAM,CAACgC,GAAP,CAAW,MAAX;IAEAD,OAAO,GAAG/B,MAAM,CAACiC,OAAP,EAAV;;IACA,IAAIjC,MAAM,CAACgC,GAAP,CAAW,GAAX,CAAJ,EAAqB;MACnB,OAAO,MAAP;IACD,CAFD,MAEO,IAAI/B,KAAK,CAACyB,SAAN,IAAmB,GAAvB,EAA4B;MACjC,OAAO,UAAP;IACD,CAFM,MAEA,IAAIjB,QAAQ,CAACyB,IAAT,CAAcH,OAAd,CAAJ,EAA4B;MACjC,IAAInB,cAAc,CAACsB,IAAf,CAAoBH,OAApB,CAAJ,EAAkC;QAChC,IAAI,EAAEA,OAAO,IAAI,KAAX,IAAoB9B,KAAK,CAACkC,MAAN,CAAaC,OAAb,CAAqB,KAArB,KAA+B,CAArD,KAA2D,EAAEL,OAAO,IAAI,KAAX,IAAoB9B,KAAK,CAACyB,SAAN,IAAmB,UAAzC,CAA/D,EAAqH;UACnHzB,KAAK,CAACkC,MAAN,CAAajC,IAAb,CAAkB6B,OAAlB;UACA9B,KAAK,CAACoC,aAAN,IAAuB,CAAvB;QACD;MACF,CALD,MAKO,IAAI,CAACpC,KAAK,CAACqC,SAAN,IAAmB,UAAnB,IAAiC,CAACrC,KAAK,CAACqC,SAAzC,KAAuDxB,wBAAwB,CAACoB,IAAzB,CAA8BH,OAA9B,CAA3D,EAAmG;QACxG9B,KAAK,CAACkC,MAAN,CAAajC,IAAb,CAAkB6B,OAAlB;QACA9B,KAAK,CAACoC,aAAN,IAAuB,CAAvB;MACD,CAHM,MAGA,IAAIN,OAAO,IAAI,KAAf,EAAsB;QAC3B9B,KAAK,CAACkC,MAAN,CAAaI,GAAb;QACAtC,KAAK,CAACoC,aAAN,IAAuB,CAAvB;MACD;;MAED,IAAIlB,aAAa,CAACqB,cAAd,CAA6BT,OAA7B,CAAJ,EAA2C;QACzC9B,KAAK,CAACF,QAAN,CAAeG,IAAf,CAAoBiB,aAAa,CAACY,OAAD,CAAjC;MACD;;MAED,OAAO,SAAP;IACD,CAnBM,MAmBA,IAAIrB,SAAS,CAACwB,IAAV,CAAeH,OAAf,CAAJ,EAA6B;MAClC,OAAO,MAAP;IACD;;IAED,OAAO,UAAP;EACD,CAtD+B,CAwDhC;EACA;;;EACA,IAAI/B,MAAM,CAACgC,GAAP,CAAW,GAAX,CAAJ,EAAqB;IACnB,IAAIhC,MAAM,CAAC6B,IAAP,MAAiB,GAArB,EAA0B;MACxB,OAAO/B,KAAK,CAAC2C,SAAS,CAAC,GAAD,EAAM,GAAN,EAAW,MAAX,CAAV,EAA8BzC,MAA9B,EAAsCC,KAAtC,CAAZ;IACD;;IAEDD,MAAM,CAACgC,GAAP,CAAW,GAAX;IACAhC,MAAM,CAAC2B,KAAP,CAAapB,MAAb,KAAwBP,MAAM,CAAC2B,KAAP,CAAanB,KAAb,CAAxB;IACA,OAAO,cAAP;EACD,CAlE+B,CAoEhC;;;EACA,IAAIR,MAAM,CAAC2B,KAAP,CAAanB,KAAb,CAAJ,EAAyB;IACvB,OAAO,KAAP;EACD,CAvE+B,CAyEhC;;;EACA,IAAIR,MAAM,CAACgC,GAAP,CAAW,GAAX,CAAJ,EAAqB;IACnB,IAAIhC,MAAM,CAACgC,GAAP,CAAW,IAAX,CAAJ,EAAsB;MACpB,OAAOlC,KAAK,CAAC4C,UAAU,CAAC,IAAD,EAAO,MAAP,EAAe,KAAf,CAAX,EAAkC1C,MAAlC,EAA0CC,KAA1C,CAAZ;IACD,CAFD,MAEO,IAAID,MAAM,CAAC2B,KAAP,CAAapB,MAAb,KAAwBP,MAAM,CAAC2B,KAAP,CAAanB,KAAb,CAAxB,IACAR,MAAM,CAAC2B,KAAP,CAAaxB,SAAb,CADA,IAC2BH,MAAM,CAAC2B,KAAP,CAAavB,oBAAb,CAD3B,IACiEJ,MAAM,CAAC2B,KAAP,CAAatB,iBAAb,CADrE,EACsG;MAC3G,OAAO,MAAP;IACD;;IACDL,MAAM,CAACgC,GAAP,CAAW,GAAX;IACA,OAAO,UAAP;EACD,CAnF+B,CAqFhC;;;EACA,IAAIhC,MAAM,CAACgC,GAAP,CAAW,IAAX,CAAJ,EAAsB;IACpB,OAAOlC,KAAK,CAAC4C,UAAU,CAAC,IAAD,EAAO,QAAP,EAAiB,IAAjB,CAAX,EAAmC1C,MAAnC,EAA2CC,KAA3C,CAAZ;EACD,CAxF+B,CA0FhC;;;EACA,IAAID,MAAM,CAAC6B,IAAP,MAAiB,GAArB,EAA0B;IACxB,IAAIc,KAAK,GAAG,QAAZ;IACA,IAAIC,KAAK,GAAG,IAAZ;IACA,IAAIC,KAAJ;;IAEA,IAAI7C,MAAM,CAAC2B,KAAP,CAAa,IAAb,CAAJ,EAAwB;MACtB;MACAgB,KAAK,GAAG,gBAAR;MACAE,KAAK,GAAG7C,MAAM,CAAC8C,IAAP,EAAR;IACD,CAJD,MAIO,IAAI9C,MAAM,CAAC2B,KAAP,CAAa,IAAb,CAAJ,EAAwB;MAC7BiB,KAAK,GAAG,KAAR;MACAC,KAAK,GAAG7C,MAAM,CAAC8C,IAAP,EAAR;IACD,CAHM,MAGA,IAAI9C,MAAM,CAAC2B,KAAP,CAAa,IAAb,CAAJ,EAAwB;MAC7BiB,KAAK,GAAG,KAAR;MACAC,KAAK,GAAG7C,MAAM,CAAC8C,IAAP,EAAR;IACD,CAHM,MAGA;MACL,IAAGD,KAAK,GAAG7C,MAAM,CAAC2B,KAAP,CAAa,cAAb,CAAX,EAAyC;QACvCkB,KAAK,GAAGA,KAAK,CAAC,CAAD,CAAb;MACD,CAFD,MAEO,IAAI7C,MAAM,CAAC2B,KAAP,CAAa,4CAAb,CAAJ,EAAgE;QACrE;QACA,OAAO,MAAP;MACD,CAHM,MAGA,IAAI3B,MAAM,CAACgC,GAAP,CAAW,GAAX,CAAJ,EAAqB;QAC1B;QACA,OAAO,UAAP;MACD;IACF;;IAED,IAAIT,QAAQ,CAACiB,cAAT,CAAwBK,KAAxB,CAAJ,EAAoC;MAClCA,KAAK,GAAGtB,QAAQ,CAACsB,KAAD,CAAhB;IACD;;IACD,OAAO/C,KAAK,CAAC4C,UAAU,CAACG,KAAD,EAAQF,KAAR,EAAeC,KAAf,CAAX,EAAkC5C,MAAlC,EAA0CC,KAA1C,CAAZ;EACD,CA1H+B,CA4HhC;;;EACA,IAAI8B,OAAO,GAAG/B,MAAM,CAAC2B,KAAP,CAAa,sBAAb,CAAd,EAAoD;IAClD,OAAO7B,KAAK,CAACiD,YAAY,CAAChB,OAAO,CAAC,CAAD,CAAR,EAAa,CAACA,OAAO,CAAC,CAAD,CAArB,CAAb,EAAwC/B,MAAxC,EAAgDC,KAAhD,CAAZ;EACD,CA/H+B,CAiIhC;;;EACA,IAAID,MAAM,CAACgC,GAAP,CAAW,GAAX,CAAJ,EAAqB;IACnBhC,MAAM,CAAC2B,KAAP,CAAa,gFAAb;IACA3B,MAAM,CAACgC,GAAP,CAAW,GAAX;IACA,OAAO,MAAP;EACD,CAtI+B,CAwIhC;;;EACA,IAAIhC,MAAM,CAACgC,GAAP,CAAW,GAAX,CAAJ,EAAqB;IACnB,IAAIhC,MAAM,CAACgC,GAAP,CAAW,GAAX,CAAJ,EAAqB;MACnBhC,MAAM,CAAC2B,KAAP,CAAa,gBAAb;IACD,CAFD,MAEO,IAAI3B,MAAM,CAACgC,GAAP,CAAW,GAAX,CAAJ,EAAqB;MAC1BhC,MAAM,CAAC2B,KAAP,CAAa,UAAb;IACD,CAFM,MAEA,IAAI3B,MAAM,CAACgC,GAAP,CAAW,GAAX,CAAJ,EAAqB;MAC1BhC,MAAM,CAAC2B,KAAP,CAAa,SAAb;IACD;;IACD,OAAO,QAAP;EACD;;EAED,IAAI3B,MAAM,CAACgC,GAAP,CAAW,KAAX,CAAJ,EAAuB;IACrBhC,MAAM,CAAC2B,KAAP,CAAa,uCAAb;IACA,OAAO,QAAP;EACD,CAvJ+B,CAyJhC;;;EACA,IAAI3B,MAAM,CAAC2B,KAAP,CAAaxB,SAAb,CAAJ,EAA6B;IAC3BH,MAAM,CAACgC,GAAP,CAAW,GAAX,EAD2B,CACV;;IACjB,OAAO,UAAP;EACD;;EAED,IAAIhC,MAAM,CAAC2B,KAAP,CAAavB,oBAAb,KAAsCJ,MAAM,CAAC2B,KAAP,CAAarB,gBAAb,CAA1C,EAA0E;IACxE,OAAO,UAAP;EACD,CAjK+B,CAmKhC;;;EACA,IAAIyB,OAAO,GAAG/B,MAAM,CAAC2B,KAAP,CAAa,OAAb,EAAsB,KAAtB,CAAd,EAA4C;IAC1CI,OAAO,GAAGA,OAAO,CAAC,CAAD,CAAjB;IACA,OAAOjC,KAAK,CAAC2C,SAAS,CAACV,OAAD,EAAUR,QAAQ,CAACQ,OAAD,CAAlB,EAA6B,IAA7B,CAAV,EAA8C/B,MAA9C,EAAsDC,KAAtD,CAAZ;EACD,CAvK+B,CAyKhC;;;EACA,IAAID,MAAM,CAACgC,GAAP,CAAW,IAAX,CAAJ,EAAsB;IACpBhC,MAAM,CAAC8C,IAAP;IACA,OAAO,MAAP;EACD;;EAED9C,MAAM,CAAC8C,IAAP;EACA,OAAO,IAAP;AACD;;AAED,SAASL,SAAT,CAAmBO,KAAnB,EAA0BrD,GAA1B,EAA+BgD,KAA/B,EAAsCM,OAAtC,EAA+C;EAC7C,OAAO,UAAUjD,MAAV,EAAkBC,KAAlB,EAAyB;IAC9B,IAAI,CAACgD,OAAD,IAAYjD,MAAM,CAAC2B,KAAP,CAAaqB,KAAb,CAAhB,EAAqC;MACnC/C,KAAK,CAACF,QAAN,CAAeE,KAAK,CAACF,QAAN,CAAemD,MAAf,GAAwB,CAAvC,IAA4CT,SAAS,CAACO,KAAD,EAAQrD,GAAR,EAAagD,KAAb,EAAoB,IAApB,CAArD;MACA1C,KAAK,CAACoC,aAAN,IAAuB,CAAvB;MACA,OAAOM,KAAP;IACD;;IAED,IAAIQ,SAAS,GAAG3B,SAAS,CAACxB,MAAD,EAASC,KAAT,CAAzB;;IACA,IAAID,MAAM,CAACiC,OAAP,OAAqBtC,GAAzB,EAA8B;MAC5BM,KAAK,CAACF,QAAN,CAAewC,GAAf;MACAtC,KAAK,CAACoC,aAAN,IAAuB,CAAvB;MACAc,SAAS,GAAGR,KAAZ;IACD;;IAED,OAAOQ,SAAP;EACD,CAfD;AAgBD;;AAED,SAASvB,UAAT,CAAoBoB,KAApB,EAA2BrD,GAA3B,EAAgCsD,OAAhC,EAAyC;EACvC,OAAO,UAAUjD,MAAV,EAAkBC,KAAlB,EAAyB;IAC9B,IAAI,CAACgD,OAAD,IAAYjD,MAAM,CAAC2B,KAAP,CAAa,MAAMqB,KAAnB,CAAhB,EAA2C;MACzC/C,KAAK,CAACoC,aAAN,IAAuB,CAAvB;MACApC,KAAK,CAACF,QAAN,CAAeE,KAAK,CAACF,QAAN,CAAemD,MAAf,GAAwB,CAAvC,IAA4CtB,UAAU,CAACoB,KAAD,EAAQrD,GAAR,EAAa,IAAb,CAAtD;MACA,OAAO,MAAP;IACD;;IAED,IAAIK,MAAM,CAAC2B,KAAP,CAAahC,GAAG,GAAG,GAAnB,CAAJ,EAA6B;MAC3BM,KAAK,CAACoC,aAAN,IAAuB,CAAvB;MACApC,KAAK,CAACF,QAAN,CAAewC,GAAf;MACA,OAAO,MAAP;IACD;;IAED,OAAOf,SAAS,CAACxB,MAAD,EAASC,KAAT,CAAhB;EACD,CAdD;AAeD;;AAED,SAASoB,aAAT,CAAuBrB,MAAvB,EAA+BC,KAA/B,EAAsC;EACpC,IAAID,MAAM,CAACyB,QAAP,EAAJ,EAAuB;IACrB,OAAO,IAAP;EACD;;EAED,IAAIM,OAAJ;;EACA,IAAIA,OAAO,GAAG/B,MAAM,CAAC2B,KAAP,CAAapB,MAAb,CAAd,EAAoC;IAClC,IAAIwB,OAAO,IAAI,KAAf,EAAsB;MACpB,OAAO,SAAP;IACD;;IACD/B,MAAM,CAACgC,GAAP,CAAW,MAAX;EACD;;EAED/B,KAAK,CAACF,QAAN,CAAewC,GAAf;EACA,OAAO,KAAP;AACD;;AAED,SAASnB,gBAAT,CAA0BpB,MAA1B,EAAkCC,KAAlC,EAAyC;EACvC,IAAID,MAAM,CAACyB,QAAP,EAAJ,EAAuB;IACrB,OAAO,IAAP;EACD;;EAED,IAAIzB,MAAM,CAAC2B,KAAP,CAAapB,MAAb,CAAJ,EAA0B;IACxBP,MAAM,CAACgC,GAAP,CAAW,MAAX;EACD,CAFD,MAEO;IACLhC,MAAM,CAAC2B,KAAP,CAAaxB,SAAb,KAA2BH,MAAM,CAAC2B,KAAP,CAAavB,oBAAb,CAA3B,IAAiEJ,MAAM,CAAC2B,KAAP,CAAatB,iBAAb,CAAjE;EACD;;EACDJ,KAAK,CAACF,QAAN,CAAewC,GAAf;EACA,OAAO,KAAP;AACD;;AAED,SAASjB,eAAT,CAAyBtB,MAAzB,EAAiCC,KAAjC,EAAwC;EACtC,IAAID,MAAM,CAACyB,QAAP,EAAJ,EAAuB;IACrB,OAAO,IAAP;EACD;;EAEDzB,MAAM,CAAC2B,KAAP,CAAanB,KAAb;EACAP,KAAK,CAACF,QAAN,CAAewC,GAAf;EACA,OAAO,KAAP;AACD;;AAED,SAASG,UAAT,CAAoB/C,GAApB,EAAyBgD,KAAzB,EAAgCC,KAAhC,EAAuC;EACrC,OAAO,UAAU5C,MAAV,EAAkBC,KAAlB,EAAyB;IAC9B,IAAImD,OAAO,GAAG,KAAd;;IAEA,OAAOpD,MAAM,CAAC6B,IAAP,EAAP,EAAsB;MACpB,IAAI,CAACuB,OAAL,EAAc;QACZ,IAAIpD,MAAM,CAAC2B,KAAP,CAAa,IAAb,EAAmB,KAAnB,CAAJ,EAA+B;UAC7B1B,KAAK,CAACF,QAAN,CAAeG,IAAf,CAAoB0B,UAAU,CAAC,GAAD,EAAM,GAAN,CAA9B;UACA,OAAOe,KAAP;QACD;;QAED,IAAI3C,MAAM,CAAC2B,KAAP,CAAa,IAAb,EAAmB,KAAnB,CAAJ,EAA+B;UAC7B1B,KAAK,CAACF,QAAN,CAAeG,IAAf,CAAoB0B,UAAU,CAAC,GAAD,EAAM,GAAN,CAA9B;UACA,OAAOe,KAAP;QACD;;QAED,IAAIC,KAAK,IAAI5C,MAAM,CAAC2B,KAAP,CAAa,IAAb,EAAmB,KAAnB,CAAb,EAAwC;UACtC1B,KAAK,CAACF,QAAN,CAAeG,IAAf,CAAoBuC,SAAS,CAAC,IAAD,EAAO,GAAP,EAAY,MAAZ,CAA7B;UACA,OAAOE,KAAP;QACD;;QAED,IAAIU,EAAE,GAAGrD,MAAM,CAAC8C,IAAP,EAAT;;QAEA,IAAIO,EAAE,IAAI1D,GAAV,EAAe;UACbM,KAAK,CAACF,QAAN,CAAewC,GAAf;UACA,OAAOI,KAAP;QACD;;QAEDS,OAAO,GAAGR,KAAK,IAAIS,EAAE,IAAI,IAAzB;MACD,CAxBD,MAwBO;QACLrD,MAAM,CAAC8C,IAAP;QACAM,OAAO,GAAG,KAAV;MACD;IACF;;IAED,OAAOT,KAAP;EACD,CAnCD;AAoCD;;AAED,SAASI,YAAT,CAAsBO,MAAtB,EAA8BV,KAA9B,EAAqC;EACnC,OAAO,UAAU5C,MAAV,EAAkBC,KAAlB,EAAyB;IAC9B,IAAID,MAAM,CAACuD,GAAP,EAAJ,EAAkB;MAChBvD,MAAM,CAACyB,QAAP;;MACA,IAAIzB,MAAM,CAAC2B,KAAP,CAAa2B,MAAb,CAAJ,EAA0B;QACxBrD,KAAK,CAACF,QAAN,CAAewC,GAAf;QACA,OAAO,QAAP;MACD;IACF;;IAED,IAAIa,OAAO,GAAG,KAAd;;IACA,OAAOpD,MAAM,CAAC6B,IAAP,EAAP,EAAsB;MACpB,IAAI,CAACuB,OAAL,EAAc;QACZ,IAAIpD,MAAM,CAAC2B,KAAP,CAAa,IAAb,EAAmB,KAAnB,CAAJ,EAA+B;UAC7B1B,KAAK,CAACF,QAAN,CAAeG,IAAf,CAAoB0B,UAAU,CAAC,GAAD,EAAM,GAAN,CAA9B;UACA,OAAO,QAAP;QACD;;QAED,IAAI5B,MAAM,CAAC2B,KAAP,CAAa,IAAb,EAAmB,KAAnB,CAAJ,EAA+B;UAC7B1B,KAAK,CAACF,QAAN,CAAeG,IAAf,CAAoB0B,UAAU,CAAC,GAAD,EAAM,GAAN,CAA9B;UACA,OAAO,QAAP;QACD;;QAED,IAAIgB,KAAK,IAAI5C,MAAM,CAAC2B,KAAP,CAAa,IAAb,EAAmB,KAAnB,CAAb,EAAwC;UACtC1B,KAAK,CAACF,QAAN,CAAeG,IAAf,CAAoBuC,SAAS,CAAC,IAAD,EAAO,GAAP,EAAY,MAAZ,CAA7B;UACA,OAAO,QAAP;QACD;;QAEDW,OAAO,GAAGR,KAAK,IAAI5C,MAAM,CAAC8C,IAAP,MAAiB,IAApC;MACD,CAjBD,MAiBO;QACL9C,MAAM,CAAC8C,IAAP;QACAM,OAAO,GAAG,KAAV;MACD;IACF;;IAED,OAAO,QAAP;EACD,CAnCD;AAoCD;;AAED,OAAO,MAAMI,OAAO,GAAG;EACrBC,UAAU,EAAE,YAAY;IACtB,OAAO;MACL1D,QAAQ,EAAE,CAACyB,SAAD,CADL;MAELa,aAAa,EAAE,CAFV;MAGLX,SAAS,EAAE,IAHN;MAILY,SAAS,EAAE,IAJN;MAKLH,MAAM,EAAE;IALH,CAAP;EAOD,CAToB;EAWrBuB,KAAK,EAAE,UAAU1D,MAAV,EAAkBC,KAAlB,EAAyB;IAC9B,IAAI0C,KAAK,GAAG1C,KAAK,CAACF,QAAN,CAAeE,KAAK,CAACF,QAAN,CAAemD,MAAf,GAAwB,CAAvC,EAA0ClD,MAA1C,EAAkDC,KAAlD,CAAZ;IACA,IAAIyD,KAAK,GAAG1D,MAAM,CAACiC,OAAP,EAAZ;;IAEA,IAAIU,KAAK,IAAIA,KAAK,IAAI,SAAtB,EAAiC;MAC/B1C,KAAK,CAACyB,SAAN,GAAkBgC,KAAlB;MACAzD,KAAK,CAACqC,SAAN,GAAkBK,KAAlB;IACD;;IAED,OAAOA,KAAP;EACD,CArBoB;EAuBrBgB,MAAM,EAAE,UAAU1D,KAAV,EAAiB2D,SAAjB,EAA4BC,EAA5B,EAAgC;IACtCD,SAAS,GAAGA,SAAS,CAACE,OAAV,CAAkB,kCAAlB,EAAsD,EAAtD,CAAZ;;IAEA,IAAI9C,cAAc,CAACkB,IAAf,CAAoB0B,SAApB,KAAkC1C,eAAe,CAACgB,IAAhB,CAAqB0B,SAArB,CAAtC,EAAuE;MACrE,OAAOC,EAAE,CAACE,IAAH,IAAW9D,KAAK,CAACoC,aAAN,GAAsB,CAAjC,CAAP;IACD;;IAED,OAAOwB,EAAE,CAACE,IAAH,GAAU9D,KAAK,CAACoC,aAAvB;EACD,CA/BoB;EAiCrB2B,YAAY,EAAE;IACZC,aAAa,EAAExE,UAAU,CAACwB,oBAAoB,CAACiD,MAArB,CAA4BnD,mBAA5B,CAAD,EAAmD,IAAnD,CADb;IAEZoD,aAAa,EAAE;MAACC,IAAI,EAAE;IAAP;EAFH;AAjCO,CAAhB"},"metadata":{},"sourceType":"module"}