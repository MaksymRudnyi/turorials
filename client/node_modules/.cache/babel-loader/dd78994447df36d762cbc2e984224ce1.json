{"ast":null,"code":"// Tokenizer\nfunction kw(type) {\n  return {\n    type: type,\n    style: \"keyword\"\n  };\n}\n\nvar A = kw(\"keyword a\"),\n    B = kw(\"keyword b\"),\n    C = kw(\"keyword c\");\nvar operator = kw(\"operator\"),\n    atom = {\n  type: \"atom\",\n  style: \"atom\"\n},\n    attribute = {\n  type: \"attribute\",\n  style: \"attribute\"\n};\nvar type = kw(\"typedef\");\nvar keywords = {\n  \"if\": A,\n  \"while\": A,\n  \"else\": B,\n  \"do\": B,\n  \"try\": B,\n  \"return\": C,\n  \"break\": C,\n  \"continue\": C,\n  \"new\": C,\n  \"throw\": C,\n  \"var\": kw(\"var\"),\n  \"inline\": attribute,\n  \"static\": attribute,\n  \"using\": kw(\"import\"),\n  \"public\": attribute,\n  \"private\": attribute,\n  \"cast\": kw(\"cast\"),\n  \"import\": kw(\"import\"),\n  \"macro\": kw(\"macro\"),\n  \"function\": kw(\"function\"),\n  \"catch\": kw(\"catch\"),\n  \"untyped\": kw(\"untyped\"),\n  \"callback\": kw(\"cb\"),\n  \"for\": kw(\"for\"),\n  \"switch\": kw(\"switch\"),\n  \"case\": kw(\"case\"),\n  \"default\": kw(\"default\"),\n  \"in\": operator,\n  \"never\": kw(\"property_access\"),\n  \"trace\": kw(\"trace\"),\n  \"class\": type,\n  \"abstract\": type,\n  \"enum\": type,\n  \"interface\": type,\n  \"typedef\": type,\n  \"extends\": type,\n  \"implements\": type,\n  \"dynamic\": type,\n  \"true\": atom,\n  \"false\": atom,\n  \"null\": atom\n};\nvar isOperatorChar = /[+\\-*&%=<>!?|]/;\n\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\n\nfunction toUnescaped(stream, end) {\n  var escaped = false,\n      next;\n\n  while ((next = stream.next()) != null) {\n    if (next == end && !escaped) return true;\n    escaped = !escaped && next == \"\\\\\";\n  }\n} // Used as scratch variables to communicate multiple values without\n// consing up tons of objects.\n\n\nvar type, content;\n\nfunction ret(tp, style, cont) {\n  type = tp;\n  content = cont;\n  return style;\n}\n\nfunction haxeTokenBase(stream, state) {\n  var ch = stream.next();\n\n  if (ch == '\"' || ch == \"'\") {\n    return chain(stream, state, haxeTokenString(ch));\n  } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n    return ret(ch);\n  } else if (ch == \"0\" && stream.eat(/x/i)) {\n    stream.eatWhile(/[\\da-f]/i);\n    return ret(\"number\", \"number\");\n  } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n    stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n    return ret(\"number\", \"number\");\n  } else if (state.reAllowed && ch == \"~\" && stream.eat(/\\//)) {\n    toUnescaped(stream, \"/\");\n    stream.eatWhile(/[gimsu]/);\n    return ret(\"regexp\", \"string.special\");\n  } else if (ch == \"/\") {\n    if (stream.eat(\"*\")) {\n      return chain(stream, state, haxeTokenComment);\n    } else if (stream.eat(\"/\")) {\n      stream.skipToEnd();\n      return ret(\"comment\", \"comment\");\n    } else {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", null, stream.current());\n    }\n  } else if (ch == \"#\") {\n    stream.skipToEnd();\n    return ret(\"conditional\", \"meta\");\n  } else if (ch == \"@\") {\n    stream.eat(/:/);\n    stream.eatWhile(/[\\w_]/);\n    return ret(\"metadata\", \"meta\");\n  } else if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return ret(\"operator\", null, stream.current());\n  } else {\n    var word;\n\n    if (/[A-Z]/.test(ch)) {\n      stream.eatWhile(/[\\w_<>]/);\n      word = stream.current();\n      return ret(\"type\", \"type\", word);\n    } else {\n      stream.eatWhile(/[\\w_]/);\n      var word = stream.current(),\n          known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return known && state.kwAllowed ? ret(known.type, known.style, word) : ret(\"variable\", \"variable\", word);\n    }\n  }\n}\n\nfunction haxeTokenString(quote) {\n  return function (stream, state) {\n    if (toUnescaped(stream, quote)) state.tokenize = haxeTokenBase;\n    return ret(\"string\", \"string\");\n  };\n}\n\nfunction haxeTokenComment(stream, state) {\n  var maybeEnd = false,\n      ch;\n\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = haxeTokenBase;\n      break;\n    }\n\n    maybeEnd = ch == \"*\";\n  }\n\n  return ret(\"comment\", \"comment\");\n} // Parser\n\n\nvar atomicTypes = {\n  \"atom\": true,\n  \"number\": true,\n  \"variable\": true,\n  \"string\": true,\n  \"regexp\": true\n};\n\nfunction HaxeLexical(indented, column, type, align, prev, info) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.prev = prev;\n  this.info = info;\n  if (align != null) this.align = align;\n}\n\nfunction inScope(state, varname) {\n  for (var v = state.localVars; v; v = v.next) if (v.name == varname) return true;\n}\n\nfunction parseHaxe(state, style, type, content, stream) {\n  var cc = state.cc; // Communicate our context to the combinators.\n  // (Less wasteful than consing up a hundred closures on every call.)\n\n  cx.state = state;\n  cx.stream = stream;\n  cx.marked = null, cx.cc = cc;\n  if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = true;\n\n  while (true) {\n    var combinator = cc.length ? cc.pop() : statement;\n\n    if (combinator(type, content)) {\n      while (cc.length && cc[cc.length - 1].lex) cc.pop()();\n\n      if (cx.marked) return cx.marked;\n      if (type == \"variable\" && inScope(state, content)) return \"variableName.local\";\n      if (type == \"variable\" && imported(state, content)) return \"variableName.special\";\n      return style;\n    }\n  }\n}\n\nfunction imported(state, typename) {\n  if (/[a-z]/.test(typename.charAt(0))) return false;\n  var len = state.importedtypes.length;\n\n  for (var i = 0; i < len; i++) if (state.importedtypes[i] == typename) return true;\n}\n\nfunction registerimport(importname) {\n  var state = cx.state;\n\n  for (var t = state.importedtypes; t; t = t.next) if (t.name == importname) return;\n\n  state.importedtypes = {\n    name: importname,\n    next: state.importedtypes\n  };\n} // Combinator utils\n\n\nvar cx = {\n  state: null,\n  column: null,\n  marked: null,\n  cc: null\n};\n\nfunction pass() {\n  for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n}\n\nfunction cont() {\n  pass.apply(null, arguments);\n  return true;\n}\n\nfunction inList(name, list) {\n  for (var v = list; v; v = v.next) if (v.name == name) return true;\n\n  return false;\n}\n\nfunction register(varname) {\n  var state = cx.state;\n\n  if (state.context) {\n    cx.marked = \"def\";\n    if (inList(varname, state.localVars)) return;\n    state.localVars = {\n      name: varname,\n      next: state.localVars\n    };\n  } else if (state.globalVars) {\n    if (inList(varname, state.globalVars)) return;\n    state.globalVars = {\n      name: varname,\n      next: state.globalVars\n    };\n  }\n} // Combinators\n\n\nvar defaultVars = {\n  name: \"this\",\n  next: null\n};\n\nfunction pushcontext() {\n  if (!cx.state.context) cx.state.localVars = defaultVars;\n  cx.state.context = {\n    prev: cx.state.context,\n    vars: cx.state.localVars\n  };\n}\n\nfunction popcontext() {\n  cx.state.localVars = cx.state.context.vars;\n  cx.state.context = cx.state.context.prev;\n}\n\npopcontext.lex = true;\n\nfunction pushlex(type, info) {\n  var result = function () {\n    var state = cx.state;\n    state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n  };\n\n  result.lex = true;\n  return result;\n}\n\nfunction poplex() {\n  var state = cx.state;\n\n  if (state.lexical.prev) {\n    if (state.lexical.type == \")\") state.indented = state.lexical.indented;\n    state.lexical = state.lexical.prev;\n  }\n}\n\npoplex.lex = true;\n\nfunction expect(wanted) {\n  function f(type) {\n    if (type == wanted) return cont();else if (wanted == \";\") return pass();else return cont(f);\n  }\n\n  return f;\n}\n\nfunction statement(type) {\n  if (type == \"@\") return cont(metadef);\n  if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n  if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n  if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n  if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\n  if (type == \";\") return cont();\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"), poplex, statement, poplex);\n  if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n  if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"), block, poplex, poplex);\n  if (type == \"case\") return cont(expression, expect(\":\"));\n  if (type == \"default\") return cont(expect(\":\"));\n  if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"), statement, poplex, popcontext);\n  if (type == \"import\") return cont(importdef, expect(\";\"));\n  if (type == \"typedef\") return cont(typedef);\n  return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n}\n\nfunction expression(type) {\n  if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n  if (type == \"type\") return cont(maybeoperator);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"keyword c\") return cont(maybeexpression);\n  if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n  if (type == \"operator\") return cont(expression);\n  if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\n  if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n  return cont();\n}\n\nfunction maybeexpression(type) {\n  if (type.match(/[;\\}\\)\\],]/)) return pass();\n  return pass(expression);\n}\n\nfunction maybeoperator(type, value) {\n  if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n  if (type == \"operator\" || type == \":\") return cont(expression);\n  if (type == \";\") return;\n  if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n  if (type == \".\") return cont(property, maybeoperator);\n  if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n}\n\nfunction maybeattribute(type) {\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"var\") return cont(vardef1);\n}\n\nfunction metadef(type) {\n  if (type == \":\") return cont(metadef);\n  if (type == \"variable\") return cont(metadef);\n  if (type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\n}\n\nfunction metaargs(type) {\n  if (type == \"variable\") return cont();\n}\n\nfunction importdef(type, value) {\n  if (type == \"variable\" && /[A-Z]/.test(value.charAt(0))) {\n    registerimport(value);\n    return cont();\n  } else if (type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\n}\n\nfunction typedef(type, value) {\n  if (type == \"variable\" && /[A-Z]/.test(value.charAt(0))) {\n    registerimport(value);\n    return cont();\n  } else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) {\n    return cont();\n  }\n}\n\nfunction maybelabel(type) {\n  if (type == \":\") return cont(poplex, statement);\n  return pass(maybeoperator, expect(\";\"), poplex);\n}\n\nfunction property(type) {\n  if (type == \"variable\") {\n    cx.marked = \"property\";\n    return cont();\n  }\n}\n\nfunction objprop(type) {\n  if (type == \"variable\") cx.marked = \"property\";\n  if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n}\n\nfunction commasep(what, end) {\n  function proceed(type) {\n    if (type == \",\") return cont(what, proceed);\n    if (type == end) return cont();\n    return cont(expect(end));\n  }\n\n  return function (type) {\n    if (type == end) return cont();else return pass(what, proceed);\n  };\n}\n\nfunction block(type) {\n  if (type == \"}\") return cont();\n  return pass(statement, block);\n}\n\nfunction vardef1(type, value) {\n  if (type == \"variable\") {\n    register(value);\n    return cont(typeuse, vardef2);\n  }\n\n  return cont();\n}\n\nfunction vardef2(type, value) {\n  if (value == \"=\") return cont(expression, vardef2);\n  if (type == \",\") return cont(vardef1);\n}\n\nfunction forspec1(type, value) {\n  if (type == \"variable\") {\n    register(value);\n    return cont(forin, expression);\n  } else {\n    return pass();\n  }\n}\n\nfunction forin(_type, value) {\n  if (value == \"in\") return cont();\n}\n\nfunction functiondef(type, value) {\n  //function names starting with upper-case letters are recognised as types, so cludging them together here.\n  if (type == \"variable\" || type == \"type\") {\n    register(value);\n    return cont(functiondef);\n  }\n\n  if (value == \"new\") return cont(functiondef);\n  if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\n}\n\nfunction typeuse(type) {\n  if (type == \":\") return cont(typestring);\n}\n\nfunction typestring(type) {\n  if (type == \"type\") return cont();\n  if (type == \"variable\") return cont();\n  if (type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\n}\n\nfunction typeprop(type) {\n  if (type == \"variable\") return cont(typeuse);\n}\n\nfunction funarg(type, value) {\n  if (type == \"variable\") {\n    register(value);\n    return cont(typeuse);\n  }\n} // Interface\n\n\nexport const haxe = {\n  startState: function (indentUnit) {\n    var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\n    var state = {\n      tokenize: haxeTokenBase,\n      reAllowed: true,\n      kwAllowed: true,\n      cc: [],\n      lexical: new HaxeLexical(-indentUnit, 0, \"block\", false),\n      importedtypes: defaulttypes,\n      context: null,\n      indented: 0\n    };\n    return state;\n  },\n  token: function (stream, state) {\n    if (stream.sol()) {\n      if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = false;\n      state.indented = stream.indentation();\n    }\n\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    if (type == \"comment\") return style;\n    state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n    state.kwAllowed = type != '.';\n    return parseHaxe(state, style, type, content, stream);\n  },\n  indent: function (state, textAfter, cx) {\n    if (state.tokenize != haxeTokenBase) return 0;\n    var firstChar = textAfter && textAfter.charAt(0),\n        lexical = state.lexical;\n    if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n    var type = lexical.type,\n        closing = firstChar == type;\n    if (type == \"vardef\") return lexical.indented + 4;else if (type == \"form\" && firstChar == \"{\") return lexical.indented;else if (type == \"stat\" || type == \"form\") return lexical.indented + cx.unit;else if (lexical.info == \"switch\" && !closing) return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? cx.unit : 2 * cx.unit);else if (lexical.align) return lexical.column + (closing ? 0 : 1);else return lexical.indented + (closing ? 0 : cx.unit);\n  },\n  languageData: {\n    indentOnInput: /^\\s*[{}]$/,\n    commentTokens: {\n      line: \"//\",\n      block: {\n        open: \"/*\",\n        close: \"*/\"\n      }\n    }\n  }\n};\nexport const hxml = {\n  startState: function () {\n    return {\n      define: false,\n      inString: false\n    };\n  },\n  token: function (stream, state) {\n    var ch = stream.peek();\n    var sol = stream.sol(); ///* comments */\n\n    if (ch == \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n\n    if (sol && ch == \"-\") {\n      var style = \"variable-2\";\n      stream.eat(/-/);\n\n      if (stream.peek() == \"-\") {\n        stream.eat(/-/);\n        style = \"keyword a\";\n      }\n\n      if (stream.peek() == \"D\") {\n        stream.eat(/[D]/);\n        style = \"keyword c\";\n        state.define = true;\n      }\n\n      stream.eatWhile(/[A-Z]/i);\n      return style;\n    }\n\n    var ch = stream.peek();\n\n    if (state.inString == false && ch == \"'\") {\n      state.inString = true;\n      stream.next();\n    }\n\n    if (state.inString == true) {\n      if (stream.skipTo(\"'\")) {} else {\n        stream.skipToEnd();\n      }\n\n      if (stream.peek() == \"'\") {\n        stream.next();\n        state.inString = false;\n      }\n\n      return \"string\";\n    }\n\n    stream.next();\n    return null;\n  },\n  languageData: {\n    commentTokens: {\n      line: \"#\"\n    }\n  }\n};","map":{"version":3,"names":["kw","type","style","A","B","C","operator","atom","attribute","keywords","isOperatorChar","chain","stream","state","f","tokenize","toUnescaped","end","escaped","next","content","ret","tp","cont","haxeTokenBase","ch","haxeTokenString","test","eat","eatWhile","match","reAllowed","haxeTokenComment","skipToEnd","current","word","known","propertyIsEnumerable","kwAllowed","quote","maybeEnd","atomicTypes","HaxeLexical","indented","column","align","prev","info","inScope","varname","v","localVars","name","parseHaxe","cc","cx","marked","lexical","hasOwnProperty","combinator","length","pop","statement","lex","imported","typename","charAt","len","importedtypes","i","registerimport","importname","t","pass","arguments","push","apply","inList","list","register","context","globalVars","defaultVars","pushcontext","vars","popcontext","pushlex","result","poplex","expect","wanted","metadef","vardef1","expression","block","maybeattribute","functiondef","forspec1","maybelabel","funarg","importdef","typedef","maybeoperator","maybeexpression","commasep","objprop","value","property","metaargs","what","proceed","typeuse","vardef2","forin","_type","typestring","typeprop","haxe","startState","indentUnit","defaulttypes","token","sol","indentation","eatSpace","indent","textAfter","firstChar","closing","unit","languageData","indentOnInput","commentTokens","line","open","close","hxml","define","inString","peek","skipTo"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/@codemirror/legacy-modes/mode/haxe.js"],"sourcesContent":["// Tokenizer\n\nfunction kw(type) {return {type: type, style: \"keyword\"};}\nvar A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\nvar operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"}, attribute = {type:\"attribute\", style: \"attribute\"};\nvar type = kw(\"typedef\");\nvar keywords = {\n  \"if\": A, \"while\": A, \"else\": B, \"do\": B, \"try\": B,\n  \"return\": C, \"break\": C, \"continue\": C, \"new\": C, \"throw\": C,\n  \"var\": kw(\"var\"), \"inline\":attribute, \"static\": attribute, \"using\":kw(\"import\"),\n  \"public\": attribute, \"private\": attribute, \"cast\": kw(\"cast\"), \"import\": kw(\"import\"), \"macro\": kw(\"macro\"),\n  \"function\": kw(\"function\"), \"catch\": kw(\"catch\"), \"untyped\": kw(\"untyped\"), \"callback\": kw(\"cb\"),\n  \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n  \"in\": operator, \"never\": kw(\"property_access\"), \"trace\":kw(\"trace\"),\n  \"class\": type, \"abstract\":type, \"enum\":type, \"interface\":type, \"typedef\":type, \"extends\":type, \"implements\":type, \"dynamic\":type,\n  \"true\": atom, \"false\": atom, \"null\": atom\n};\n\nvar isOperatorChar = /[+\\-*&%=<>!?|]/;\n\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\n\nfunction toUnescaped(stream, end) {\n  var escaped = false, next;\n  while ((next = stream.next()) != null) {\n    if (next == end && !escaped)\n      return true;\n    escaped = !escaped && next == \"\\\\\";\n  }\n}\n\n// Used as scratch variables to communicate multiple values without\n// consing up tons of objects.\nvar type, content;\nfunction ret(tp, style, cont) {\n  type = tp; content = cont;\n  return style;\n}\n\nfunction haxeTokenBase(stream, state) {\n  var ch = stream.next();\n  if (ch == '\"' || ch == \"'\") {\n    return chain(stream, state, haxeTokenString(ch));\n  } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n    return ret(ch);\n  } else if (ch == \"0\" && stream.eat(/x/i)) {\n    stream.eatWhile(/[\\da-f]/i);\n    return ret(\"number\", \"number\");\n  } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n    stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n    return ret(\"number\", \"number\");\n  } else if (state.reAllowed && (ch == \"~\" && stream.eat(/\\//))) {\n    toUnescaped(stream, \"/\");\n    stream.eatWhile(/[gimsu]/);\n    return ret(\"regexp\", \"string.special\");\n  } else if (ch == \"/\") {\n    if (stream.eat(\"*\")) {\n      return chain(stream, state, haxeTokenComment);\n    } else if (stream.eat(\"/\")) {\n      stream.skipToEnd();\n      return ret(\"comment\", \"comment\");\n    } else {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", null, stream.current());\n    }\n  } else if (ch == \"#\") {\n    stream.skipToEnd();\n    return ret(\"conditional\", \"meta\");\n  } else if (ch == \"@\") {\n    stream.eat(/:/);\n    stream.eatWhile(/[\\w_]/);\n    return ret (\"metadata\", \"meta\");\n  } else if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return ret(\"operator\", null, stream.current());\n  } else {\n    var word;\n    if(/[A-Z]/.test(ch)) {\n      stream.eatWhile(/[\\w_<>]/);\n      word = stream.current();\n      return ret(\"type\", \"type\", word);\n    } else {\n      stream.eatWhile(/[\\w_]/);\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return (known && state.kwAllowed) ? ret(known.type, known.style, word) :\n        ret(\"variable\", \"variable\", word);\n    }\n  }\n}\n\nfunction haxeTokenString(quote) {\n  return function(stream, state) {\n    if (toUnescaped(stream, quote))\n      state.tokenize = haxeTokenBase;\n    return ret(\"string\", \"string\");\n  };\n}\n\nfunction haxeTokenComment(stream, state) {\n  var maybeEnd = false, ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = haxeTokenBase;\n      break;\n    }\n    maybeEnd = (ch == \"*\");\n  }\n  return ret(\"comment\", \"comment\");\n}\n\n// Parser\n\nvar atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true};\n\nfunction HaxeLexical(indented, column, type, align, prev, info) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.prev = prev;\n  this.info = info;\n  if (align != null) this.align = align;\n}\n\nfunction inScope(state, varname) {\n  for (var v = state.localVars; v; v = v.next)\n    if (v.name == varname) return true;\n}\n\nfunction parseHaxe(state, style, type, content, stream) {\n  var cc = state.cc;\n  // Communicate our context to the combinators.\n  // (Less wasteful than consing up a hundred closures on every call.)\n  cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n\n  if (!state.lexical.hasOwnProperty(\"align\"))\n    state.lexical.align = true;\n\n  while(true) {\n    var combinator = cc.length ? cc.pop() : statement;\n    if (combinator(type, content)) {\n      while(cc.length && cc[cc.length - 1].lex)\n        cc.pop()();\n      if (cx.marked) return cx.marked;\n      if (type == \"variable\" && inScope(state, content)) return \"variableName.local\";\n      if (type == \"variable\" && imported(state, content)) return \"variableName.special\";\n      return style;\n    }\n  }\n}\n\nfunction imported(state, typename) {\n  if (/[a-z]/.test(typename.charAt(0)))\n    return false;\n  var len = state.importedtypes.length;\n  for (var i = 0; i<len; i++)\n    if(state.importedtypes[i]==typename) return true;\n}\n\nfunction registerimport(importname) {\n  var state = cx.state;\n  for (var t = state.importedtypes; t; t = t.next)\n    if(t.name == importname) return;\n  state.importedtypes = { name: importname, next: state.importedtypes };\n}\n// Combinator utils\n\nvar cx = {state: null, column: null, marked: null, cc: null};\nfunction pass() {\n  for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n}\nfunction cont() {\n  pass.apply(null, arguments);\n  return true;\n}\nfunction inList(name, list) {\n  for (var v = list; v; v = v.next)\n    if (v.name == name) return true;\n  return false;\n}\nfunction register(varname) {\n  var state = cx.state;\n  if (state.context) {\n    cx.marked = \"def\";\n    if (inList(varname, state.localVars)) return;\n    state.localVars = {name: varname, next: state.localVars};\n  } else if (state.globalVars) {\n    if (inList(varname, state.globalVars)) return;\n    state.globalVars = {name: varname, next: state.globalVars};\n  }\n}\n\n// Combinators\n\nvar defaultVars = {name: \"this\", next: null};\nfunction pushcontext() {\n  if (!cx.state.context) cx.state.localVars = defaultVars;\n  cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n}\nfunction popcontext() {\n  cx.state.localVars = cx.state.context.vars;\n  cx.state.context = cx.state.context.prev;\n}\npopcontext.lex = true;\nfunction pushlex(type, info) {\n  var result = function() {\n    var state = cx.state;\n    state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n  };\n  result.lex = true;\n  return result;\n}\nfunction poplex() {\n  var state = cx.state;\n  if (state.lexical.prev) {\n    if (state.lexical.type == \")\")\n      state.indented = state.lexical.indented;\n    state.lexical = state.lexical.prev;\n  }\n}\npoplex.lex = true;\n\nfunction expect(wanted) {\n  function f(type) {\n    if (type == wanted) return cont();\n    else if (wanted == \";\") return pass();\n    else return cont(f);\n  }\n  return f;\n}\n\nfunction statement(type) {\n  if (type == \"@\") return cont(metadef);\n  if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n  if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n  if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n  if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\n  if (type == \";\") return cont();\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"),\n                                 poplex, statement, poplex);\n  if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n  if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                    block, poplex, poplex);\n  if (type == \"case\") return cont(expression, expect(\":\"));\n  if (type == \"default\") return cont(expect(\":\"));\n  if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                   statement, poplex, popcontext);\n  if (type == \"import\") return cont(importdef, expect(\";\"));\n  if (type == \"typedef\") return cont(typedef);\n  return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n}\nfunction expression(type) {\n  if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n  if (type == \"type\" ) return cont(maybeoperator);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"keyword c\") return cont(maybeexpression);\n  if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n  if (type == \"operator\") return cont(expression);\n  if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\n  if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n  return cont();\n}\nfunction maybeexpression(type) {\n  if (type.match(/[;\\}\\)\\],]/)) return pass();\n  return pass(expression);\n}\n\nfunction maybeoperator(type, value) {\n  if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n  if (type == \"operator\" || type == \":\") return cont(expression);\n  if (type == \";\") return;\n  if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n  if (type == \".\") return cont(property, maybeoperator);\n  if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n}\n\nfunction maybeattribute(type) {\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"var\") return cont(vardef1);\n}\n\nfunction metadef(type) {\n  if(type == \":\") return cont(metadef);\n  if(type == \"variable\") return cont(metadef);\n  if(type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\n}\nfunction metaargs(type) {\n  if(type == \"variable\") return cont();\n}\n\nfunction importdef (type, value) {\n  if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n  else if(type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\n}\n\nfunction typedef (type, value)\n{\n  if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n  else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) { return cont(); }\n}\n\nfunction maybelabel(type) {\n  if (type == \":\") return cont(poplex, statement);\n  return pass(maybeoperator, expect(\";\"), poplex);\n}\nfunction property(type) {\n  if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n}\nfunction objprop(type) {\n  if (type == \"variable\") cx.marked = \"property\";\n  if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n}\nfunction commasep(what, end) {\n  function proceed(type) {\n    if (type == \",\") return cont(what, proceed);\n    if (type == end) return cont();\n    return cont(expect(end));\n  }\n  return function(type) {\n    if (type == end) return cont();\n    else return pass(what, proceed);\n  };\n}\nfunction block(type) {\n  if (type == \"}\") return cont();\n  return pass(statement, block);\n}\nfunction vardef1(type, value) {\n  if (type == \"variable\"){register(value); return cont(typeuse, vardef2);}\n  return cont();\n}\nfunction vardef2(type, value) {\n  if (value == \"=\") return cont(expression, vardef2);\n  if (type == \",\") return cont(vardef1);\n}\nfunction forspec1(type, value) {\n  if (type == \"variable\") {\n    register(value);\n    return cont(forin, expression)\n  } else {\n    return pass()\n  }\n}\nfunction forin(_type, value) {\n  if (value == \"in\") return cont();\n}\nfunction functiondef(type, value) {\n  //function names starting with upper-case letters are recognised as types, so cludging them together here.\n  if (type == \"variable\" || type == \"type\") {register(value); return cont(functiondef);}\n  if (value == \"new\") return cont(functiondef);\n  if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\n}\nfunction typeuse(type) {\n  if(type == \":\") return cont(typestring);\n}\nfunction typestring(type) {\n  if(type == \"type\") return cont();\n  if(type == \"variable\") return cont();\n  if(type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\n}\nfunction typeprop(type) {\n  if(type == \"variable\") return cont(typeuse);\n}\nfunction funarg(type, value) {\n  if (type == \"variable\") {register(value); return cont(typeuse);}\n}\n\n// Interface\nexport const haxe = {\n  startState: function(indentUnit) {\n    var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\n    var state = {\n      tokenize: haxeTokenBase,\n      reAllowed: true,\n      kwAllowed: true,\n      cc: [],\n      lexical: new HaxeLexical(-indentUnit, 0, \"block\", false),\n      importedtypes: defaulttypes,\n      context: null,\n      indented: 0\n    };\n    return state;\n  },\n\n  token: function(stream, state) {\n    if (stream.sol()) {\n      if (!state.lexical.hasOwnProperty(\"align\"))\n        state.lexical.align = false;\n      state.indented = stream.indentation();\n    }\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    if (type == \"comment\") return style;\n    state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n    state.kwAllowed = type != '.';\n    return parseHaxe(state, style, type, content, stream);\n  },\n\n  indent: function(state, textAfter, cx) {\n    if (state.tokenize != haxeTokenBase) return 0;\n    var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n    if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n    var type = lexical.type, closing = firstChar == type;\n    if (type == \"vardef\") return lexical.indented + 4;\n    else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n    else if (type == \"stat\" || type == \"form\") return lexical.indented + cx.unit;\n    else if (lexical.info == \"switch\" && !closing)\n      return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? cx.unit : 2 * cx.unit);\n    else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n    else return lexical.indented + (closing ? 0 : cx.unit);\n  },\n\n  languageData: {\n    indentOnInput: /^\\s*[{}]$/,\n    commentTokens: {line: \"//\", block: {open: \"/*\", close: \"*/\"}}\n  }\n};\n\nexport const hxml = {\n  startState: function () {\n    return {\n      define: false,\n      inString: false\n    };\n  },\n  token: function (stream, state) {\n    var ch = stream.peek();\n    var sol = stream.sol();\n\n    ///* comments */\n    if (ch == \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n    if (sol && ch == \"-\") {\n      var style = \"variable-2\";\n\n      stream.eat(/-/);\n\n      if (stream.peek() == \"-\") {\n        stream.eat(/-/);\n        style = \"keyword a\";\n      }\n\n      if (stream.peek() == \"D\") {\n        stream.eat(/[D]/);\n        style = \"keyword c\";\n        state.define = true;\n      }\n\n      stream.eatWhile(/[A-Z]/i);\n      return style;\n    }\n\n    var ch = stream.peek();\n\n    if (state.inString == false && ch == \"'\") {\n      state.inString = true;\n      stream.next();\n    }\n\n    if (state.inString == true) {\n      if (stream.skipTo(\"'\")) {\n\n      } else {\n        stream.skipToEnd();\n      }\n\n      if (stream.peek() == \"'\") {\n        stream.next();\n        state.inString = false;\n      }\n\n      return \"string\";\n    }\n\n    stream.next();\n    return null;\n  },\n  languageData: {\n    commentTokens: {line: \"#\"}\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}