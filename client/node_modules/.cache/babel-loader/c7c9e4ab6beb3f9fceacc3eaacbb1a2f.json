{"ast":null,"code":"/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('./types.js').Selectors} Selectors\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').RuleSet} RuleSet\n * @typedef {import('./types.js').HastNode} HastNode\n * @typedef {import('./types.js').SelectIterator} SelectIterator\n * @typedef {import('./types.js').SelectState} SelectState\n */\nimport { html, svg } from 'property-information';\nimport { zwitch } from 'zwitch';\nimport { enterState } from './enter-state.js';\nimport { nest } from './nest.js';\nimport { pseudo } from './pseudo.js';\nimport { test } from './test.js';\nconst type = zwitch('type', {\n  // @ts-expect-error: hush.\n  unknown: unknownType,\n  invalid: invalidType,\n  // @ts-expect-error: hush.\n  handlers: {\n    selectors,\n    ruleSet,\n    rule\n  }\n});\n/**\n * @param {Selectors|RuleSet|Rule} query\n * @param {HastNode|undefined} node\n * @param {SelectState} state\n * @returns {Array<Element>}\n */\n\nexport function any(query, node, state) {\n  // @ts-expect-error zwitch types are off.\n  return query && node ? type(query, node, state) : [];\n}\n/**\n * @param {Selectors} query\n * @param {HastNode} node\n * @param {SelectState} state\n * @returns {Array<Element>}\n */\n\nfunction selectors(query, node, state) {\n  const collector = new Collector(state.one);\n  let index = -1;\n\n  while (++index < query.selectors.length) {\n    collector.collectAll(ruleSet(query.selectors[index], node, state));\n  }\n\n  return collector.result;\n}\n/**\n * @param {RuleSet} query\n * @param {HastNode} node\n * @param {SelectState} state\n * @returns {Array<Element>}\n */\n\n\nfunction ruleSet(query, node, state) {\n  return rule(query.rule, node, state);\n}\n/**\n * @param {Rule} query\n * @param {HastNode} tree\n * @param {SelectState} state\n * @returns {Array<Element>}\n */\n\n\nfunction rule(query, tree, state) {\n  const collector = new Collector(state.one);\n\n  if (state.shallow && query.rule) {\n    throw new Error('Expected selector without nesting');\n  }\n\n  nest(query, tree, 0, null, configure(query, {\n    schema: state.space === 'svg' ? svg : html,\n    language: undefined,\n    direction: 'ltr',\n    editableOrEditingHost: false,\n    // @ts-expect-error assume elements.\n    scopeElements: tree.type === 'root' ? tree.children : [tree],\n    iterator,\n    one: state.one,\n    shallow: state.shallow\n  }));\n  return collector.result;\n  /** @type {SelectIterator} */\n\n  function iterator(query, node, index, parent, state) {\n    const exit = enterState(state, node);\n\n    if (test(query, node, index, parent, state)) {\n      if (query.rule) {\n        nest(query.rule, node, index, parent, configure(query.rule, state));\n      } else {\n        // @ts-expect-error `test` also asserts `node is Element`\n        collector.collect(node);\n        state.found = true;\n      }\n    }\n\n    exit();\n  }\n  /**\n   * @template {SelectState} S\n   * @param {Rule} query\n   * @param {S} state\n   * @returns {S}\n   */\n\n\n  function configure(query, state) {\n    const pseudos = query.pseudos || [];\n    let index = -1;\n\n    while (++index < pseudos.length) {\n      if (pseudo.needsIndex.includes(pseudos[index].name)) {\n        state.index = true;\n        break;\n      }\n    }\n\n    return state;\n  }\n} // Shouldn’t be called, all data is handled.\n\n/* c8 ignore next 6 */\n\n/**\n * @param {{[x: string]: unknown, type: string}} query\n */\n\n\nfunction unknownType(query) {\n  throw new Error('Unknown type `' + query.type + '`');\n} // Shouldn’t be called, parser gives correct data.\n\n/* c8 ignore next 3 */\n\n\nfunction invalidType() {\n  throw new Error('Invalid type');\n}\n\nclass Collector {\n  /**\n   * @param {boolean|undefined} [one]\n   */\n  constructor(one) {\n    /** @type {Array<Element>} */\n    this.result = [];\n    /** @type {boolean|undefined} */\n\n    this.one = one;\n    /** @type {boolean} */\n\n    this.found = false;\n  }\n  /**\n   * Append nodes to array, filtering out duplicates.\n   *\n   * @param {Array<Element>} elements\n   */\n\n\n  collectAll(elements) {\n    let index = -1;\n\n    while (++index < elements.length) {\n      this.collect(elements[index]);\n    }\n  }\n  /**\n   * Append one node.\n   *\n   * @param {Element} element\n   */\n\n\n  collect(element) {\n    if (this.one) {\n      // Shouldn’t happen, safeguards performance problems.\n\n      /* c8 ignore next */\n      if (this.found) return;\n      this.found = true;\n    }\n\n    if (!this.result.includes(element)) this.result.push(element);\n  }\n\n}","map":{"version":3,"names":["html","svg","zwitch","enterState","nest","pseudo","test","type","unknown","unknownType","invalid","invalidType","handlers","selectors","ruleSet","rule","any","query","node","state","collector","Collector","one","index","length","collectAll","result","tree","shallow","Error","configure","schema","space","language","undefined","direction","editableOrEditingHost","scopeElements","children","iterator","parent","exit","collect","found","pseudos","needsIndex","includes","name","constructor","elements","element","push"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/hast-util-select/lib/any.js"],"sourcesContent":["/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('./types.js').Selectors} Selectors\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').RuleSet} RuleSet\n * @typedef {import('./types.js').HastNode} HastNode\n * @typedef {import('./types.js').SelectIterator} SelectIterator\n * @typedef {import('./types.js').SelectState} SelectState\n */\n\nimport {html, svg} from 'property-information'\nimport {zwitch} from 'zwitch'\nimport {enterState} from './enter-state.js'\nimport {nest} from './nest.js'\nimport {pseudo} from './pseudo.js'\nimport {test} from './test.js'\n\nconst type = zwitch('type', {\n  // @ts-expect-error: hush.\n  unknown: unknownType,\n  invalid: invalidType,\n  // @ts-expect-error: hush.\n  handlers: {selectors, ruleSet, rule}\n})\n\n/**\n * @param {Selectors|RuleSet|Rule} query\n * @param {HastNode|undefined} node\n * @param {SelectState} state\n * @returns {Array<Element>}\n */\nexport function any(query, node, state) {\n  // @ts-expect-error zwitch types are off.\n  return query && node ? type(query, node, state) : []\n}\n\n/**\n * @param {Selectors} query\n * @param {HastNode} node\n * @param {SelectState} state\n * @returns {Array<Element>}\n */\nfunction selectors(query, node, state) {\n  const collector = new Collector(state.one)\n  let index = -1\n\n  while (++index < query.selectors.length) {\n    collector.collectAll(ruleSet(query.selectors[index], node, state))\n  }\n\n  return collector.result\n}\n\n/**\n * @param {RuleSet} query\n * @param {HastNode} node\n * @param {SelectState} state\n * @returns {Array<Element>}\n */\nfunction ruleSet(query, node, state) {\n  return rule(query.rule, node, state)\n}\n\n/**\n * @param {Rule} query\n * @param {HastNode} tree\n * @param {SelectState} state\n * @returns {Array<Element>}\n */\nfunction rule(query, tree, state) {\n  const collector = new Collector(state.one)\n\n  if (state.shallow && query.rule) {\n    throw new Error('Expected selector without nesting')\n  }\n\n  nest(\n    query,\n    tree,\n    0,\n    null,\n    configure(query, {\n      schema: state.space === 'svg' ? svg : html,\n      language: undefined,\n      direction: 'ltr',\n      editableOrEditingHost: false,\n      // @ts-expect-error assume elements.\n      scopeElements: tree.type === 'root' ? tree.children : [tree],\n      iterator,\n      one: state.one,\n      shallow: state.shallow\n    })\n  )\n\n  return collector.result\n\n  /** @type {SelectIterator} */\n  function iterator(query, node, index, parent, state) {\n    const exit = enterState(state, node)\n\n    if (test(query, node, index, parent, state)) {\n      if (query.rule) {\n        nest(query.rule, node, index, parent, configure(query.rule, state))\n      } else {\n        // @ts-expect-error `test` also asserts `node is Element`\n        collector.collect(node)\n        state.found = true\n      }\n    }\n\n    exit()\n  }\n\n  /**\n   * @template {SelectState} S\n   * @param {Rule} query\n   * @param {S} state\n   * @returns {S}\n   */\n  function configure(query, state) {\n    const pseudos = query.pseudos || []\n    let index = -1\n\n    while (++index < pseudos.length) {\n      if (pseudo.needsIndex.includes(pseudos[index].name)) {\n        state.index = true\n        break\n      }\n    }\n\n    return state\n  }\n}\n\n// Shouldn’t be called, all data is handled.\n/* c8 ignore next 6 */\n/**\n * @param {{[x: string]: unknown, type: string}} query\n */\nfunction unknownType(query) {\n  throw new Error('Unknown type `' + query.type + '`')\n}\n\n// Shouldn’t be called, parser gives correct data.\n/* c8 ignore next 3 */\nfunction invalidType() {\n  throw new Error('Invalid type')\n}\n\nclass Collector {\n  /**\n   * @param {boolean|undefined} [one]\n   */\n  constructor(one) {\n    /** @type {Array<Element>} */\n    this.result = []\n    /** @type {boolean|undefined} */\n    this.one = one\n    /** @type {boolean} */\n    this.found = false\n  }\n\n  /**\n   * Append nodes to array, filtering out duplicates.\n   *\n   * @param {Array<Element>} elements\n   */\n  collectAll(elements) {\n    let index = -1\n\n    while (++index < elements.length) {\n      this.collect(elements[index])\n    }\n  }\n\n  /**\n   * Append one node.\n   *\n   * @param {Element} element\n   */\n  collect(element) {\n    if (this.one) {\n      // Shouldn’t happen, safeguards performance problems.\n      /* c8 ignore next */\n      if (this.found) return\n      this.found = true\n    }\n\n    if (!this.result.includes(element)) this.result.push(element)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}