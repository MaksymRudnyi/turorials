{"ast":null,"code":"/*!\n * proxy-addr\n * Copyright(c) 2014-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n'use strict';\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = proxyaddr;\nmodule.exports.all = alladdrs;\nmodule.exports.compile = compile;\n/**\n * Module dependencies.\n * @private\n */\n\nvar forwarded = require('forwarded');\n\nvar ipaddr = require('ipaddr.js');\n/**\n * Variables.\n * @private\n */\n\n\nvar DIGIT_REGEXP = /^[0-9]+$/;\nvar isip = ipaddr.isValid;\nvar parseip = ipaddr.parse;\n/**\n * Pre-defined IP ranges.\n * @private\n */\n\nvar IP_RANGES = {\n  linklocal: ['169.254.0.0/16', 'fe80::/10'],\n  loopback: ['127.0.0.1/8', '::1/128'],\n  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']\n};\n/**\n * Get all addresses in the request, optionally stopping\n * at the first untrusted.\n *\n * @param {Object} request\n * @param {Function|Array|String} [trust]\n * @public\n */\n\nfunction alladdrs(req, trust) {\n  // get addresses\n  var addrs = forwarded(req);\n\n  if (!trust) {\n    // Return all addresses\n    return addrs;\n  }\n\n  if (typeof trust !== 'function') {\n    trust = compile(trust);\n  }\n\n  for (var i = 0; i < addrs.length - 1; i++) {\n    if (trust(addrs[i], i)) continue;\n    addrs.length = i + 1;\n  }\n\n  return addrs;\n}\n/**\n * Compile argument into trust function.\n *\n * @param {Array|String} val\n * @private\n */\n\n\nfunction compile(val) {\n  if (!val) {\n    throw new TypeError('argument is required');\n  }\n\n  var trust;\n\n  if (typeof val === 'string') {\n    trust = [val];\n  } else if (Array.isArray(val)) {\n    trust = val.slice();\n  } else {\n    throw new TypeError('unsupported trust argument');\n  }\n\n  for (var i = 0; i < trust.length; i++) {\n    val = trust[i];\n\n    if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {\n      continue;\n    } // Splice in pre-defined range\n\n\n    val = IP_RANGES[val];\n    trust.splice.apply(trust, [i, 1].concat(val));\n    i += val.length - 1;\n  }\n\n  return compileTrust(compileRangeSubnets(trust));\n}\n/**\n * Compile `arr` elements into range subnets.\n *\n * @param {Array} arr\n * @private\n */\n\n\nfunction compileRangeSubnets(arr) {\n  var rangeSubnets = new Array(arr.length);\n\n  for (var i = 0; i < arr.length; i++) {\n    rangeSubnets[i] = parseipNotation(arr[i]);\n  }\n\n  return rangeSubnets;\n}\n/**\n * Compile range subnet array into trust function.\n *\n * @param {Array} rangeSubnets\n * @private\n */\n\n\nfunction compileTrust(rangeSubnets) {\n  // Return optimized function based on length\n  var len = rangeSubnets.length;\n  return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);\n}\n/**\n * Parse IP notation string into range subnet.\n *\n * @param {String} note\n * @private\n */\n\n\nfunction parseipNotation(note) {\n  var pos = note.lastIndexOf('/');\n  var str = pos !== -1 ? note.substring(0, pos) : note;\n\n  if (!isip(str)) {\n    throw new TypeError('invalid IP address: ' + str);\n  }\n\n  var ip = parseip(str);\n\n  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {\n    // Store as IPv4\n    ip = ip.toIPv4Address();\n  }\n\n  var max = ip.kind() === 'ipv6' ? 128 : 32;\n  var range = pos !== -1 ? note.substring(pos + 1, note.length) : null;\n\n  if (range === null) {\n    range = max;\n  } else if (DIGIT_REGEXP.test(range)) {\n    range = parseInt(range, 10);\n  } else if (ip.kind() === 'ipv4' && isip(range)) {\n    range = parseNetmask(range);\n  } else {\n    range = null;\n  }\n\n  if (range <= 0 || range > max) {\n    throw new TypeError('invalid range on address: ' + note);\n  }\n\n  return [ip, range];\n}\n/**\n * Parse netmask string into CIDR range.\n *\n * @param {String} netmask\n * @private\n */\n\n\nfunction parseNetmask(netmask) {\n  var ip = parseip(netmask);\n  var kind = ip.kind();\n  return kind === 'ipv4' ? ip.prefixLengthFromSubnetMask() : null;\n}\n/**\n * Determine address of proxied request.\n *\n * @param {Object} request\n * @param {Function|Array|String} trust\n * @public\n */\n\n\nfunction proxyaddr(req, trust) {\n  if (!req) {\n    throw new TypeError('req argument is required');\n  }\n\n  if (!trust) {\n    throw new TypeError('trust argument is required');\n  }\n\n  var addrs = alladdrs(req, trust);\n  var addr = addrs[addrs.length - 1];\n  return addr;\n}\n/**\n * Static trust function to trust nothing.\n *\n * @private\n */\n\n\nfunction trustNone() {\n  return false;\n}\n/**\n * Compile trust function for multiple subnets.\n *\n * @param {Array} subnets\n * @private\n */\n\n\nfunction trustMulti(subnets) {\n  return function trust(addr) {\n    if (!isip(addr)) return false;\n    var ip = parseip(addr);\n    var ipconv;\n    var kind = ip.kind();\n\n    for (var i = 0; i < subnets.length; i++) {\n      var subnet = subnets[i];\n      var subnetip = subnet[0];\n      var subnetkind = subnetip.kind();\n      var subnetrange = subnet[1];\n      var trusted = ip;\n\n      if (kind !== subnetkind) {\n        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {\n          // Incompatible IP addresses\n          continue;\n        }\n\n        if (!ipconv) {\n          // Convert IP to match subnet IP kind\n          ipconv = subnetkind === 'ipv4' ? ip.toIPv4Address() : ip.toIPv4MappedAddress();\n        }\n\n        trusted = ipconv;\n      }\n\n      if (trusted.match(subnetip, subnetrange)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n}\n/**\n * Compile trust function for single subnet.\n *\n * @param {Object} subnet\n * @private\n */\n\n\nfunction trustSingle(subnet) {\n  var subnetip = subnet[0];\n  var subnetkind = subnetip.kind();\n  var subnetisipv4 = subnetkind === 'ipv4';\n  var subnetrange = subnet[1];\n  return function trust(addr) {\n    if (!isip(addr)) return false;\n    var ip = parseip(addr);\n    var kind = ip.kind();\n\n    if (kind !== subnetkind) {\n      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {\n        // Incompatible IP addresses\n        return false;\n      } // Convert IP to match subnet IP kind\n\n\n      ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();\n    }\n\n    return ip.match(subnetip, subnetrange);\n  };\n}","map":{"version":3,"names":["module","exports","proxyaddr","all","alladdrs","compile","forwarded","require","ipaddr","DIGIT_REGEXP","isip","isValid","parseip","parse","IP_RANGES","linklocal","loopback","uniquelocal","req","trust","addrs","i","length","val","TypeError","Array","isArray","slice","Object","prototype","hasOwnProperty","call","splice","apply","concat","compileTrust","compileRangeSubnets","arr","rangeSubnets","parseipNotation","len","trustNone","trustSingle","trustMulti","note","pos","lastIndexOf","str","substring","ip","kind","isIPv4MappedAddress","toIPv4Address","max","range","test","parseInt","parseNetmask","netmask","prefixLengthFromSubnetMask","addr","subnets","ipconv","subnet","subnetip","subnetkind","subnetrange","trusted","toIPv4MappedAddress","match","subnetisipv4"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/server/node_modules/proxy-addr/index.js"],"sourcesContent":["/*!\n * proxy-addr\n * Copyright(c) 2014-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = proxyaddr\nmodule.exports.all = alladdrs\nmodule.exports.compile = compile\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar forwarded = require('forwarded')\nvar ipaddr = require('ipaddr.js')\n\n/**\n * Variables.\n * @private\n */\n\nvar DIGIT_REGEXP = /^[0-9]+$/\nvar isip = ipaddr.isValid\nvar parseip = ipaddr.parse\n\n/**\n * Pre-defined IP ranges.\n * @private\n */\n\nvar IP_RANGES = {\n  linklocal: ['169.254.0.0/16', 'fe80::/10'],\n  loopback: ['127.0.0.1/8', '::1/128'],\n  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']\n}\n\n/**\n * Get all addresses in the request, optionally stopping\n * at the first untrusted.\n *\n * @param {Object} request\n * @param {Function|Array|String} [trust]\n * @public\n */\n\nfunction alladdrs (req, trust) {\n  // get addresses\n  var addrs = forwarded(req)\n\n  if (!trust) {\n    // Return all addresses\n    return addrs\n  }\n\n  if (typeof trust !== 'function') {\n    trust = compile(trust)\n  }\n\n  for (var i = 0; i < addrs.length - 1; i++) {\n    if (trust(addrs[i], i)) continue\n\n    addrs.length = i + 1\n  }\n\n  return addrs\n}\n\n/**\n * Compile argument into trust function.\n *\n * @param {Array|String} val\n * @private\n */\n\nfunction compile (val) {\n  if (!val) {\n    throw new TypeError('argument is required')\n  }\n\n  var trust\n\n  if (typeof val === 'string') {\n    trust = [val]\n  } else if (Array.isArray(val)) {\n    trust = val.slice()\n  } else {\n    throw new TypeError('unsupported trust argument')\n  }\n\n  for (var i = 0; i < trust.length; i++) {\n    val = trust[i]\n\n    if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {\n      continue\n    }\n\n    // Splice in pre-defined range\n    val = IP_RANGES[val]\n    trust.splice.apply(trust, [i, 1].concat(val))\n    i += val.length - 1\n  }\n\n  return compileTrust(compileRangeSubnets(trust))\n}\n\n/**\n * Compile `arr` elements into range subnets.\n *\n * @param {Array} arr\n * @private\n */\n\nfunction compileRangeSubnets (arr) {\n  var rangeSubnets = new Array(arr.length)\n\n  for (var i = 0; i < arr.length; i++) {\n    rangeSubnets[i] = parseipNotation(arr[i])\n  }\n\n  return rangeSubnets\n}\n\n/**\n * Compile range subnet array into trust function.\n *\n * @param {Array} rangeSubnets\n * @private\n */\n\nfunction compileTrust (rangeSubnets) {\n  // Return optimized function based on length\n  var len = rangeSubnets.length\n  return len === 0\n    ? trustNone\n    : len === 1\n      ? trustSingle(rangeSubnets[0])\n      : trustMulti(rangeSubnets)\n}\n\n/**\n * Parse IP notation string into range subnet.\n *\n * @param {String} note\n * @private\n */\n\nfunction parseipNotation (note) {\n  var pos = note.lastIndexOf('/')\n  var str = pos !== -1\n    ? note.substring(0, pos)\n    : note\n\n  if (!isip(str)) {\n    throw new TypeError('invalid IP address: ' + str)\n  }\n\n  var ip = parseip(str)\n\n  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {\n    // Store as IPv4\n    ip = ip.toIPv4Address()\n  }\n\n  var max = ip.kind() === 'ipv6'\n    ? 128\n    : 32\n\n  var range = pos !== -1\n    ? note.substring(pos + 1, note.length)\n    : null\n\n  if (range === null) {\n    range = max\n  } else if (DIGIT_REGEXP.test(range)) {\n    range = parseInt(range, 10)\n  } else if (ip.kind() === 'ipv4' && isip(range)) {\n    range = parseNetmask(range)\n  } else {\n    range = null\n  }\n\n  if (range <= 0 || range > max) {\n    throw new TypeError('invalid range on address: ' + note)\n  }\n\n  return [ip, range]\n}\n\n/**\n * Parse netmask string into CIDR range.\n *\n * @param {String} netmask\n * @private\n */\n\nfunction parseNetmask (netmask) {\n  var ip = parseip(netmask)\n  var kind = ip.kind()\n\n  return kind === 'ipv4'\n    ? ip.prefixLengthFromSubnetMask()\n    : null\n}\n\n/**\n * Determine address of proxied request.\n *\n * @param {Object} request\n * @param {Function|Array|String} trust\n * @public\n */\n\nfunction proxyaddr (req, trust) {\n  if (!req) {\n    throw new TypeError('req argument is required')\n  }\n\n  if (!trust) {\n    throw new TypeError('trust argument is required')\n  }\n\n  var addrs = alladdrs(req, trust)\n  var addr = addrs[addrs.length - 1]\n\n  return addr\n}\n\n/**\n * Static trust function to trust nothing.\n *\n * @private\n */\n\nfunction trustNone () {\n  return false\n}\n\n/**\n * Compile trust function for multiple subnets.\n *\n * @param {Array} subnets\n * @private\n */\n\nfunction trustMulti (subnets) {\n  return function trust (addr) {\n    if (!isip(addr)) return false\n\n    var ip = parseip(addr)\n    var ipconv\n    var kind = ip.kind()\n\n    for (var i = 0; i < subnets.length; i++) {\n      var subnet = subnets[i]\n      var subnetip = subnet[0]\n      var subnetkind = subnetip.kind()\n      var subnetrange = subnet[1]\n      var trusted = ip\n\n      if (kind !== subnetkind) {\n        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {\n          // Incompatible IP addresses\n          continue\n        }\n\n        if (!ipconv) {\n          // Convert IP to match subnet IP kind\n          ipconv = subnetkind === 'ipv4'\n            ? ip.toIPv4Address()\n            : ip.toIPv4MappedAddress()\n        }\n\n        trusted = ipconv\n      }\n\n      if (trusted.match(subnetip, subnetrange)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\n/**\n * Compile trust function for single subnet.\n *\n * @param {Object} subnet\n * @private\n */\n\nfunction trustSingle (subnet) {\n  var subnetip = subnet[0]\n  var subnetkind = subnetip.kind()\n  var subnetisipv4 = subnetkind === 'ipv4'\n  var subnetrange = subnet[1]\n\n  return function trust (addr) {\n    if (!isip(addr)) return false\n\n    var ip = parseip(addr)\n    var kind = ip.kind()\n\n    if (kind !== subnetkind) {\n      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {\n        // Incompatible IP addresses\n        return false\n      }\n\n      // Convert IP to match subnet IP kind\n      ip = subnetisipv4\n        ? ip.toIPv4Address()\n        : ip.toIPv4MappedAddress()\n    }\n\n    return ip.match(subnetip, subnetrange)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}