{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownSpace } from 'micromark-util-character';\n/** @type {Construct} */\n\nexport const blockQuote = {\n  name: 'blockQuote',\n  tokenize: tokenizeBlockQuoteStart,\n  continuation: {\n    tokenize: tokenizeBlockQuoteContinuation\n  },\n  exit\n};\n/** @type {Tokenizer} */\n\nfunction tokenizeBlockQuoteStart(effects, ok, nok) {\n  const self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (code === 62) {\n      const state = self.containerState;\n\n      if (!state.open) {\n        effects.enter('blockQuote', {\n          _container: true\n        });\n        state.open = true;\n      }\n\n      effects.enter('blockQuotePrefix');\n      effects.enter('blockQuoteMarker');\n      effects.consume(code);\n      effects.exit('blockQuoteMarker');\n      return after;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    if (markdownSpace(code)) {\n      effects.enter('blockQuotePrefixWhitespace');\n      effects.consume(code);\n      effects.exit('blockQuotePrefixWhitespace');\n      effects.exit('blockQuotePrefix');\n      return ok;\n    }\n\n    effects.exit('blockQuotePrefix');\n    return ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeBlockQuoteContinuation(effects, ok, nok) {\n  return factorySpace(effects, effects.attempt(blockQuote, ok, nok), 'linePrefix', this.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4);\n}\n/** @type {Exiter} */\n\n\nfunction exit(effects) {\n  effects.exit('blockQuote');\n}","map":{"version":3,"names":["factorySpace","markdownSpace","blockQuote","name","tokenize","tokenizeBlockQuoteStart","continuation","tokenizeBlockQuoteContinuation","exit","effects","ok","nok","self","start","code","state","containerState","open","enter","_container","consume","after","attempt","parser","constructs","disable","null","includes","undefined"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/micromark-core-commonmark/lib/block-quote.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownSpace} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const blockQuote = {\n  name: 'blockQuote',\n  tokenize: tokenizeBlockQuoteStart,\n  continuation: {\n    tokenize: tokenizeBlockQuoteContinuation\n  },\n  exit\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeBlockQuoteStart(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (code === 62) {\n      const state = self.containerState\n\n      if (!state.open) {\n        effects.enter('blockQuote', {\n          _container: true\n        })\n        state.open = true\n      }\n\n      effects.enter('blockQuotePrefix')\n      effects.enter('blockQuoteMarker')\n      effects.consume(code)\n      effects.exit('blockQuoteMarker')\n      return after\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    if (markdownSpace(code)) {\n      effects.enter('blockQuotePrefixWhitespace')\n      effects.consume(code)\n      effects.exit('blockQuotePrefixWhitespace')\n      effects.exit('blockQuotePrefix')\n      return ok\n    }\n\n    effects.exit('blockQuotePrefix')\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeBlockQuoteContinuation(effects, ok, nok) {\n  return factorySpace(\n    effects,\n    effects.attempt(blockQuote, ok, nok),\n    'linePrefix',\n    this.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4\n  )\n}\n/** @type {Exiter} */\n\nfunction exit(effects) {\n  effects.exit('blockQuote')\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQA,YAAR,QAA2B,yBAA3B;AACA,SAAQC,aAAR,QAA4B,0BAA5B;AAEA;;AACA,OAAO,MAAMC,UAAU,GAAG;EACxBC,IAAI,EAAE,YADkB;EAExBC,QAAQ,EAAEC,uBAFc;EAGxBC,YAAY,EAAE;IACZF,QAAQ,EAAEG;EADE,CAHU;EAMxBC;AANwB,CAAnB;AAQP;;AAEA,SAASH,uBAAT,CAAiCI,OAAjC,EAA0CC,EAA1C,EAA8CC,GAA9C,EAAmD;EACjD,MAAMC,IAAI,GAAG,IAAb;EACA,OAAOC,KAAP;EACA;;EAEA,SAASA,KAAT,CAAeC,IAAf,EAAqB;IACnB,IAAIA,IAAI,KAAK,EAAb,EAAiB;MACf,MAAMC,KAAK,GAAGH,IAAI,CAACI,cAAnB;;MAEA,IAAI,CAACD,KAAK,CAACE,IAAX,EAAiB;QACfR,OAAO,CAACS,KAAR,CAAc,YAAd,EAA4B;UAC1BC,UAAU,EAAE;QADc,CAA5B;QAGAJ,KAAK,CAACE,IAAN,GAAa,IAAb;MACD;;MAEDR,OAAO,CAACS,KAAR,CAAc,kBAAd;MACAT,OAAO,CAACS,KAAR,CAAc,kBAAd;MACAT,OAAO,CAACW,OAAR,CAAgBN,IAAhB;MACAL,OAAO,CAACD,IAAR,CAAa,kBAAb;MACA,OAAOa,KAAP;IACD;;IAED,OAAOV,GAAG,CAACG,IAAD,CAAV;EACD;EACD;;;EAEA,SAASO,KAAT,CAAeP,IAAf,EAAqB;IACnB,IAAIb,aAAa,CAACa,IAAD,CAAjB,EAAyB;MACvBL,OAAO,CAACS,KAAR,CAAc,4BAAd;MACAT,OAAO,CAACW,OAAR,CAAgBN,IAAhB;MACAL,OAAO,CAACD,IAAR,CAAa,4BAAb;MACAC,OAAO,CAACD,IAAR,CAAa,kBAAb;MACA,OAAOE,EAAP;IACD;;IAEDD,OAAO,CAACD,IAAR,CAAa,kBAAb;IACA,OAAOE,EAAE,CAACI,IAAD,CAAT;EACD;AACF;AACD;;;AAEA,SAASP,8BAAT,CAAwCE,OAAxC,EAAiDC,EAAjD,EAAqDC,GAArD,EAA0D;EACxD,OAAOX,YAAY,CACjBS,OADiB,EAEjBA,OAAO,CAACa,OAAR,CAAgBpB,UAAhB,EAA4BQ,EAA5B,EAAgCC,GAAhC,CAFiB,EAGjB,YAHiB,EAIjB,KAAKY,MAAL,CAAYC,UAAZ,CAAuBC,OAAvB,CAA+BC,IAA/B,CAAoCC,QAApC,CAA6C,cAA7C,IAA+DC,SAA/D,GAA2E,CAJ1D,CAAnB;AAMD;AACD;;;AAEA,SAASpB,IAAT,CAAcC,OAAd,EAAuB;EACrBA,OAAO,CAACD,IAAR,CAAa,YAAb;AACD"},"metadata":{},"sourceType":"module"}