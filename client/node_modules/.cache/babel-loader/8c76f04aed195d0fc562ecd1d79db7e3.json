{"ast":null,"code":"/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('property-information').Schema} Schema\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {import('hast').Parent} Parent\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').DocType} Doctype\n * @typedef {Parent['children'][number]} Child\n * @typedef {Element['children'][number]} ElementChild\n * @typedef {Child|Root} Node\n * @typedef {import('parse5').Document} P5Document\n * @typedef {import('parse5').DocumentType} P5Doctype\n * @typedef {import('parse5').CommentNode} P5Comment\n * @typedef {import('parse5').TextNode} P5Text\n * @typedef {import('parse5').Element} P5Element\n * @typedef {import('parse5').ElementLocation} P5ElementLocation\n * @typedef {import('parse5').Location} P5Location\n * @typedef {import('parse5').Attribute} P5Attribute\n * @typedef {import('parse5').Node} P5Node\n *\n * @typedef {'html'|'svg'} Space\n *\n * @callback Handler\n * @param {Context} ctx\n * @param {P5Node} node\n * @param {Array.<Child>} [children]\n * @returns {Node}\n *\n * @typedef Options\n * @property {Space} [space='html'] Whether the root of the tree is in the `'html'` or `'svg'` space. If an element in with the SVG namespace is found in `ast`, `fromParse5` automatically switches to the SVG space when entering the element, and switches back when leaving\n * @property {VFile} [file] `VFile`, used to add positional information to nodes. If given, the file should have the original HTML source as its contents\n * @property {boolean} [verbose=false] Whether to add extra positional information about starting tags, closing tags, and attributes to elements. Note: not used without `file`\n *\n * @typedef Context\n * @property {Schema} schema\n * @property {VFile|undefined} file\n * @property {boolean|undefined} verbose\n * @property {boolean} location\n */\nimport { h, s } from 'hastscript';\nimport { html, svg, find } from 'property-information';\nimport { location } from 'vfile-location';\nimport { webNamespaces } from 'web-namespaces';\nconst own = {}.hasOwnProperty; // Handlers.\n\nconst map = {\n  '#document': root,\n  '#document-fragment': root,\n  '#text': text,\n  '#comment': comment,\n  '#documentType': doctype\n};\n/**\n * Transform Parse5’s AST to a hast tree.\n *\n * @param {P5Node} ast\n * @param {Options|VFile} [options]\n */\n\nexport function fromParse5(ast) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  /** @type {Options} */\n  let settings;\n  /** @type {VFile|undefined} */\n\n  let file;\n\n  if (isFile(options)) {\n    file = options;\n    settings = {};\n  } else {\n    file = options.file;\n    settings = options;\n  }\n\n  return transform({\n    schema: settings.space === 'svg' ? svg : html,\n    file,\n    verbose: settings.verbose,\n    location: false\n  }, ast);\n}\n/**\n * Transform children.\n *\n * @param {Context} ctx\n * @param {P5Node} ast\n * @returns {Node}\n */\n\nfunction transform(ctx, ast) {\n  const schema = ctx.schema;\n  /** @type {Handler} */\n  // @ts-expect-error: index is fine.\n\n  const fn = own.call(map, ast.nodeName) ? map[ast.nodeName] : element;\n  /** @type {Array.<Child>|undefined} */\n\n  let children; // Element.\n\n  if ('tagName' in ast) {\n    ctx.schema = ast.namespaceURI === webNamespaces.svg ? svg : html;\n  }\n\n  if ('childNodes' in ast) {\n    children = nodes(ctx, ast.childNodes);\n  }\n\n  const result = fn(ctx, ast, children);\n\n  if ('sourceCodeLocation' in ast && ast.sourceCodeLocation && ctx.file) {\n    // @ts-expect-error It’s fine.\n    const position = createLocation(ctx, result, ast.sourceCodeLocation);\n\n    if (position) {\n      ctx.location = true;\n      result.position = position;\n    }\n  }\n\n  ctx.schema = schema;\n  return result;\n}\n/**\n * Transform children.\n *\n * @param {Context} ctx\n * @param {Array.<P5Node>} children\n * @returns {Array.<Child>}\n */\n\n\nfunction nodes(ctx, children) {\n  let index = -1;\n  /** @type {Array.<Child>} */\n\n  const result = [];\n\n  while (++index < children.length) {\n    // @ts-expect-error Assume no roots in children.\n    result[index] = transform(ctx, children[index]);\n  }\n\n  return result;\n}\n/**\n * Transform a document.\n * Stores `ast.quirksMode` in `node.data.quirksMode`.\n *\n * @type {Handler}\n * @param {P5Document} ast\n * @param {Array.<Child>} children\n * @returns {Root}\n */\n\n\nfunction root(ctx, ast, children) {\n  /** @type {Root} */\n  const result = {\n    type: 'root',\n    children,\n    data: {\n      quirksMode: ast.mode === 'quirks' || ast.mode === 'limited-quirks'\n    }\n  };\n\n  if (ctx.file && ctx.location) {\n    const doc = String(ctx.file);\n    const loc = location(doc);\n    result.position = {\n      start: loc.toPoint(0),\n      end: loc.toPoint(doc.length)\n    };\n  }\n\n  return result;\n}\n/**\n * Transform a doctype.\n *\n * @type {Handler}\n * @returns {Doctype}\n */\n\n\nfunction doctype() {\n  // @ts-expect-error Types are out of date.\n  return {\n    type: 'doctype'\n  };\n}\n/**\n * Transform a text.\n *\n * @type {Handler}\n * @param {P5Text} ast\n * @returns {Text}\n */\n\n\nfunction text(_, ast) {\n  return {\n    type: 'text',\n    value: ast.value\n  };\n}\n/**\n * Transform a comment.\n *\n * @type {Handler}\n * @param {P5Comment} ast\n * @returns {Comment}\n */\n\n\nfunction comment(_, ast) {\n  return {\n    type: 'comment',\n    value: ast.data\n  };\n}\n/**\n * Transform an element.\n *\n * @type {Handler}\n * @param {P5Element} ast\n * @param {Array.<ElementChild>} children\n * @returns {Element}\n */\n\n\nfunction element(ctx, ast, children) {\n  const fn = ctx.schema.space === 'svg' ? s : h;\n  let index = -1;\n  /** @type {Object.<string, string>} */\n\n  const props = {};\n\n  while (++index < ast.attrs.length) {\n    const attribute = ast.attrs[index];\n    props[(attribute.prefix ? attribute.prefix + ':' : '') + attribute.name] = attribute.value;\n  }\n\n  const result = fn(ast.tagName, props, children);\n\n  if (result.tagName === 'template' && 'content' in ast) {\n    const pos = ast.sourceCodeLocation;\n    const startTag = pos && pos.startTag && position(pos.startTag);\n    const endTag = pos && pos.endTag && position(pos.endTag);\n    /** @type {Root} */\n    // @ts-expect-error Types are wrong.\n\n    const content = transform(ctx, ast.content);\n\n    if (startTag && endTag && ctx.file) {\n      content.position = {\n        start: startTag.end,\n        end: endTag.start\n      };\n    }\n\n    result.content = content;\n  }\n\n  return result;\n}\n/**\n * Create clean positional information.\n *\n * @param {Context} ctx\n * @param {Node} node\n * @param {P5ElementLocation} location\n * @returns {Position|null}\n */\n\n\nfunction createLocation(ctx, node, location) {\n  const result = position(location);\n\n  if (node.type === 'element') {\n    const tail = node.children[node.children.length - 1]; // Bug for unclosed with children.\n    // See: <https://github.com/inikulin/parse5/issues/109>.\n\n    if (result && !location.endTag && tail && tail.position && tail.position.end) {\n      result.end = Object.assign({}, tail.position.end);\n    }\n\n    if (ctx.verbose) {\n      /** @type {Object.<string, Position|null>} */\n      const props = {};\n      /** @type {string} */\n\n      let key;\n\n      for (key in location.attrs) {\n        if (own.call(location.attrs, key)) {\n          props[find(ctx.schema, key).property] = position(location.attrs[key]);\n        }\n      }\n\n      node.data = {\n        position: {\n          opening: position(location.startTag),\n          closing: location.endTag ? position(location.endTag) : null,\n          properties: props\n        }\n      };\n    }\n  }\n\n  return result;\n}\n/**\n * @param {P5Location} loc\n * @returns {Position|null}\n */\n\n\nfunction position(loc) {\n  const start = point({\n    line: loc.startLine,\n    column: loc.startCol,\n    offset: loc.startOffset\n  });\n  const end = point({\n    line: loc.endLine,\n    column: loc.endCol,\n    offset: loc.endOffset\n  }); // @ts-expect-error `null` is fine.\n\n  return start || end ? {\n    start,\n    end\n  } : null;\n}\n/**\n * @param {Point} point\n * @returns {Point|null}\n */\n\n\nfunction point(point) {\n  return point.line && point.column ? point : null;\n}\n/**\n * @param {VFile|Options} value\n * @returns {value is VFile}\n */\n\n\nfunction isFile(value) {\n  return 'messages' in value;\n}","map":{"version":3,"names":["h","s","html","svg","find","location","webNamespaces","own","hasOwnProperty","map","root","text","comment","doctype","fromParse5","ast","options","settings","file","isFile","transform","schema","space","verbose","ctx","fn","call","nodeName","element","children","namespaceURI","nodes","childNodes","result","sourceCodeLocation","position","createLocation","index","length","type","data","quirksMode","mode","doc","String","loc","start","toPoint","end","_","value","props","attrs","attribute","prefix","name","tagName","pos","startTag","endTag","content","node","tail","Object","assign","key","property","opening","closing","properties","point","line","startLine","column","startCol","offset","startOffset","endLine","endCol","endOffset"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/hast-util-from-parse5/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('property-information').Schema} Schema\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {import('hast').Parent} Parent\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').DocType} Doctype\n * @typedef {Parent['children'][number]} Child\n * @typedef {Element['children'][number]} ElementChild\n * @typedef {Child|Root} Node\n * @typedef {import('parse5').Document} P5Document\n * @typedef {import('parse5').DocumentType} P5Doctype\n * @typedef {import('parse5').CommentNode} P5Comment\n * @typedef {import('parse5').TextNode} P5Text\n * @typedef {import('parse5').Element} P5Element\n * @typedef {import('parse5').ElementLocation} P5ElementLocation\n * @typedef {import('parse5').Location} P5Location\n * @typedef {import('parse5').Attribute} P5Attribute\n * @typedef {import('parse5').Node} P5Node\n *\n * @typedef {'html'|'svg'} Space\n *\n * @callback Handler\n * @param {Context} ctx\n * @param {P5Node} node\n * @param {Array.<Child>} [children]\n * @returns {Node}\n *\n * @typedef Options\n * @property {Space} [space='html'] Whether the root of the tree is in the `'html'` or `'svg'` space. If an element in with the SVG namespace is found in `ast`, `fromParse5` automatically switches to the SVG space when entering the element, and switches back when leaving\n * @property {VFile} [file] `VFile`, used to add positional information to nodes. If given, the file should have the original HTML source as its contents\n * @property {boolean} [verbose=false] Whether to add extra positional information about starting tags, closing tags, and attributes to elements. Note: not used without `file`\n *\n * @typedef Context\n * @property {Schema} schema\n * @property {VFile|undefined} file\n * @property {boolean|undefined} verbose\n * @property {boolean} location\n */\n\nimport {h, s} from 'hastscript'\nimport {html, svg, find} from 'property-information'\nimport {location} from 'vfile-location'\nimport {webNamespaces} from 'web-namespaces'\n\nconst own = {}.hasOwnProperty\n\n// Handlers.\nconst map = {\n  '#document': root,\n  '#document-fragment': root,\n  '#text': text,\n  '#comment': comment,\n  '#documentType': doctype\n}\n\n/**\n * Transform Parse5’s AST to a hast tree.\n *\n * @param {P5Node} ast\n * @param {Options|VFile} [options]\n */\nexport function fromParse5(ast, options = {}) {\n  /** @type {Options} */\n  let settings\n  /** @type {VFile|undefined} */\n  let file\n\n  if (isFile(options)) {\n    file = options\n    settings = {}\n  } else {\n    file = options.file\n    settings = options\n  }\n\n  return transform(\n    {\n      schema: settings.space === 'svg' ? svg : html,\n      file,\n      verbose: settings.verbose,\n      location: false\n    },\n    ast\n  )\n}\n\n/**\n * Transform children.\n *\n * @param {Context} ctx\n * @param {P5Node} ast\n * @returns {Node}\n */\nfunction transform(ctx, ast) {\n  const schema = ctx.schema\n  /** @type {Handler} */\n  // @ts-expect-error: index is fine.\n  const fn = own.call(map, ast.nodeName) ? map[ast.nodeName] : element\n  /** @type {Array.<Child>|undefined} */\n  let children\n\n  // Element.\n  if ('tagName' in ast) {\n    ctx.schema = ast.namespaceURI === webNamespaces.svg ? svg : html\n  }\n\n  if ('childNodes' in ast) {\n    children = nodes(ctx, ast.childNodes)\n  }\n\n  const result = fn(ctx, ast, children)\n\n  if ('sourceCodeLocation' in ast && ast.sourceCodeLocation && ctx.file) {\n    // @ts-expect-error It’s fine.\n    const position = createLocation(ctx, result, ast.sourceCodeLocation)\n\n    if (position) {\n      ctx.location = true\n      result.position = position\n    }\n  }\n\n  ctx.schema = schema\n\n  return result\n}\n\n/**\n * Transform children.\n *\n * @param {Context} ctx\n * @param {Array.<P5Node>} children\n * @returns {Array.<Child>}\n */\nfunction nodes(ctx, children) {\n  let index = -1\n  /** @type {Array.<Child>} */\n  const result = []\n\n  while (++index < children.length) {\n    // @ts-expect-error Assume no roots in children.\n    result[index] = transform(ctx, children[index])\n  }\n\n  return result\n}\n\n/**\n * Transform a document.\n * Stores `ast.quirksMode` in `node.data.quirksMode`.\n *\n * @type {Handler}\n * @param {P5Document} ast\n * @param {Array.<Child>} children\n * @returns {Root}\n */\nfunction root(ctx, ast, children) {\n  /** @type {Root} */\n  const result = {\n    type: 'root',\n    children,\n    data: {quirksMode: ast.mode === 'quirks' || ast.mode === 'limited-quirks'}\n  }\n\n  if (ctx.file && ctx.location) {\n    const doc = String(ctx.file)\n    const loc = location(doc)\n    result.position = {\n      start: loc.toPoint(0),\n      end: loc.toPoint(doc.length)\n    }\n  }\n\n  return result\n}\n\n/**\n * Transform a doctype.\n *\n * @type {Handler}\n * @returns {Doctype}\n */\nfunction doctype() {\n  // @ts-expect-error Types are out of date.\n  return {type: 'doctype'}\n}\n\n/**\n * Transform a text.\n *\n * @type {Handler}\n * @param {P5Text} ast\n * @returns {Text}\n */\nfunction text(_, ast) {\n  return {type: 'text', value: ast.value}\n}\n\n/**\n * Transform a comment.\n *\n * @type {Handler}\n * @param {P5Comment} ast\n * @returns {Comment}\n */\nfunction comment(_, ast) {\n  return {type: 'comment', value: ast.data}\n}\n\n/**\n * Transform an element.\n *\n * @type {Handler}\n * @param {P5Element} ast\n * @param {Array.<ElementChild>} children\n * @returns {Element}\n */\nfunction element(ctx, ast, children) {\n  const fn = ctx.schema.space === 'svg' ? s : h\n  let index = -1\n  /** @type {Object.<string, string>} */\n  const props = {}\n\n  while (++index < ast.attrs.length) {\n    const attribute = ast.attrs[index]\n    props[(attribute.prefix ? attribute.prefix + ':' : '') + attribute.name] =\n      attribute.value\n  }\n\n  const result = fn(ast.tagName, props, children)\n\n  if (result.tagName === 'template' && 'content' in ast) {\n    const pos = ast.sourceCodeLocation\n    const startTag = pos && pos.startTag && position(pos.startTag)\n    const endTag = pos && pos.endTag && position(pos.endTag)\n\n    /** @type {Root} */\n    // @ts-expect-error Types are wrong.\n    const content = transform(ctx, ast.content)\n\n    if (startTag && endTag && ctx.file) {\n      content.position = {start: startTag.end, end: endTag.start}\n    }\n\n    result.content = content\n  }\n\n  return result\n}\n\n/**\n * Create clean positional information.\n *\n * @param {Context} ctx\n * @param {Node} node\n * @param {P5ElementLocation} location\n * @returns {Position|null}\n */\nfunction createLocation(ctx, node, location) {\n  const result = position(location)\n\n  if (node.type === 'element') {\n    const tail = node.children[node.children.length - 1]\n\n    // Bug for unclosed with children.\n    // See: <https://github.com/inikulin/parse5/issues/109>.\n    if (\n      result &&\n      !location.endTag &&\n      tail &&\n      tail.position &&\n      tail.position.end\n    ) {\n      result.end = Object.assign({}, tail.position.end)\n    }\n\n    if (ctx.verbose) {\n      /** @type {Object.<string, Position|null>} */\n      const props = {}\n      /** @type {string} */\n      let key\n\n      for (key in location.attrs) {\n        if (own.call(location.attrs, key)) {\n          props[find(ctx.schema, key).property] = position(location.attrs[key])\n        }\n      }\n\n      node.data = {\n        position: {\n          opening: position(location.startTag),\n          closing: location.endTag ? position(location.endTag) : null,\n          properties: props\n        }\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * @param {P5Location} loc\n * @returns {Position|null}\n */\nfunction position(loc) {\n  const start = point({\n    line: loc.startLine,\n    column: loc.startCol,\n    offset: loc.startOffset\n  })\n  const end = point({\n    line: loc.endLine,\n    column: loc.endCol,\n    offset: loc.endOffset\n  })\n  // @ts-expect-error `null` is fine.\n  return start || end ? {start, end} : null\n}\n\n/**\n * @param {Point} point\n * @returns {Point|null}\n */\nfunction point(point) {\n  return point.line && point.column ? point : null\n}\n\n/**\n * @param {VFile|Options} value\n * @returns {value is VFile}\n */\nfunction isFile(value) {\n  return 'messages' in value\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}