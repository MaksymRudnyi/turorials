{"ast":null,"code":"/*!\n * body-parser\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n'use strict';\n/**\n * Module dependencies.\n */\n\nvar bytes = require('bytes');\n\nvar debug = require('debug')('body-parser:raw');\n\nvar read = require('../read');\n\nvar typeis = require('type-is');\n/**\n * Module exports.\n */\n\n\nmodule.exports = raw;\n/**\n * Create a middleware to parse raw bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @api public\n */\n\nfunction raw(options) {\n  var opts = options || {};\n  var inflate = opts.inflate !== false;\n  var limit = typeof opts.limit !== 'number' ? bytes.parse(opts.limit || '100kb') : opts.limit;\n  var type = opts.type || 'application/octet-stream';\n  var verify = opts.verify || false;\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function');\n  } // create the appropriate type checking function\n\n\n  var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;\n\n  function parse(buf) {\n    return buf;\n  }\n\n  return function rawParser(req, res, next) {\n    if (req._body) {\n      debug('body already parsed');\n      next();\n      return;\n    }\n\n    req.body = req.body || {}; // skip requests without bodies\n\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body');\n      next();\n      return;\n    }\n\n    debug('content-type %j', req.headers['content-type']); // determine if request should be parsed\n\n    if (!shouldParse(req)) {\n      debug('skip parsing');\n      next();\n      return;\n    } // read\n\n\n    read(req, res, next, parse, debug, {\n      encoding: null,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    });\n  };\n}\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\n\nfunction typeChecker(type) {\n  return function checkType(req) {\n    return Boolean(typeis(req, type));\n  };\n}","map":{"version":3,"names":["bytes","require","debug","read","typeis","module","exports","raw","options","opts","inflate","limit","parse","type","verify","TypeError","shouldParse","typeChecker","buf","rawParser","req","res","next","_body","body","hasBody","headers","encoding","checkType","Boolean"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/server/node_modules/body-parser/lib/types/raw.js"],"sourcesContent":["/*!\n * body-parser\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n */\n\nvar bytes = require('bytes')\nvar debug = require('debug')('body-parser:raw')\nvar read = require('../read')\nvar typeis = require('type-is')\n\n/**\n * Module exports.\n */\n\nmodule.exports = raw\n\n/**\n * Create a middleware to parse raw bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @api public\n */\n\nfunction raw (options) {\n  var opts = options || {}\n\n  var inflate = opts.inflate !== false\n  var limit = typeof opts.limit !== 'number'\n    ? bytes.parse(opts.limit || '100kb')\n    : opts.limit\n  var type = opts.type || 'application/octet-stream'\n  var verify = opts.verify || false\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function')\n  }\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function'\n    ? typeChecker(type)\n    : type\n\n  function parse (buf) {\n    return buf\n  }\n\n  return function rawParser (req, res, next) {\n    if (req._body) {\n      debug('body already parsed')\n      next()\n      return\n    }\n\n    req.body = req.body || {}\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body')\n      next()\n      return\n    }\n\n    debug('content-type %j', req.headers['content-type'])\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing')\n      next()\n      return\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      encoding: null,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    })\n  }\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\nfunction typeChecker (type) {\n  return function checkType (req) {\n    return Boolean(typeis(req, type))\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAnB;;AACA,IAAIC,KAAK,GAAGD,OAAO,CAAC,OAAD,CAAP,CAAiB,iBAAjB,CAAZ;;AACA,IAAIE,IAAI,GAAGF,OAAO,CAAC,SAAD,CAAlB;;AACA,IAAIG,MAAM,GAAGH,OAAO,CAAC,SAAD,CAApB;AAEA;AACA;AACA;;;AAEAI,MAAM,CAACC,OAAP,GAAiBC,GAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,GAAT,CAAcC,OAAd,EAAuB;EACrB,IAAIC,IAAI,GAAGD,OAAO,IAAI,EAAtB;EAEA,IAAIE,OAAO,GAAGD,IAAI,CAACC,OAAL,KAAiB,KAA/B;EACA,IAAIC,KAAK,GAAG,OAAOF,IAAI,CAACE,KAAZ,KAAsB,QAAtB,GACRX,KAAK,CAACY,KAAN,CAAYH,IAAI,CAACE,KAAL,IAAc,OAA1B,CADQ,GAERF,IAAI,CAACE,KAFT;EAGA,IAAIE,IAAI,GAAGJ,IAAI,CAACI,IAAL,IAAa,0BAAxB;EACA,IAAIC,MAAM,GAAGL,IAAI,CAACK,MAAL,IAAe,KAA5B;;EAEA,IAAIA,MAAM,KAAK,KAAX,IAAoB,OAAOA,MAAP,KAAkB,UAA1C,EAAsD;IACpD,MAAM,IAAIC,SAAJ,CAAc,gCAAd,CAAN;EACD,CAZoB,CAcrB;;;EACA,IAAIC,WAAW,GAAG,OAAOH,IAAP,KAAgB,UAAhB,GACdI,WAAW,CAACJ,IAAD,CADG,GAEdA,IAFJ;;EAIA,SAASD,KAAT,CAAgBM,GAAhB,EAAqB;IACnB,OAAOA,GAAP;EACD;;EAED,OAAO,SAASC,SAAT,CAAoBC,GAApB,EAAyBC,GAAzB,EAA8BC,IAA9B,EAAoC;IACzC,IAAIF,GAAG,CAACG,KAAR,EAAe;MACbrB,KAAK,CAAC,qBAAD,CAAL;MACAoB,IAAI;MACJ;IACD;;IAEDF,GAAG,CAACI,IAAJ,GAAWJ,GAAG,CAACI,IAAJ,IAAY,EAAvB,CAPyC,CASzC;;IACA,IAAI,CAACpB,MAAM,CAACqB,OAAP,CAAeL,GAAf,CAAL,EAA0B;MACxBlB,KAAK,CAAC,iBAAD,CAAL;MACAoB,IAAI;MACJ;IACD;;IAEDpB,KAAK,CAAC,iBAAD,EAAoBkB,GAAG,CAACM,OAAJ,CAAY,cAAZ,CAApB,CAAL,CAhByC,CAkBzC;;IACA,IAAI,CAACV,WAAW,CAACI,GAAD,CAAhB,EAAuB;MACrBlB,KAAK,CAAC,cAAD,CAAL;MACAoB,IAAI;MACJ;IACD,CAvBwC,CAyBzC;;;IACAnB,IAAI,CAACiB,GAAD,EAAMC,GAAN,EAAWC,IAAX,EAAiBV,KAAjB,EAAwBV,KAAxB,EAA+B;MACjCyB,QAAQ,EAAE,IADuB;MAEjCjB,OAAO,EAAEA,OAFwB;MAGjCC,KAAK,EAAEA,KAH0B;MAIjCG,MAAM,EAAEA;IAJyB,CAA/B,CAAJ;EAMD,CAhCD;AAiCD;AAED;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASG,WAAT,CAAsBJ,IAAtB,EAA4B;EAC1B,OAAO,SAASe,SAAT,CAAoBR,GAApB,EAAyB;IAC9B,OAAOS,OAAO,CAACzB,MAAM,CAACgB,GAAD,EAAMP,IAAN,CAAP,CAAd;EACD,CAFD;AAGD"},"metadata":{},"sourceType":"script"}