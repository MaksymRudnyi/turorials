{"ast":null,"code":"function words(str) {\n  var obj = {},\n      words = str.split(\" \");\n\n  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n\n  return obj;\n}\n\nvar blockKeywordsStr = \"body catch class do else enum for foreach foreach_reverse if in interface mixin \" + \"out scope struct switch try union unittest version while with\";\nconst parserConfig = {\n  keywords: words(\"abstract alias align asm assert auto break case cast cdouble cent cfloat const continue \" + \"debug default delegate delete deprecated export extern final finally function goto immutable \" + \"import inout invariant is lazy macro module new nothrow override package pragma private \" + \"protected public pure ref return shared short static super synchronized template this \" + \"throw typedef typeid typeof volatile __FILE__ __LINE__ __gshared __traits __vector __parameters \" + blockKeywordsStr),\n  blockKeywords: words(blockKeywordsStr),\n  builtin: words(\"bool byte char creal dchar double float idouble ifloat int ireal long real short ubyte \" + \"ucent uint ulong ushort wchar wstring void size_t sizediff_t\"),\n  atoms: words(\"exit failure success true false null\"),\n  hooks: {\n    \"@\": function (stream, _state) {\n      stream.eatWhile(/[\\w\\$_]/);\n      return \"meta\";\n    }\n  }\n};\nvar statementIndentUnit = parserConfig.statementIndentUnit,\n    keywords = parserConfig.keywords,\n    builtin = parserConfig.builtin,\n    blockKeywords = parserConfig.blockKeywords,\n    atoms = parserConfig.atoms,\n    hooks = parserConfig.hooks,\n    multiLineStrings = parserConfig.multiLineStrings;\nvar isOperatorChar = /[+\\-*&%=<>!?|\\/]/;\nvar curPunc;\n\nfunction tokenBase(stream, state) {\n  var ch = stream.next();\n\n  if (hooks[ch]) {\n    var result = hooks[ch](stream, state);\n    if (result !== false) return result;\n  }\n\n  if (ch == '\"' || ch == \"'\" || ch == \"`\") {\n    state.tokenize = tokenString(ch);\n    return state.tokenize(stream, state);\n  }\n\n  if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n    curPunc = ch;\n    return null;\n  }\n\n  if (/\\d/.test(ch)) {\n    stream.eatWhile(/[\\w\\.]/);\n    return \"number\";\n  }\n\n  if (ch == \"/\") {\n    if (stream.eat(\"+\")) {\n      state.tokenize = tokenNestedComment;\n      return tokenNestedComment(stream, state);\n    }\n\n    if (stream.eat(\"*\")) {\n      state.tokenize = tokenComment;\n      return tokenComment(stream, state);\n    }\n\n    if (stream.eat(\"/\")) {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n  }\n\n  if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return \"operator\";\n  }\n\n  stream.eatWhile(/[\\w\\$_\\xa1-\\uffff]/);\n  var cur = stream.current();\n\n  if (keywords.propertyIsEnumerable(cur)) {\n    if (blockKeywords.propertyIsEnumerable(cur)) curPunc = \"newstatement\";\n    return \"keyword\";\n  }\n\n  if (builtin.propertyIsEnumerable(cur)) {\n    if (blockKeywords.propertyIsEnumerable(cur)) curPunc = \"newstatement\";\n    return \"builtin\";\n  }\n\n  if (atoms.propertyIsEnumerable(cur)) return \"atom\";\n  return \"variable\";\n}\n\nfunction tokenString(quote) {\n  return function (stream, state) {\n    var escaped = false,\n        next,\n        end = false;\n\n    while ((next = stream.next()) != null) {\n      if (next == quote && !escaped) {\n        end = true;\n        break;\n      }\n\n      escaped = !escaped && next == \"\\\\\";\n    }\n\n    if (end || !(escaped || multiLineStrings)) state.tokenize = null;\n    return \"string\";\n  };\n}\n\nfunction tokenComment(stream, state) {\n  var maybeEnd = false,\n      ch;\n\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = null;\n      break;\n    }\n\n    maybeEnd = ch == \"*\";\n  }\n\n  return \"comment\";\n}\n\nfunction tokenNestedComment(stream, state) {\n  var maybeEnd = false,\n      ch;\n\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = null;\n      break;\n    }\n\n    maybeEnd = ch == \"+\";\n  }\n\n  return \"comment\";\n}\n\nfunction Context(indented, column, type, align, prev) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.align = align;\n  this.prev = prev;\n}\n\nfunction pushContext(state, col, type) {\n  var indent = state.indented;\n  if (state.context && state.context.type == \"statement\") indent = state.context.indented;\n  return state.context = new Context(indent, col, type, null, state.context);\n}\n\nfunction popContext(state) {\n  var t = state.context.type;\n  if (t == \")\" || t == \"]\" || t == \"}\") state.indented = state.context.indented;\n  return state.context = state.context.prev;\n} // Interface\n\n\nexport const d = {\n  startState: function (indentUnit) {\n    return {\n      tokenize: null,\n      context: new Context(-indentUnit, 0, \"top\", false),\n      indented: 0,\n      startOfLine: true\n    };\n  },\n  token: function (stream, state) {\n    var ctx = state.context;\n\n    if (stream.sol()) {\n      if (ctx.align == null) ctx.align = false;\n      state.indented = stream.indentation();\n      state.startOfLine = true;\n    }\n\n    if (stream.eatSpace()) return null;\n    curPunc = null;\n    var style = (state.tokenize || tokenBase)(stream, state);\n    if (style == \"comment\" || style == \"meta\") return style;\n    if (ctx.align == null) ctx.align = true;\n    if ((curPunc == \";\" || curPunc == \":\" || curPunc == \",\") && ctx.type == \"statement\") popContext(state);else if (curPunc == \"{\") pushContext(state, stream.column(), \"}\");else if (curPunc == \"[\") pushContext(state, stream.column(), \"]\");else if (curPunc == \"(\") pushContext(state, stream.column(), \")\");else if (curPunc == \"}\") {\n      while (ctx.type == \"statement\") ctx = popContext(state);\n\n      if (ctx.type == \"}\") ctx = popContext(state);\n\n      while (ctx.type == \"statement\") ctx = popContext(state);\n    } else if (curPunc == ctx.type) popContext(state);else if ((ctx.type == \"}\" || ctx.type == \"top\") && curPunc != ';' || ctx.type == \"statement\" && curPunc == \"newstatement\") pushContext(state, stream.column(), \"statement\");\n    state.startOfLine = false;\n    return style;\n  },\n  indent: function (state, textAfter, cx) {\n    if (state.tokenize != tokenBase && state.tokenize != null) return null;\n    var ctx = state.context,\n        firstChar = textAfter && textAfter.charAt(0);\n    if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n    var closing = firstChar == ctx.type;\n    if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit || cx.unit);else if (ctx.align) return ctx.column + (closing ? 0 : 1);else return ctx.indented + (closing ? 0 : cx.unit);\n  },\n  languageData: {\n    indentOnInput: /^\\s*[{}]$/,\n    commentTokens: {\n      line: \"//\",\n      block: {\n        open: \"/*\",\n        close: \"*/\"\n      }\n    }\n  }\n};","map":{"version":3,"names":["words","str","obj","split","i","length","blockKeywordsStr","parserConfig","keywords","blockKeywords","builtin","atoms","hooks","stream","_state","eatWhile","statementIndentUnit","multiLineStrings","isOperatorChar","curPunc","tokenBase","state","ch","next","result","tokenize","tokenString","test","eat","tokenNestedComment","tokenComment","skipToEnd","cur","current","propertyIsEnumerable","quote","escaped","end","maybeEnd","Context","indented","column","type","align","prev","pushContext","col","indent","context","popContext","t","d","startState","indentUnit","startOfLine","token","ctx","sol","indentation","eatSpace","style","textAfter","cx","firstChar","charAt","closing","unit","languageData","indentOnInput","commentTokens","line","block","open","close"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/@codemirror/legacy-modes/mode/d.js"],"sourcesContent":["function words(str) {\n  var obj = {}, words = str.split(\" \");\n  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n  return obj;\n}\n\nvar blockKeywordsStr = \"body catch class do else enum for foreach foreach_reverse if in interface mixin \" +\n    \"out scope struct switch try union unittest version while with\";\n\nconst parserConfig = {\n  keywords: words(\"abstract alias align asm assert auto break case cast cdouble cent cfloat const continue \" +\n                  \"debug default delegate delete deprecated export extern final finally function goto immutable \" +\n                  \"import inout invariant is lazy macro module new nothrow override package pragma private \" +\n                  \"protected public pure ref return shared short static super synchronized template this \" +\n                  \"throw typedef typeid typeof volatile __FILE__ __LINE__ __gshared __traits __vector __parameters \" +\n                  blockKeywordsStr),\n  blockKeywords: words(blockKeywordsStr),\n  builtin: words(\"bool byte char creal dchar double float idouble ifloat int ireal long real short ubyte \" +\n                 \"ucent uint ulong ushort wchar wstring void size_t sizediff_t\"),\n  atoms: words(\"exit failure success true false null\"),\n  hooks: {\n    \"@\": function(stream, _state) {\n      stream.eatWhile(/[\\w\\$_]/);\n      return \"meta\";\n    }\n  }\n}\n\nvar statementIndentUnit = parserConfig.statementIndentUnit,\n    keywords = parserConfig.keywords,\n    builtin = parserConfig.builtin,\n    blockKeywords = parserConfig.blockKeywords,\n    atoms = parserConfig.atoms,\n    hooks = parserConfig.hooks,\n    multiLineStrings = parserConfig.multiLineStrings;\nvar isOperatorChar = /[+\\-*&%=<>!?|\\/]/;\n\nvar curPunc;\n\nfunction tokenBase(stream, state) {\n  var ch = stream.next();\n  if (hooks[ch]) {\n    var result = hooks[ch](stream, state);\n    if (result !== false) return result;\n  }\n  if (ch == '\"' || ch == \"'\" || ch == \"`\") {\n    state.tokenize = tokenString(ch);\n    return state.tokenize(stream, state);\n  }\n  if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n    curPunc = ch;\n    return null;\n  }\n  if (/\\d/.test(ch)) {\n    stream.eatWhile(/[\\w\\.]/);\n    return \"number\";\n  }\n  if (ch == \"/\") {\n    if (stream.eat(\"+\")) {\n      state.tokenize = tokenNestedComment;\n      return tokenNestedComment(stream, state);\n    }\n    if (stream.eat(\"*\")) {\n      state.tokenize = tokenComment;\n      return tokenComment(stream, state);\n    }\n    if (stream.eat(\"/\")) {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n  }\n  if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return \"operator\";\n  }\n  stream.eatWhile(/[\\w\\$_\\xa1-\\uffff]/);\n  var cur = stream.current();\n  if (keywords.propertyIsEnumerable(cur)) {\n    if (blockKeywords.propertyIsEnumerable(cur)) curPunc = \"newstatement\";\n    return \"keyword\";\n  }\n  if (builtin.propertyIsEnumerable(cur)) {\n    if (blockKeywords.propertyIsEnumerable(cur)) curPunc = \"newstatement\";\n    return \"builtin\";\n  }\n  if (atoms.propertyIsEnumerable(cur)) return \"atom\";\n  return \"variable\";\n}\n\nfunction tokenString(quote) {\n  return function(stream, state) {\n    var escaped = false, next, end = false;\n    while ((next = stream.next()) != null) {\n      if (next == quote && !escaped) {end = true; break;}\n      escaped = !escaped && next == \"\\\\\";\n    }\n    if (end || !(escaped || multiLineStrings))\n      state.tokenize = null;\n    return \"string\";\n  };\n}\n\nfunction tokenComment(stream, state) {\n  var maybeEnd = false, ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = null;\n      break;\n    }\n    maybeEnd = (ch == \"*\");\n  }\n  return \"comment\";\n}\n\nfunction tokenNestedComment(stream, state) {\n  var maybeEnd = false, ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = null;\n      break;\n    }\n    maybeEnd = (ch == \"+\");\n  }\n  return \"comment\";\n}\n\nfunction Context(indented, column, type, align, prev) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.align = align;\n  this.prev = prev;\n}\nfunction pushContext(state, col, type) {\n  var indent = state.indented;\n  if (state.context && state.context.type == \"statement\")\n    indent = state.context.indented;\n  return state.context = new Context(indent, col, type, null, state.context);\n}\nfunction popContext(state) {\n  var t = state.context.type;\n  if (t == \")\" || t == \"]\" || t == \"}\")\n    state.indented = state.context.indented;\n  return state.context = state.context.prev;\n}\n\n// Interface\n\nexport const d = {\n  startState: function(indentUnit) {\n    return {\n      tokenize: null,\n      context: new Context(-indentUnit, 0, \"top\", false),\n      indented: 0,\n      startOfLine: true\n    };\n  },\n\n  token: function(stream, state) {\n    var ctx = state.context;\n    if (stream.sol()) {\n      if (ctx.align == null) ctx.align = false;\n      state.indented = stream.indentation();\n      state.startOfLine = true;\n    }\n    if (stream.eatSpace()) return null;\n    curPunc = null;\n    var style = (state.tokenize || tokenBase)(stream, state);\n    if (style == \"comment\" || style == \"meta\") return style;\n    if (ctx.align == null) ctx.align = true;\n\n    if ((curPunc == \";\" || curPunc == \":\" || curPunc == \",\") && ctx.type == \"statement\") popContext(state);\n    else if (curPunc == \"{\") pushContext(state, stream.column(), \"}\");\n    else if (curPunc == \"[\") pushContext(state, stream.column(), \"]\");\n    else if (curPunc == \"(\") pushContext(state, stream.column(), \")\");\n    else if (curPunc == \"}\") {\n      while (ctx.type == \"statement\") ctx = popContext(state);\n      if (ctx.type == \"}\") ctx = popContext(state);\n      while (ctx.type == \"statement\") ctx = popContext(state);\n    }\n    else if (curPunc == ctx.type) popContext(state);\n    else if (((ctx.type == \"}\" || ctx.type == \"top\") && curPunc != ';') || (ctx.type == \"statement\" && curPunc == \"newstatement\"))\n      pushContext(state, stream.column(), \"statement\");\n    state.startOfLine = false;\n    return style;\n  },\n\n  indent: function(state, textAfter, cx) {\n    if (state.tokenize != tokenBase && state.tokenize != null) return null;\n    var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);\n    if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n    var closing = firstChar == ctx.type;\n    if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit || cx.unit);\n    else if (ctx.align) return ctx.column + (closing ? 0 : 1);\n    else return ctx.indented + (closing ? 0 : cx.unit);\n  },\n\n  languageData: {\n    indentOnInput: /^\\s*[{}]$/,\n    commentTokens: {line: \"//\", block: {open: \"/*\", close: \"*/\"}}\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}