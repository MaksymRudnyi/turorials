{"ast":null,"code":"import { keywords as cssKeywords } from \"./css.js\";\nconst propertyKeywords = new Set(cssKeywords.properties);\nconst colorKeywords = new Set(cssKeywords.colors);\nconst valueKeywords = new Set(cssKeywords.values);\nconst fontProperties = new Set(cssKeywords.fonts);\n\nfunction tokenRegexp(words) {\n  return new RegExp(\"^\" + words.join(\"|\"));\n}\n\nlet keywords = [\"true\", \"false\", \"null\", \"auto\"];\nlet keywordsRegexp = new RegExp(\"^\" + keywords.join(\"|\"));\nlet operators = [\"\\\\(\", \"\\\\)\", \"=\", \">\", \"<\", \"==\", \">=\", \"<=\", \"\\\\+\", \"-\", \"\\\\!=\", \"/\", \"\\\\*\", \"%\", \"and\", \"or\", \"not\", \";\", \"\\\\{\", \"\\\\}\", \":\"];\nlet opRegexp = tokenRegexp(operators);\nlet pseudoElementsRegexp = /^::?[a-zA-Z_][\\w\\-]*/;\nlet word;\n\nfunction isEndLine(stream) {\n  return !stream.peek() || stream.match(/\\s+$/, false);\n}\n\nfunction urlTokens(stream, state) {\n  let ch = stream.peek();\n\n  if (ch === \")\") {\n    stream.next();\n    state.tokenizer = tokenBase;\n    return \"operator\";\n  } else if (ch === \"(\") {\n    stream.next();\n    stream.eatSpace();\n    return \"operator\";\n  } else if (ch === \"'\" || ch === '\"') {\n    state.tokenizer = buildStringTokenizer(stream.next());\n    return \"string\";\n  } else {\n    state.tokenizer = buildStringTokenizer(\")\", false);\n    return \"string\";\n  }\n}\n\nfunction comment(indentation, multiLine) {\n  return function (stream, state) {\n    if (stream.sol() && stream.indentation() <= indentation) {\n      state.tokenizer = tokenBase;\n      return tokenBase(stream, state);\n    }\n\n    if (multiLine && stream.skipTo(\"*/\")) {\n      stream.next();\n      stream.next();\n      state.tokenizer = tokenBase;\n    } else {\n      stream.skipToEnd();\n    }\n\n    return \"comment\";\n  };\n}\n\nfunction buildStringTokenizer(quote, greedy) {\n  if (greedy == null) {\n    greedy = true;\n  }\n\n  function stringTokenizer(stream, state) {\n    let nextChar = stream.next();\n    let peekChar = stream.peek();\n    let previousChar = stream.string.charAt(stream.pos - 2);\n    let endingString = nextChar !== \"\\\\\" && peekChar === quote || nextChar === quote && previousChar !== \"\\\\\";\n\n    if (endingString) {\n      if (nextChar !== quote && greedy) {\n        stream.next();\n      }\n\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0;\n      }\n\n      state.tokenizer = tokenBase;\n      return \"string\";\n    } else if (nextChar === \"#\" && peekChar === \"{\") {\n      state.tokenizer = buildInterpolationTokenizer(stringTokenizer);\n      stream.next();\n      return \"operator\";\n    } else {\n      return \"string\";\n    }\n  }\n\n  return stringTokenizer;\n}\n\nfunction buildInterpolationTokenizer(currentTokenizer) {\n  return function (stream, state) {\n    if (stream.peek() === \"}\") {\n      stream.next();\n      state.tokenizer = currentTokenizer;\n      return \"operator\";\n    } else {\n      return tokenBase(stream, state);\n    }\n  };\n}\n\nfunction indent(state, stream) {\n  if (state.indentCount == 0) {\n    state.indentCount++;\n    let lastScopeOffset = state.scopes[0].offset;\n    let currentOffset = lastScopeOffset + stream.indentUnit;\n    state.scopes.unshift({\n      offset: currentOffset\n    });\n  }\n}\n\nfunction dedent(state) {\n  if (state.scopes.length == 1) return;\n  state.scopes.shift();\n}\n\nfunction tokenBase(stream, state) {\n  let ch = stream.peek(); // Comment\n\n  if (stream.match(\"/*\")) {\n    state.tokenizer = comment(stream.indentation(), true);\n    return state.tokenizer(stream, state);\n  }\n\n  if (stream.match(\"//\")) {\n    state.tokenizer = comment(stream.indentation(), false);\n    return state.tokenizer(stream, state);\n  } // Interpolation\n\n\n  if (stream.match(\"#{\")) {\n    state.tokenizer = buildInterpolationTokenizer(tokenBase);\n    return \"operator\";\n  } // Strings\n\n\n  if (ch === '\"' || ch === \"'\") {\n    stream.next();\n    state.tokenizer = buildStringTokenizer(ch);\n    return \"string\";\n  }\n\n  if (!state.cursorHalf) {\n    // first half i.e. before : for key-value pairs\n    // including selectors\n    if (ch === \"-\") {\n      if (stream.match(/^-\\w+-/)) {\n        return \"meta\";\n      }\n    }\n\n    if (ch === \".\") {\n      stream.next();\n\n      if (stream.match(/^[\\w-]+/)) {\n        indent(state, stream);\n        return \"qualifier\";\n      } else if (stream.peek() === \"#\") {\n        indent(state, stream);\n        return \"tag\";\n      }\n    }\n\n    if (ch === \"#\") {\n      stream.next(); // ID selectors\n\n      if (stream.match(/^[\\w-]+/)) {\n        indent(state, stream);\n        return \"builtin\";\n      }\n\n      if (stream.peek() === \"#\") {\n        indent(state, stream);\n        return \"tag\";\n      }\n    } // Variables\n\n\n    if (ch === \"$\") {\n      stream.next();\n      stream.eatWhile(/[\\w-]/);\n      return \"variable-2\";\n    } // Numbers\n\n\n    if (stream.match(/^-?[0-9\\.]+/)) return \"number\"; // Units\n\n    if (stream.match(/^(px|em|in)\\b/)) return \"unit\";\n    if (stream.match(keywordsRegexp)) return \"keyword\";\n\n    if (stream.match(/^url/) && stream.peek() === \"(\") {\n      state.tokenizer = urlTokens;\n      return \"atom\";\n    }\n\n    if (ch === \"=\") {\n      // Match shortcut mixin definition\n      if (stream.match(/^=[\\w-]+/)) {\n        indent(state, stream);\n        return \"meta\";\n      }\n    }\n\n    if (ch === \"+\") {\n      // Match shortcut mixin definition\n      if (stream.match(/^\\+[\\w-]+/)) {\n        return \"meta\";\n      }\n    }\n\n    if (ch === \"@\") {\n      if (stream.match('@extend')) {\n        if (!stream.match(/\\s*[\\w]/)) dedent(state);\n      }\n    } // Indent Directives\n\n\n    if (stream.match(/^@(else if|if|media|else|for|each|while|mixin|function)/)) {\n      indent(state, stream);\n      return \"def\";\n    } // Other Directives\n\n\n    if (ch === \"@\") {\n      stream.next();\n      stream.eatWhile(/[\\w-]/);\n      return \"def\";\n    }\n\n    if (stream.eatWhile(/[\\w-]/)) {\n      if (stream.match(/ *: *[\\w-\\+\\$#!\\(\"']/, false)) {\n        word = stream.current().toLowerCase();\n        let prop = state.prevProp + \"-\" + word;\n\n        if (propertyKeywords.has(prop)) {\n          return \"property\";\n        } else if (propertyKeywords.has(word)) {\n          state.prevProp = word;\n          return \"property\";\n        } else if (fontProperties.has(word)) {\n          return \"property\";\n        }\n\n        return \"tag\";\n      } else if (stream.match(/ *:/, false)) {\n        indent(state, stream);\n        state.cursorHalf = 1;\n        state.prevProp = stream.current().toLowerCase();\n        return \"property\";\n      } else if (stream.match(/ *,/, false)) {\n        return \"tag\";\n      } else {\n        indent(state, stream);\n        return \"tag\";\n      }\n    }\n\n    if (ch === \":\") {\n      if (stream.match(pseudoElementsRegexp)) {\n        // could be a pseudo-element\n        return \"type\";\n      }\n\n      stream.next();\n      state.cursorHalf = 1;\n      return \"operator\";\n    }\n  } else {\n    if (ch === \"#\") {\n      stream.next(); // Hex numbers\n\n      if (stream.match(/[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/)) {\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n\n        return \"number\";\n      }\n    } // Numbers\n\n\n    if (stream.match(/^-?[0-9\\.]+/)) {\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0;\n      }\n\n      return \"number\";\n    } // Units\n\n\n    if (stream.match(/^(px|em|in)\\b/)) {\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0;\n      }\n\n      return \"unit\";\n    }\n\n    if (stream.match(keywordsRegexp)) {\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0;\n      }\n\n      return \"keyword\";\n    }\n\n    if (stream.match(/^url/) && stream.peek() === \"(\") {\n      state.tokenizer = urlTokens;\n\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0;\n      }\n\n      return \"atom\";\n    } // Variables\n\n\n    if (ch === \"$\") {\n      stream.next();\n      stream.eatWhile(/[\\w-]/);\n\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0;\n      }\n\n      return \"variable-2\";\n    } // bang character for !important, !default, etc.\n\n\n    if (ch === \"!\") {\n      stream.next();\n      state.cursorHalf = 0;\n      return stream.match(/^[\\w]+/) ? \"keyword\" : \"operator\";\n    }\n\n    if (stream.match(opRegexp)) {\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0;\n      }\n\n      return \"operator\";\n    } // attributes\n\n\n    if (stream.eatWhile(/[\\w-]/)) {\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0;\n      }\n\n      word = stream.current().toLowerCase();\n\n      if (valueKeywords.has(word)) {\n        return \"atom\";\n      } else if (colorKeywords.has(word)) {\n        return \"keyword\";\n      } else if (propertyKeywords.has(word)) {\n        state.prevProp = stream.current().toLowerCase();\n        return \"property\";\n      } else {\n        return \"tag\";\n      }\n    }\n\n    if (isEndLine(stream)) {\n      state.cursorHalf = 0;\n      return null;\n    }\n  }\n\n  if (stream.match(opRegexp)) return \"operator\";\n  stream.next();\n  return null;\n}\n\nfunction tokenLexer(stream, state) {\n  if (stream.sol()) state.indentCount = 0;\n  let style = state.tokenizer(stream, state);\n  let current = stream.current();\n\n  if (current === \"@return\" || current === \"}\") {\n    dedent(state);\n  }\n\n  if (style !== null) {\n    let startOfToken = stream.pos - current.length;\n    let withCurrentIndent = startOfToken + stream.indentUnit * state.indentCount;\n    let newScopes = [];\n\n    for (let i = 0; i < state.scopes.length; i++) {\n      let scope = state.scopes[i];\n      if (scope.offset <= withCurrentIndent) newScopes.push(scope);\n    }\n\n    state.scopes = newScopes;\n  }\n\n  return style;\n}\n\nexport const sass = {\n  startState: function () {\n    return {\n      tokenizer: tokenBase,\n      scopes: [{\n        offset: 0,\n        type: \"sass\"\n      }],\n      indentCount: 0,\n      cursorHalf: 0,\n      // cursor half tells us if cursor lies after (1)\n      // or before (0) colon (well... more or less)\n      definedVars: [],\n      definedMixins: []\n    };\n  },\n  token: function (stream, state) {\n    let style = tokenLexer(stream, state);\n    state.lastToken = {\n      style: style,\n      content: stream.current()\n    };\n    return style;\n  },\n  indent: function (state) {\n    return state.scopes[0].offset;\n  },\n  languageData: {\n    commentTokens: {\n      line: \"//\",\n      block: {\n        open: \"/*\",\n        close: \"*/\"\n      }\n    },\n    autocomplete: cssKeywords.all\n  }\n};","map":{"version":3,"names":["keywords","cssKeywords","propertyKeywords","Set","properties","colorKeywords","colors","valueKeywords","values","fontProperties","fonts","tokenRegexp","words","RegExp","join","keywordsRegexp","operators","opRegexp","pseudoElementsRegexp","word","isEndLine","stream","peek","match","urlTokens","state","ch","next","tokenizer","tokenBase","eatSpace","buildStringTokenizer","comment","indentation","multiLine","sol","skipTo","skipToEnd","quote","greedy","stringTokenizer","nextChar","peekChar","previousChar","string","charAt","pos","endingString","cursorHalf","buildInterpolationTokenizer","currentTokenizer","indent","indentCount","lastScopeOffset","scopes","offset","currentOffset","indentUnit","unshift","dedent","length","shift","eatWhile","current","toLowerCase","prop","prevProp","has","tokenLexer","style","startOfToken","withCurrentIndent","newScopes","i","scope","push","sass","startState","type","definedVars","definedMixins","token","lastToken","content","languageData","commentTokens","line","block","open","close","autocomplete","all"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/@codemirror/legacy-modes/mode/sass.js"],"sourcesContent":["import {keywords as cssKeywords} from \"./css.js\"\nconst propertyKeywords = new Set(cssKeywords.properties)\nconst colorKeywords = new Set(cssKeywords.colors)\nconst valueKeywords = new Set(cssKeywords.values)\nconst fontProperties = new Set(cssKeywords.fonts)\n\nfunction tokenRegexp(words) {\n  return new RegExp(\"^\" + words.join(\"|\"))\n}\n\nlet keywords = [\"true\", \"false\", \"null\", \"auto\"]\nlet keywordsRegexp = new RegExp(\"^\" + keywords.join(\"|\"))\n\nlet operators = [\"\\\\(\", \"\\\\)\", \"=\", \">\", \"<\", \"==\", \">=\", \"<=\", \"\\\\+\", \"-\",\n                 \"\\\\!=\", \"/\", \"\\\\*\", \"%\", \"and\", \"or\", \"not\", \";\",\"\\\\{\",\"\\\\}\",\":\"]\nlet opRegexp = tokenRegexp(operators)\n\nlet pseudoElementsRegexp = /^::?[a-zA-Z_][\\w\\-]*/\n\nlet word\n\nfunction isEndLine(stream) {\n  return !stream.peek() || stream.match(/\\s+$/, false)\n}\n\nfunction urlTokens(stream, state) {\n  let ch = stream.peek()\n\n  if (ch === \")\") {\n    stream.next()\n    state.tokenizer = tokenBase\n    return \"operator\"\n  } else if (ch === \"(\") {\n    stream.next()\n    stream.eatSpace()\n\n    return \"operator\"\n  } else if (ch === \"'\" || ch === '\"') {\n    state.tokenizer = buildStringTokenizer(stream.next())\n    return \"string\"\n  } else {\n    state.tokenizer = buildStringTokenizer(\")\", false)\n    return \"string\"\n  }\n}\nfunction comment(indentation, multiLine) {\n  return function(stream, state) {\n    if (stream.sol() && stream.indentation() <= indentation) {\n      state.tokenizer = tokenBase\n      return tokenBase(stream, state)\n    }\n\n    if (multiLine && stream.skipTo(\"*/\")) {\n      stream.next()\n      stream.next()\n      state.tokenizer = tokenBase\n    } else {\n      stream.skipToEnd()\n    }\n\n    return \"comment\"\n  }\n}\n\nfunction buildStringTokenizer(quote, greedy) {\n  if (greedy == null) { greedy = true }\n\n  function stringTokenizer(stream, state) {\n    let nextChar = stream.next()\n    let peekChar = stream.peek()\n    let previousChar = stream.string.charAt(stream.pos-2)\n\n    let endingString = ((nextChar !== \"\\\\\" && peekChar === quote) || (nextChar === quote && previousChar !== \"\\\\\"))\n\n    if (endingString) {\n      if (nextChar !== quote && greedy) { stream.next() }\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0\n      }\n      state.tokenizer = tokenBase\n      return \"string\"\n    } else if (nextChar === \"#\" && peekChar === \"{\") {\n      state.tokenizer = buildInterpolationTokenizer(stringTokenizer)\n      stream.next()\n      return \"operator\"\n    } else {\n      return \"string\"\n    }\n  }\n\n  return stringTokenizer\n}\n\nfunction buildInterpolationTokenizer(currentTokenizer) {\n  return function(stream, state) {\n    if (stream.peek() === \"}\") {\n      stream.next()\n      state.tokenizer = currentTokenizer\n      return \"operator\"\n    } else {\n      return tokenBase(stream, state)\n    }\n  }\n}\n\nfunction indent(state, stream) {\n  if (state.indentCount == 0) {\n    state.indentCount++\n    let lastScopeOffset = state.scopes[0].offset\n    let currentOffset = lastScopeOffset + stream.indentUnit\n    state.scopes.unshift({ offset:currentOffset })\n  }\n}\n\nfunction dedent(state) {\n  if (state.scopes.length == 1) return\n\n  state.scopes.shift()\n}\n\nfunction tokenBase(stream, state) {\n  let ch = stream.peek()\n\n  // Comment\n  if (stream.match(\"/*\")) {\n    state.tokenizer = comment(stream.indentation(), true)\n    return state.tokenizer(stream, state)\n  }\n  if (stream.match(\"//\")) {\n    state.tokenizer = comment(stream.indentation(), false)\n    return state.tokenizer(stream, state)\n  }\n\n  // Interpolation\n  if (stream.match(\"#{\")) {\n    state.tokenizer = buildInterpolationTokenizer(tokenBase)\n    return \"operator\"\n  }\n\n  // Strings\n  if (ch === '\"' || ch === \"'\") {\n    stream.next()\n    state.tokenizer = buildStringTokenizer(ch)\n    return \"string\"\n  }\n\n  if (!state.cursorHalf) {\n    // first half i.e. before : for key-value pairs\n    // including selectors\n    if (ch === \"-\") {\n      if (stream.match(/^-\\w+-/)) {\n        return \"meta\"\n      }\n    }\n\n    if (ch === \".\") {\n      stream.next()\n      if (stream.match(/^[\\w-]+/)) {\n        indent(state, stream)\n        return \"qualifier\"\n      } else if (stream.peek() === \"#\") {\n        indent(state, stream)\n        return \"tag\"\n      }\n    }\n\n    if (ch === \"#\") {\n      stream.next()\n      // ID selectors\n      if (stream.match(/^[\\w-]+/)) {\n        indent(state, stream)\n        return \"builtin\"\n      }\n      if (stream.peek() === \"#\") {\n        indent(state, stream)\n        return \"tag\"\n      }\n    }\n\n    // Variables\n    if (ch === \"$\") {\n      stream.next()\n      stream.eatWhile(/[\\w-]/)\n      return \"variable-2\"\n    }\n\n    // Numbers\n    if (stream.match(/^-?[0-9\\.]+/))\n      return \"number\"\n\n    // Units\n    if (stream.match(/^(px|em|in)\\b/))\n      return \"unit\"\n\n    if (stream.match(keywordsRegexp))\n      return \"keyword\"\n\n    if (stream.match(/^url/) && stream.peek() === \"(\") {\n      state.tokenizer = urlTokens\n      return \"atom\"\n    }\n\n    if (ch === \"=\") {\n      // Match shortcut mixin definition\n      if (stream.match(/^=[\\w-]+/)) {\n        indent(state, stream)\n        return \"meta\"\n      }\n    }\n\n    if (ch === \"+\") {\n      // Match shortcut mixin definition\n      if (stream.match(/^\\+[\\w-]+/)) {\n        return \"meta\"\n      }\n    }\n\n    if (ch === \"@\") {\n      if (stream.match('@extend')) {\n        if (!stream.match(/\\s*[\\w]/))\n          dedent(state)\n      }\n    }\n\n\n    // Indent Directives\n    if (stream.match(/^@(else if|if|media|else|for|each|while|mixin|function)/)) {\n      indent(state, stream)\n      return \"def\"\n    }\n\n    // Other Directives\n    if (ch === \"@\") {\n      stream.next()\n      stream.eatWhile(/[\\w-]/)\n      return \"def\"\n    }\n\n    if (stream.eatWhile(/[\\w-]/)) {\n      if (stream.match(/ *: *[\\w-\\+\\$#!\\(\"']/,false)) {\n        word = stream.current().toLowerCase()\n        let prop = state.prevProp + \"-\" + word\n        if (propertyKeywords.has(prop)) {\n          return \"property\"\n        } else if (propertyKeywords.has(word)) {\n          state.prevProp = word\n          return \"property\"\n        } else if (fontProperties.has(word)) {\n          return \"property\"\n        }\n        return \"tag\"\n      } else if (stream.match(/ *:/,false)) {\n        indent(state, stream)\n        state.cursorHalf = 1\n        state.prevProp = stream.current().toLowerCase()\n        return \"property\"\n      } else if (stream.match(/ *,/,false)) {\n        return \"tag\"\n      } else {\n        indent(state, stream)\n        return \"tag\"\n      }\n    }\n\n    if (ch === \":\") {\n      if (stream.match(pseudoElementsRegexp)) { // could be a pseudo-element\n        return \"type\"\n      }\n      stream.next()\n      state.cursorHalf=1\n      return \"operator\"\n    }\n  } else {\n    if (ch === \"#\") {\n      stream.next()\n      // Hex numbers\n      if (stream.match(/[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/)) {\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0\n        }\n        return \"number\"\n      }\n    }\n\n    // Numbers\n    if (stream.match(/^-?[0-9\\.]+/)) {\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0\n      }\n      return \"number\"\n    }\n\n    // Units\n    if (stream.match(/^(px|em|in)\\b/)) {\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0\n      }\n      return \"unit\"\n    }\n\n    if (stream.match(keywordsRegexp)) {\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0\n      }\n      return \"keyword\"\n    }\n\n    if (stream.match(/^url/) && stream.peek() === \"(\") {\n      state.tokenizer = urlTokens\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0\n      }\n      return \"atom\"\n    }\n\n    // Variables\n    if (ch === \"$\") {\n      stream.next()\n      stream.eatWhile(/[\\w-]/)\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0\n      }\n      return \"variable-2\"\n    }\n\n    // bang character for !important, !default, etc.\n    if (ch === \"!\") {\n      stream.next()\n      state.cursorHalf = 0\n      return stream.match(/^[\\w]+/) ? \"keyword\": \"operator\"\n    }\n\n    if (stream.match(opRegexp)) {\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0\n      }\n      return \"operator\"\n    }\n\n    // attributes\n    if (stream.eatWhile(/[\\w-]/)) {\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0\n      }\n      word = stream.current().toLowerCase()\n      if (valueKeywords.has(word)) {\n        return \"atom\"\n      } else if (colorKeywords.has(word)) {\n        return \"keyword\"\n      } else if (propertyKeywords.has(word)) {\n        state.prevProp = stream.current().toLowerCase()\n        return \"property\"\n      } else {\n        return \"tag\"\n      }\n    }\n\n    if (isEndLine(stream)) {\n      state.cursorHalf = 0\n      return null\n    }\n  }\n\n  if (stream.match(opRegexp))\n    return \"operator\"\n\n  stream.next()\n  return null\n}\n\nfunction tokenLexer(stream, state) {\n  if (stream.sol()) state.indentCount = 0\n  let style = state.tokenizer(stream, state)\n  let current = stream.current()\n\n  if (current === \"@return\" || current === \"}\") {\n    dedent(state)\n  }\n\n  if (style !== null) {\n    let startOfToken = stream.pos - current.length\n\n    let withCurrentIndent = startOfToken + (stream.indentUnit * state.indentCount)\n\n    let newScopes = []\n\n    for (let i = 0; i < state.scopes.length; i++) {\n      let scope = state.scopes[i]\n\n      if (scope.offset <= withCurrentIndent)\n        newScopes.push(scope)\n    }\n\n    state.scopes = newScopes\n  }\n\n  return style\n}\n\nexport const sass = {\n  startState: function() {\n    return {\n      tokenizer: tokenBase,\n      scopes: [{offset: 0, type: \"sass\"}],\n      indentCount: 0,\n      cursorHalf: 0,  // cursor half tells us if cursor lies after (1)\n      // or before (0) colon (well... more or less)\n      definedVars: [],\n      definedMixins: []\n    }\n  },\n  token: function(stream, state) {\n    let style = tokenLexer(stream, state)\n    state.lastToken = { style: style, content: stream.current() }\n    return style\n  },\n\n  indent: function(state) {\n    return state.scopes[0].offset\n  },\n\n  languageData: {\n    commentTokens: {line: \"//\", block: {open: \"/*\", close: \"*/\"}},\n    autocomplete: cssKeywords.all\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}