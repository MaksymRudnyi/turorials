{"ast":null,"code":"'use strict'; //Const\n\nconst NOAH_ARK_CAPACITY = 3; //List of formatting elements\n\nclass FormattingElementList {\n  constructor(treeAdapter) {\n    this.length = 0;\n    this.entries = [];\n    this.treeAdapter = treeAdapter;\n    this.bookmark = null;\n  } //Noah Ark's condition\n  //OPTIMIZATION: at first we try to find possible candidates for exclusion using\n  //lightweight heuristics without thorough attributes check.\n\n\n  _getNoahArkConditionCandidates(newElement) {\n    const candidates = [];\n\n    if (this.length >= NOAH_ARK_CAPACITY) {\n      const neAttrsLength = this.treeAdapter.getAttrList(newElement).length;\n      const neTagName = this.treeAdapter.getTagName(newElement);\n      const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);\n\n      for (let i = this.length - 1; i >= 0; i--) {\n        const entry = this.entries[i];\n\n        if (entry.type === FormattingElementList.MARKER_ENTRY) {\n          break;\n        }\n\n        const element = entry.element;\n        const elementAttrs = this.treeAdapter.getAttrList(element);\n        const isCandidate = this.treeAdapter.getTagName(element) === neTagName && this.treeAdapter.getNamespaceURI(element) === neNamespaceURI && elementAttrs.length === neAttrsLength;\n\n        if (isCandidate) {\n          candidates.push({\n            idx: i,\n            attrs: elementAttrs\n          });\n        }\n      }\n    }\n\n    return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;\n  }\n\n  _ensureNoahArkCondition(newElement) {\n    const candidates = this._getNoahArkConditionCandidates(newElement);\n\n    let cLength = candidates.length;\n\n    if (cLength) {\n      const neAttrs = this.treeAdapter.getAttrList(newElement);\n      const neAttrsLength = neAttrs.length;\n      const neAttrsMap = Object.create(null); //NOTE: build attrs map for the new element so we can perform fast lookups\n\n      for (let i = 0; i < neAttrsLength; i++) {\n        const neAttr = neAttrs[i];\n        neAttrsMap[neAttr.name] = neAttr.value;\n      }\n\n      for (let i = 0; i < neAttrsLength; i++) {\n        for (let j = 0; j < cLength; j++) {\n          const cAttr = candidates[j].attrs[i];\n\n          if (neAttrsMap[cAttr.name] !== cAttr.value) {\n            candidates.splice(j, 1);\n            cLength--;\n          }\n\n          if (candidates.length < NOAH_ARK_CAPACITY) {\n            return;\n          }\n        }\n      } //NOTE: remove bottommost candidates until Noah's Ark condition will not be met\n\n\n      for (let i = cLength - 1; i >= NOAH_ARK_CAPACITY - 1; i--) {\n        this.entries.splice(candidates[i].idx, 1);\n        this.length--;\n      }\n    }\n  } //Mutations\n\n\n  insertMarker() {\n    this.entries.push({\n      type: FormattingElementList.MARKER_ENTRY\n    });\n    this.length++;\n  }\n\n  pushElement(element, token) {\n    this._ensureNoahArkCondition(element);\n\n    this.entries.push({\n      type: FormattingElementList.ELEMENT_ENTRY,\n      element: element,\n      token: token\n    });\n    this.length++;\n  }\n\n  insertElementAfterBookmark(element, token) {\n    let bookmarkIdx = this.length - 1;\n\n    for (; bookmarkIdx >= 0; bookmarkIdx--) {\n      if (this.entries[bookmarkIdx] === this.bookmark) {\n        break;\n      }\n    }\n\n    this.entries.splice(bookmarkIdx + 1, 0, {\n      type: FormattingElementList.ELEMENT_ENTRY,\n      element: element,\n      token: token\n    });\n    this.length++;\n  }\n\n  removeEntry(entry) {\n    for (let i = this.length - 1; i >= 0; i--) {\n      if (this.entries[i] === entry) {\n        this.entries.splice(i, 1);\n        this.length--;\n        break;\n      }\n    }\n  }\n\n  clearToLastMarker() {\n    while (this.length) {\n      const entry = this.entries.pop();\n      this.length--;\n\n      if (entry.type === FormattingElementList.MARKER_ENTRY) {\n        break;\n      }\n    }\n  } //Search\n\n\n  getElementEntryInScopeWithTagName(tagName) {\n    for (let i = this.length - 1; i >= 0; i--) {\n      const entry = this.entries[i];\n\n      if (entry.type === FormattingElementList.MARKER_ENTRY) {\n        return null;\n      }\n\n      if (this.treeAdapter.getTagName(entry.element) === tagName) {\n        return entry;\n      }\n    }\n\n    return null;\n  }\n\n  getElementEntry(element) {\n    for (let i = this.length - 1; i >= 0; i--) {\n      const entry = this.entries[i];\n\n      if (entry.type === FormattingElementList.ELEMENT_ENTRY && entry.element === element) {\n        return entry;\n      }\n    }\n\n    return null;\n  }\n\n} //Entry types\n\n\nFormattingElementList.MARKER_ENTRY = 'MARKER_ENTRY';\nFormattingElementList.ELEMENT_ENTRY = 'ELEMENT_ENTRY';\nmodule.exports = FormattingElementList;","map":{"version":3,"names":["NOAH_ARK_CAPACITY","FormattingElementList","constructor","treeAdapter","length","entries","bookmark","_getNoahArkConditionCandidates","newElement","candidates","neAttrsLength","getAttrList","neTagName","getTagName","neNamespaceURI","getNamespaceURI","i","entry","type","MARKER_ENTRY","element","elementAttrs","isCandidate","push","idx","attrs","_ensureNoahArkCondition","cLength","neAttrs","neAttrsMap","Object","create","neAttr","name","value","j","cAttr","splice","insertMarker","pushElement","token","ELEMENT_ENTRY","insertElementAfterBookmark","bookmarkIdx","removeEntry","clearToLastMarker","pop","getElementEntryInScopeWithTagName","tagName","getElementEntry","module","exports"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/parse5/lib/parser/formatting-element-list.js"],"sourcesContent":["'use strict';\n\n//Const\nconst NOAH_ARK_CAPACITY = 3;\n\n//List of formatting elements\nclass FormattingElementList {\n    constructor(treeAdapter) {\n        this.length = 0;\n        this.entries = [];\n        this.treeAdapter = treeAdapter;\n        this.bookmark = null;\n    }\n\n    //Noah Ark's condition\n    //OPTIMIZATION: at first we try to find possible candidates for exclusion using\n    //lightweight heuristics without thorough attributes check.\n    _getNoahArkConditionCandidates(newElement) {\n        const candidates = [];\n\n        if (this.length >= NOAH_ARK_CAPACITY) {\n            const neAttrsLength = this.treeAdapter.getAttrList(newElement).length;\n            const neTagName = this.treeAdapter.getTagName(newElement);\n            const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);\n\n            for (let i = this.length - 1; i >= 0; i--) {\n                const entry = this.entries[i];\n\n                if (entry.type === FormattingElementList.MARKER_ENTRY) {\n                    break;\n                }\n\n                const element = entry.element;\n                const elementAttrs = this.treeAdapter.getAttrList(element);\n\n                const isCandidate =\n                    this.treeAdapter.getTagName(element) === neTagName &&\n                    this.treeAdapter.getNamespaceURI(element) === neNamespaceURI &&\n                    elementAttrs.length === neAttrsLength;\n\n                if (isCandidate) {\n                    candidates.push({ idx: i, attrs: elementAttrs });\n                }\n            }\n        }\n\n        return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;\n    }\n\n    _ensureNoahArkCondition(newElement) {\n        const candidates = this._getNoahArkConditionCandidates(newElement);\n        let cLength = candidates.length;\n\n        if (cLength) {\n            const neAttrs = this.treeAdapter.getAttrList(newElement);\n            const neAttrsLength = neAttrs.length;\n            const neAttrsMap = Object.create(null);\n\n            //NOTE: build attrs map for the new element so we can perform fast lookups\n            for (let i = 0; i < neAttrsLength; i++) {\n                const neAttr = neAttrs[i];\n\n                neAttrsMap[neAttr.name] = neAttr.value;\n            }\n\n            for (let i = 0; i < neAttrsLength; i++) {\n                for (let j = 0; j < cLength; j++) {\n                    const cAttr = candidates[j].attrs[i];\n\n                    if (neAttrsMap[cAttr.name] !== cAttr.value) {\n                        candidates.splice(j, 1);\n                        cLength--;\n                    }\n\n                    if (candidates.length < NOAH_ARK_CAPACITY) {\n                        return;\n                    }\n                }\n            }\n\n            //NOTE: remove bottommost candidates until Noah's Ark condition will not be met\n            for (let i = cLength - 1; i >= NOAH_ARK_CAPACITY - 1; i--) {\n                this.entries.splice(candidates[i].idx, 1);\n                this.length--;\n            }\n        }\n    }\n\n    //Mutations\n    insertMarker() {\n        this.entries.push({ type: FormattingElementList.MARKER_ENTRY });\n        this.length++;\n    }\n\n    pushElement(element, token) {\n        this._ensureNoahArkCondition(element);\n\n        this.entries.push({\n            type: FormattingElementList.ELEMENT_ENTRY,\n            element: element,\n            token: token\n        });\n\n        this.length++;\n    }\n\n    insertElementAfterBookmark(element, token) {\n        let bookmarkIdx = this.length - 1;\n\n        for (; bookmarkIdx >= 0; bookmarkIdx--) {\n            if (this.entries[bookmarkIdx] === this.bookmark) {\n                break;\n            }\n        }\n\n        this.entries.splice(bookmarkIdx + 1, 0, {\n            type: FormattingElementList.ELEMENT_ENTRY,\n            element: element,\n            token: token\n        });\n\n        this.length++;\n    }\n\n    removeEntry(entry) {\n        for (let i = this.length - 1; i >= 0; i--) {\n            if (this.entries[i] === entry) {\n                this.entries.splice(i, 1);\n                this.length--;\n                break;\n            }\n        }\n    }\n\n    clearToLastMarker() {\n        while (this.length) {\n            const entry = this.entries.pop();\n\n            this.length--;\n\n            if (entry.type === FormattingElementList.MARKER_ENTRY) {\n                break;\n            }\n        }\n    }\n\n    //Search\n    getElementEntryInScopeWithTagName(tagName) {\n        for (let i = this.length - 1; i >= 0; i--) {\n            const entry = this.entries[i];\n\n            if (entry.type === FormattingElementList.MARKER_ENTRY) {\n                return null;\n            }\n\n            if (this.treeAdapter.getTagName(entry.element) === tagName) {\n                return entry;\n            }\n        }\n\n        return null;\n    }\n\n    getElementEntry(element) {\n        for (let i = this.length - 1; i >= 0; i--) {\n            const entry = this.entries[i];\n\n            if (entry.type === FormattingElementList.ELEMENT_ENTRY && entry.element === element) {\n                return entry;\n            }\n        }\n\n        return null;\n    }\n}\n\n//Entry types\nFormattingElementList.MARKER_ENTRY = 'MARKER_ENTRY';\nFormattingElementList.ELEMENT_ENTRY = 'ELEMENT_ENTRY';\n\nmodule.exports = FormattingElementList;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}