{"ast":null,"code":"import { parser } from '@lezer/python';\nimport { LRLanguage, indentNodeProp, delimitedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\n\nfunction indentBody(context, node) {\n  let base = context.lineIndent(node.from);\n  let line = context.lineAt(context.pos, -1),\n      to = line.from + line.text.length; // Don't consider blank, deindented lines at the end of the\n  // block part of the block\n\n  if (!/\\S/.test(line.text) && context.node.to < to + 100 && !/\\S/.test(context.state.sliceDoc(to, context.node.to)) && context.lineIndent(context.pos, -1) <= base) return null; // A normally deindenting keyword that appears at a higher\n  // indentation than the block should probably be handled by the next\n  // level\n\n  if (/^\\s*(else:|elif |except |finally:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base) return null;\n  return base + context.unit;\n}\n/**\nA language provider based on the [Lezer Python\nparser](https://github.com/lezer-parser/python), extended with\nhighlighting and indentation information.\n*/\n\n\nconst pythonLanguage = /*@__PURE__*/LRLanguage.define({\n  parser: /*@__PURE__*/parser.configure({\n    props: [/*@__PURE__*/indentNodeProp.add({\n      Body: context => {\n        var _a;\n\n        return (_a = indentBody(context, context.node)) !== null && _a !== void 0 ? _a : context.continue();\n      },\n      IfStatement: cx => /^\\s*(else:|elif )/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n      TryStatement: cx => /^\\s*(except |finally:)/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n      \"TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression\": /*@__PURE__*/delimitedIndent({\n        closing: \")\"\n      }),\n      \"DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression\": /*@__PURE__*/delimitedIndent({\n        closing: \"}\"\n      }),\n      \"ArrayExpression ArrayComprehensionExpression\": /*@__PURE__*/delimitedIndent({\n        closing: \"]\"\n      }),\n      \"String FormatString\": () => null,\n      Script: context => {\n        if (context.pos + /\\s*/.exec(context.textAfter)[0].length >= context.node.to) {\n          let endBody = null;\n\n          for (let cur = context.node, to = cur.to;;) {\n            cur = cur.lastChild;\n            if (!cur || cur.to != to) break;\n            if (cur.type.name == \"Body\") endBody = cur;\n          }\n\n          if (endBody) {\n            let bodyIndent = indentBody(context, endBody);\n            if (bodyIndent != null) return bodyIndent;\n          }\n        }\n\n        return context.continue();\n      }\n    }), /*@__PURE__*/foldNodeProp.add({\n      \"ArrayExpression DictionaryExpression SetExpression TupleExpression\": foldInside,\n      Body: (node, state) => ({\n        from: node.from + 1,\n        to: node.to - (node.to == state.doc.length ? 0 : 1)\n      })\n    })]\n  }),\n  languageData: {\n    closeBrackets: {\n      brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"'''\", '\"\"\"']\n    },\n    commentTokens: {\n      line: \"#\"\n    },\n    indentOnInput: /^\\s*([\\}\\]\\)]|else:|elif |except |finally:)$/\n  }\n});\n/**\nPython language support.\n*/\n\nfunction python() {\n  return new LanguageSupport(pythonLanguage);\n}\n\nexport { python, pythonLanguage };","map":{"version":3,"names":["parser","LRLanguage","indentNodeProp","delimitedIndent","foldNodeProp","foldInside","LanguageSupport","indentBody","context","node","base","lineIndent","from","line","lineAt","pos","to","text","length","test","state","sliceDoc","textAfter","unit","pythonLanguage","define","configure","props","add","Body","_a","continue","IfStatement","cx","baseIndent","TryStatement","closing","Script","exec","endBody","cur","lastChild","type","name","bodyIndent","doc","languageData","closeBrackets","brackets","commentTokens","indentOnInput","python"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/@codemirror/lang-python/dist/index.js"],"sourcesContent":["import { parser } from '@lezer/python';\nimport { LRLanguage, indentNodeProp, delimitedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\n\nfunction indentBody(context, node) {\n    let base = context.lineIndent(node.from);\n    let line = context.lineAt(context.pos, -1), to = line.from + line.text.length;\n    // Don't consider blank, deindented lines at the end of the\n    // block part of the block\n    if (!/\\S/.test(line.text) &&\n        context.node.to < to + 100 &&\n        !/\\S/.test(context.state.sliceDoc(to, context.node.to)) &&\n        context.lineIndent(context.pos, -1) <= base)\n        return null;\n    // A normally deindenting keyword that appears at a higher\n    // indentation than the block should probably be handled by the next\n    // level\n    if (/^\\s*(else:|elif |except |finally:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base)\n        return null;\n    return base + context.unit;\n}\n/**\nA language provider based on the [Lezer Python\nparser](https://github.com/lezer-parser/python), extended with\nhighlighting and indentation information.\n*/\nconst pythonLanguage = /*@__PURE__*/LRLanguage.define({\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/indentNodeProp.add({\n                Body: context => { var _a; return (_a = indentBody(context, context.node)) !== null && _a !== void 0 ? _a : context.continue(); },\n                IfStatement: cx => /^\\s*(else:|elif )/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n                TryStatement: cx => /^\\s*(except |finally:)/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n                \"TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression\": /*@__PURE__*/delimitedIndent({ closing: \")\" }),\n                \"DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression\": /*@__PURE__*/delimitedIndent({ closing: \"}\" }),\n                \"ArrayExpression ArrayComprehensionExpression\": /*@__PURE__*/delimitedIndent({ closing: \"]\" }),\n                \"String FormatString\": () => null,\n                Script: context => {\n                    if (context.pos + /\\s*/.exec(context.textAfter)[0].length >= context.node.to) {\n                        let endBody = null;\n                        for (let cur = context.node, to = cur.to;;) {\n                            cur = cur.lastChild;\n                            if (!cur || cur.to != to)\n                                break;\n                            if (cur.type.name == \"Body\")\n                                endBody = cur;\n                        }\n                        if (endBody) {\n                            let bodyIndent = indentBody(context, endBody);\n                            if (bodyIndent != null)\n                                return bodyIndent;\n                        }\n                    }\n                    return context.continue();\n                }\n            }),\n            /*@__PURE__*/foldNodeProp.add({\n                \"ArrayExpression DictionaryExpression SetExpression TupleExpression\": foldInside,\n                Body: (node, state) => ({ from: node.from + 1, to: node.to - (node.to == state.doc.length ? 0 : 1) })\n            })\n        ],\n    }),\n    languageData: {\n        closeBrackets: { brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"'''\", '\"\"\"'] },\n        commentTokens: { line: \"#\" },\n        indentOnInput: /^\\s*([\\}\\]\\)]|else:|elif |except |finally:)$/\n    }\n});\n/**\nPython language support.\n*/\nfunction python() {\n    return new LanguageSupport(pythonLanguage);\n}\n\nexport { python, pythonLanguage };\n"],"mappings":"AAAA,SAASA,MAAT,QAAuB,eAAvB;AACA,SAASC,UAAT,EAAqBC,cAArB,EAAqCC,eAArC,EAAsDC,YAAtD,EAAoEC,UAApE,EAAgFC,eAAhF,QAAuG,sBAAvG;;AAEA,SAASC,UAAT,CAAoBC,OAApB,EAA6BC,IAA7B,EAAmC;EAC/B,IAAIC,IAAI,GAAGF,OAAO,CAACG,UAAR,CAAmBF,IAAI,CAACG,IAAxB,CAAX;EACA,IAAIC,IAAI,GAAGL,OAAO,CAACM,MAAR,CAAeN,OAAO,CAACO,GAAvB,EAA4B,CAAC,CAA7B,CAAX;EAAA,IAA4CC,EAAE,GAAGH,IAAI,CAACD,IAAL,GAAYC,IAAI,CAACI,IAAL,CAAUC,MAAvE,CAF+B,CAG/B;EACA;;EACA,IAAI,CAAC,KAAKC,IAAL,CAAUN,IAAI,CAACI,IAAf,CAAD,IACAT,OAAO,CAACC,IAAR,CAAaO,EAAb,GAAkBA,EAAE,GAAG,GADvB,IAEA,CAAC,KAAKG,IAAL,CAAUX,OAAO,CAACY,KAAR,CAAcC,QAAd,CAAuBL,EAAvB,EAA2BR,OAAO,CAACC,IAAR,CAAaO,EAAxC,CAAV,CAFD,IAGAR,OAAO,CAACG,UAAR,CAAmBH,OAAO,CAACO,GAA3B,EAAgC,CAAC,CAAjC,KAAuCL,IAH3C,EAII,OAAO,IAAP,CAT2B,CAU/B;EACA;EACA;;EACA,IAAI,qCAAqCS,IAArC,CAA0CX,OAAO,CAACc,SAAlD,KAAgEd,OAAO,CAACG,UAAR,CAAmBH,OAAO,CAACO,GAA3B,EAAgC,CAAC,CAAjC,IAAsCL,IAA1G,EACI,OAAO,IAAP;EACJ,OAAOA,IAAI,GAAGF,OAAO,CAACe,IAAtB;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,MAAMC,cAAc,GAAG,aAAavB,UAAU,CAACwB,MAAX,CAAkB;EAClDzB,MAAM,EAAE,aAAaA,MAAM,CAAC0B,SAAP,CAAiB;IAClCC,KAAK,EAAE,CACH,aAAazB,cAAc,CAAC0B,GAAf,CAAmB;MAC5BC,IAAI,EAAErB,OAAO,IAAI;QAAE,IAAIsB,EAAJ;;QAAQ,OAAO,CAACA,EAAE,GAAGvB,UAAU,CAACC,OAAD,EAAUA,OAAO,CAACC,IAAlB,CAAhB,MAA6C,IAA7C,IAAqDqB,EAAE,KAAK,KAAK,CAAjE,GAAqEA,EAArE,GAA0EtB,OAAO,CAACuB,QAAR,EAAjF;MAAsG,CADrG;MAE5BC,WAAW,EAAEC,EAAE,IAAI,oBAAoBd,IAApB,CAAyBc,EAAE,CAACX,SAA5B,IAAyCW,EAAE,CAACC,UAA5C,GAAyDD,EAAE,CAACF,QAAH,EAFhD;MAG5BI,YAAY,EAAEF,EAAE,IAAI,yBAAyBd,IAAzB,CAA8Bc,EAAE,CAACX,SAAjC,IAA8CW,EAAE,CAACC,UAAjD,GAA8DD,EAAE,CAACF,QAAH,EAHtD;MAI5B,qFAAqF,aAAa5B,eAAe,CAAC;QAAEiC,OAAO,EAAE;MAAX,CAAD,CAJrF;MAK5B,mGAAmG,aAAajC,eAAe,CAAC;QAAEiC,OAAO,EAAE;MAAX,CAAD,CALnG;MAM5B,gDAAgD,aAAajC,eAAe,CAAC;QAAEiC,OAAO,EAAE;MAAX,CAAD,CANhD;MAO5B,uBAAuB,MAAM,IAPD;MAQ5BC,MAAM,EAAE7B,OAAO,IAAI;QACf,IAAIA,OAAO,CAACO,GAAR,GAAc,MAAMuB,IAAN,CAAW9B,OAAO,CAACc,SAAnB,EAA8B,CAA9B,EAAiCJ,MAA/C,IAAyDV,OAAO,CAACC,IAAR,CAAaO,EAA1E,EAA8E;UAC1E,IAAIuB,OAAO,GAAG,IAAd;;UACA,KAAK,IAAIC,GAAG,GAAGhC,OAAO,CAACC,IAAlB,EAAwBO,EAAE,GAAGwB,GAAG,CAACxB,EAAtC,IAA4C;YACxCwB,GAAG,GAAGA,GAAG,CAACC,SAAV;YACA,IAAI,CAACD,GAAD,IAAQA,GAAG,CAACxB,EAAJ,IAAUA,EAAtB,EACI;YACJ,IAAIwB,GAAG,CAACE,IAAJ,CAASC,IAAT,IAAiB,MAArB,EACIJ,OAAO,GAAGC,GAAV;UACP;;UACD,IAAID,OAAJ,EAAa;YACT,IAAIK,UAAU,GAAGrC,UAAU,CAACC,OAAD,EAAU+B,OAAV,CAA3B;YACA,IAAIK,UAAU,IAAI,IAAlB,EACI,OAAOA,UAAP;UACP;QACJ;;QACD,OAAOpC,OAAO,CAACuB,QAAR,EAAP;MACH;IAzB2B,CAAnB,CADV,EA4BH,aAAa3B,YAAY,CAACwB,GAAb,CAAiB;MAC1B,sEAAsEvB,UAD5C;MAE1BwB,IAAI,EAAE,CAACpB,IAAD,EAAOW,KAAP,MAAkB;QAAER,IAAI,EAAEH,IAAI,CAACG,IAAL,GAAY,CAApB;QAAuBI,EAAE,EAAEP,IAAI,CAACO,EAAL,IAAWP,IAAI,CAACO,EAAL,IAAWI,KAAK,CAACyB,GAAN,CAAU3B,MAArB,GAA8B,CAA9B,GAAkC,CAA7C;MAA3B,CAAlB;IAFoB,CAAjB,CA5BV;EAD2B,CAAjB,CAD6B;EAoClD4B,YAAY,EAAE;IACVC,aAAa,EAAE;MAAEC,QAAQ,EAAE,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB,GAArB,EAA0B,KAA1B,EAAiC,KAAjC;IAAZ,CADL;IAEVC,aAAa,EAAE;MAAEpC,IAAI,EAAE;IAAR,CAFL;IAGVqC,aAAa,EAAE;EAHL;AApCoC,CAAlB,CAApC;AA0CA;AACA;AACA;;AACA,SAASC,MAAT,GAAkB;EACd,OAAO,IAAI7C,eAAJ,CAAoBkB,cAApB,CAAP;AACH;;AAED,SAAS2B,MAAT,EAAiB3B,cAAjB"},"metadata":{},"sourceType":"module"}