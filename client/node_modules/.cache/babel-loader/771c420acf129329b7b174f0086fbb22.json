{"ast":null,"code":"// @ts-nocheck\nzig.displayName = 'zig';\nzig.aliases = [];\n/** @type {import('../core.js').Syntax} */\n\nexport default function zig(Prism) {\n  ;\n\n  (function (Prism) {\n    function literal(str) {\n      return function () {\n        return str;\n      };\n    }\n\n    var keyword = /\\b(?:align|allowzero|and|anyframe|anytype|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|nosuspend|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\\b/;\n    var IDENTIFIER = '\\\\b(?!' + keyword.source + ')(?!\\\\d)\\\\w+\\\\b';\n    var ALIGN = /align\\s*\\((?:[^()]|\\([^()]*\\))*\\)/.source;\n    var PREFIX_TYPE_OP = /(?:\\?|\\bpromise->|(?:\\[[^[\\]]*\\]|\\*(?!\\*)|\\*\\*)(?:\\s*<ALIGN>|\\s*const\\b|\\s*volatile\\b|\\s*allowzero\\b)*)/.source.replace(/<ALIGN>/g, literal(ALIGN));\n    var SUFFIX_EXPR = /(?:\\bpromise\\b|(?:\\berror\\.)?<ID>(?:\\.<ID>)*(?!\\s+<ID>))/.source.replace(/<ID>/g, literal(IDENTIFIER));\n    var TYPE = '(?!\\\\s)(?:!?\\\\s*(?:' + PREFIX_TYPE_OP + '\\\\s*)*' + SUFFIX_EXPR + ')+';\n    /*\n     * A simplified grammar for Zig compile time type literals:\n     *\n     * TypeExpr = ( \"!\"? PREFIX_TYPE_OP* SUFFIX_EXPR )+\n     *\n     * SUFFIX_EXPR = ( \\b \"promise\" \\b | ( \\b \"error\" \".\" )? IDENTIFIER ( \".\" IDENTIFIER )* (?! \\s+ IDENTIFIER ) )\n     *\n     * PREFIX_TYPE_OP = \"?\"\n     *                | \\b \"promise\" \"->\"\n     *                | ( \"[\" [^\\[\\]]* \"]\" | \"*\" | \"**\" ) ( ALIGN | \"const\" \\b | \"volatile\" \\b | \"allowzero\" \\b )*\n     *\n     * ALIGN = \"align\" \"(\" ( [^()] | \"(\" [^()]* \")\" )* \")\"\n     *\n     * IDENTIFIER = \\b (?! KEYWORD ) [a-zA-Z_] \\w* \\b\n     *\n     */\n\n    Prism.languages.zig = {\n      comment: [{\n        pattern: /\\/\\/[/!].*/,\n        alias: 'doc-comment'\n      }, /\\/{2}.*/],\n      string: [{\n        // \"string\" and c\"string\"\n        pattern: /(^|[^\\\\@])c?\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"/,\n        lookbehind: true,\n        greedy: true\n      }, {\n        // multiline strings and c-strings\n        pattern: /([\\r\\n])([ \\t]+c?\\\\{2}).*(?:(?:\\r\\n?|\\n)\\2.*)*/,\n        lookbehind: true,\n        greedy: true\n      }],\n      char: {\n        // characters 'a', '\\n', '\\xFF', '\\u{10FFFF}'\n        pattern: /(^|[^\\\\])'(?:[^'\\\\\\r\\n]|[\\uD800-\\uDFFF]{2}|\\\\(?:.|x[a-fA-F\\d]{2}|u\\{[a-fA-F\\d]{1,6}\\}))'/,\n        lookbehind: true,\n        greedy: true\n      },\n      builtin: /\\B@(?!\\d)\\w+(?=\\s*\\()/,\n      label: {\n        pattern: /(\\b(?:break|continue)\\s*:\\s*)\\w+\\b|\\b(?!\\d)\\w+\\b(?=\\s*:\\s*(?:\\{|while\\b))/,\n        lookbehind: true\n      },\n      'class-name': [// const Foo = struct {};\n      /\\b(?!\\d)\\w+(?=\\s*=\\s*(?:(?:extern|packed)\\s+)?(?:enum|struct|union)\\s*[({])/, {\n        // const x: i32 = 9;\n        // var x: Bar;\n        // fn foo(x: bool, y: f32) void {}\n        pattern: RegExp(/(:\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?[=;,)])|<TYPE>(?=\\s*(?:<ALIGN>\\s*)?\\{)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))),\n        lookbehind: true,\n        inside: null // see below\n\n      }, {\n        // extern fn foo(x: f64) f64; (optional alignment)\n        pattern: RegExp(/(\\)\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?;)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))),\n        lookbehind: true,\n        inside: null // see below\n\n      }],\n      'builtin-type': {\n        pattern: /\\b(?:anyerror|bool|c_u?(?:int|long|longlong|short)|c_longdouble|c_void|comptime_(?:float|int)|f(?:16|32|64|128)|[iu](?:8|16|32|64|128|size)|noreturn|type|void)\\b/,\n        alias: 'keyword'\n      },\n      keyword: keyword,\n      function: /\\b(?!\\d)\\w+(?=\\s*\\()/,\n      number: /\\b(?:0b[01]+|0o[0-7]+|0x[a-fA-F\\d]+(?:\\.[a-fA-F\\d]*)?(?:[pP][+-]?[a-fA-F\\d]+)?|\\d+(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\b/,\n      boolean: /\\b(?:false|true)\\b/,\n      operator: /\\.[*?]|\\.{2,3}|[-=]>|\\*\\*|\\+\\+|\\|\\||(?:<<|>>|[-+*]%|[-+*/%^&|<>!=])=?|[?~]/,\n      punctuation: /[.:,;(){}[\\]]/\n    };\n    Prism.languages.zig['class-name'].forEach(function (obj) {\n      if (obj.inside === null) {\n        obj.inside = Prism.languages.zig;\n      }\n    });\n  })(Prism);\n}","map":{"version":3,"names":["zig","displayName","aliases","Prism","literal","str","keyword","IDENTIFIER","source","ALIGN","PREFIX_TYPE_OP","replace","SUFFIX_EXPR","TYPE","languages","comment","pattern","alias","string","lookbehind","greedy","char","builtin","label","RegExp","inside","function","number","boolean","operator","punctuation","forEach","obj"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/refractor/lang/zig.js"],"sourcesContent":["// @ts-nocheck\nzig.displayName = 'zig'\nzig.aliases = []\n\n/** @type {import('../core.js').Syntax} */\nexport default function zig(Prism) {\n  ;(function (Prism) {\n    function literal(str) {\n      return function () {\n        return str\n      }\n    }\n\n    var keyword =\n      /\\b(?:align|allowzero|and|anyframe|anytype|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|nosuspend|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\\b/\n    var IDENTIFIER = '\\\\b(?!' + keyword.source + ')(?!\\\\d)\\\\w+\\\\b'\n    var ALIGN = /align\\s*\\((?:[^()]|\\([^()]*\\))*\\)/.source\n    var PREFIX_TYPE_OP =\n      /(?:\\?|\\bpromise->|(?:\\[[^[\\]]*\\]|\\*(?!\\*)|\\*\\*)(?:\\s*<ALIGN>|\\s*const\\b|\\s*volatile\\b|\\s*allowzero\\b)*)/.source.replace(\n        /<ALIGN>/g,\n        literal(ALIGN)\n      )\n    var SUFFIX_EXPR =\n      /(?:\\bpromise\\b|(?:\\berror\\.)?<ID>(?:\\.<ID>)*(?!\\s+<ID>))/.source.replace(\n        /<ID>/g,\n        literal(IDENTIFIER)\n      )\n    var TYPE =\n      '(?!\\\\s)(?:!?\\\\s*(?:' + PREFIX_TYPE_OP + '\\\\s*)*' + SUFFIX_EXPR + ')+'\n    /*\n     * A simplified grammar for Zig compile time type literals:\n     *\n     * TypeExpr = ( \"!\"? PREFIX_TYPE_OP* SUFFIX_EXPR )+\n     *\n     * SUFFIX_EXPR = ( \\b \"promise\" \\b | ( \\b \"error\" \".\" )? IDENTIFIER ( \".\" IDENTIFIER )* (?! \\s+ IDENTIFIER ) )\n     *\n     * PREFIX_TYPE_OP = \"?\"\n     *                | \\b \"promise\" \"->\"\n     *                | ( \"[\" [^\\[\\]]* \"]\" | \"*\" | \"**\" ) ( ALIGN | \"const\" \\b | \"volatile\" \\b | \"allowzero\" \\b )*\n     *\n     * ALIGN = \"align\" \"(\" ( [^()] | \"(\" [^()]* \")\" )* \")\"\n     *\n     * IDENTIFIER = \\b (?! KEYWORD ) [a-zA-Z_] \\w* \\b\n     *\n     */\n\n    Prism.languages.zig = {\n      comment: [\n        {\n          pattern: /\\/\\/[/!].*/,\n          alias: 'doc-comment'\n        },\n        /\\/{2}.*/\n      ],\n      string: [\n        {\n          // \"string\" and c\"string\"\n          pattern: /(^|[^\\\\@])c?\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"/,\n          lookbehind: true,\n          greedy: true\n        },\n        {\n          // multiline strings and c-strings\n          pattern: /([\\r\\n])([ \\t]+c?\\\\{2}).*(?:(?:\\r\\n?|\\n)\\2.*)*/,\n          lookbehind: true,\n          greedy: true\n        }\n      ],\n      char: {\n        // characters 'a', '\\n', '\\xFF', '\\u{10FFFF}'\n        pattern:\n          /(^|[^\\\\])'(?:[^'\\\\\\r\\n]|[\\uD800-\\uDFFF]{2}|\\\\(?:.|x[a-fA-F\\d]{2}|u\\{[a-fA-F\\d]{1,6}\\}))'/,\n        lookbehind: true,\n        greedy: true\n      },\n      builtin: /\\B@(?!\\d)\\w+(?=\\s*\\()/,\n      label: {\n        pattern:\n          /(\\b(?:break|continue)\\s*:\\s*)\\w+\\b|\\b(?!\\d)\\w+\\b(?=\\s*:\\s*(?:\\{|while\\b))/,\n        lookbehind: true\n      },\n      'class-name': [\n        // const Foo = struct {};\n        /\\b(?!\\d)\\w+(?=\\s*=\\s*(?:(?:extern|packed)\\s+)?(?:enum|struct|union)\\s*[({])/,\n        {\n          // const x: i32 = 9;\n          // var x: Bar;\n          // fn foo(x: bool, y: f32) void {}\n          pattern: RegExp(\n            /(:\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?[=;,)])|<TYPE>(?=\\s*(?:<ALIGN>\\s*)?\\{)/.source\n              .replace(/<TYPE>/g, literal(TYPE))\n              .replace(/<ALIGN>/g, literal(ALIGN))\n          ),\n          lookbehind: true,\n          inside: null // see below\n        },\n        {\n          // extern fn foo(x: f64) f64; (optional alignment)\n          pattern: RegExp(\n            /(\\)\\s*)<TYPE>(?=\\s*(?:<ALIGN>\\s*)?;)/.source\n              .replace(/<TYPE>/g, literal(TYPE))\n              .replace(/<ALIGN>/g, literal(ALIGN))\n          ),\n          lookbehind: true,\n          inside: null // see below\n        }\n      ],\n      'builtin-type': {\n        pattern:\n          /\\b(?:anyerror|bool|c_u?(?:int|long|longlong|short)|c_longdouble|c_void|comptime_(?:float|int)|f(?:16|32|64|128)|[iu](?:8|16|32|64|128|size)|noreturn|type|void)\\b/,\n        alias: 'keyword'\n      },\n      keyword: keyword,\n      function: /\\b(?!\\d)\\w+(?=\\s*\\()/,\n      number:\n        /\\b(?:0b[01]+|0o[0-7]+|0x[a-fA-F\\d]+(?:\\.[a-fA-F\\d]*)?(?:[pP][+-]?[a-fA-F\\d]+)?|\\d+(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\b/,\n      boolean: /\\b(?:false|true)\\b/,\n      operator:\n        /\\.[*?]|\\.{2,3}|[-=]>|\\*\\*|\\+\\+|\\|\\||(?:<<|>>|[-+*]%|[-+*/%^&|<>!=])=?|[?~]/,\n      punctuation: /[.:,;(){}[\\]]/\n    }\n    Prism.languages.zig['class-name'].forEach(function (obj) {\n      if (obj.inside === null) {\n        obj.inside = Prism.languages.zig\n      }\n    })\n  })(Prism)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}