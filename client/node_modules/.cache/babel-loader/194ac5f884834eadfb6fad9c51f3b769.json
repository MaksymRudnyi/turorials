{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n */\n\n/**\n * @typedef {'left'|'center'|'right'|'none'} Align\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\n/** @type {Extension} */\n\nexport const gfmTable = {\n  flow: {\n    null: {\n      tokenize: tokenizeTable,\n      resolve: resolveTable\n    }\n  }\n};\nconst nextPrefixedOrBlank = {\n  tokenize: tokenizeNextPrefixedOrBlank,\n  partial: true\n};\n/** @type {Resolver} */\n\nfunction resolveTable(events, context) {\n  let index = -1;\n  /** @type {boolean|undefined} */\n\n  let inHead;\n  /** @type {boolean|undefined} */\n\n  let inDelimiterRow;\n  /** @type {boolean|undefined} */\n\n  let inRow;\n  /** @type {number|undefined} */\n\n  let contentStart;\n  /** @type {number|undefined} */\n\n  let contentEnd;\n  /** @type {number|undefined} */\n\n  let cellStart;\n  /** @type {boolean|undefined} */\n\n  let seenCellInRow;\n\n  while (++index < events.length) {\n    const token = events[index][1];\n\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index;\n        contentEnd = index;\n      }\n\n      if ( // Combine separate content parts into one.\n      (token.type === 'tableCellDivider' || token.type === 'tableRow') && contentEnd) {\n        const content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        };\n        /** @type {Token} */\n\n        const text = {\n          type: 'chunkText',\n          start: content.start,\n          end: content.end,\n          // @ts-expect-error It’s fine.\n          contentType: 'text'\n        };\n        events.splice(contentStart, contentEnd - contentStart + 1, ['enter', content, context], ['enter', text, context], ['exit', text, context], ['exit', content, context]);\n        index -= contentEnd - contentStart - 3;\n        contentStart = undefined;\n        contentEnd = undefined;\n      }\n    }\n\n    if (events[index][0] === 'exit' && cellStart !== undefined && cellStart + (seenCellInRow ? 0 : 1) < index && (token.type === 'tableCellDivider' || token.type === 'tableRow' && (cellStart + 3 < index || events[cellStart][1].type !== 'whitespace'))) {\n      const cell = {\n        type: inDelimiterRow ? 'tableDelimiter' : inHead ? 'tableHeader' : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      };\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, ['exit', cell, context]);\n      events.splice(cellStart, 0, ['enter', cell, context]);\n      index += 2;\n      cellStart = index + 1;\n      seenCellInRow = true;\n    }\n\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter';\n\n      if (inRow) {\n        cellStart = index + 1;\n        seenCellInRow = false;\n      }\n    }\n\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter';\n\n      if (inDelimiterRow) {\n        cellStart = index + 1;\n        seenCellInRow = false;\n      }\n    }\n\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter';\n    }\n  }\n\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeTable(effects, ok, nok) {\n  const self = this;\n  /** @type {Array<Align>} */\n\n  const align = [];\n  let tableHeaderCount = 0;\n  /** @type {boolean|undefined} */\n\n  let seenDelimiter;\n  /** @type {boolean|undefined} */\n\n  let hasDash;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    // @ts-expect-error Custom.\n    effects.enter('table')._align = align;\n    effects.enter('tableHead');\n    effects.enter('tableRow'); // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerHead(code);\n    }\n\n    tableHeaderCount++;\n    effects.enter('temporaryTableCellContent'); // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentHead(code);\n  }\n  /** @type {State} */\n\n\n  function cellDividerHead(code) {\n    effects.enter('tableCellDivider');\n    effects.consume(code);\n    effects.exit('tableCellDivider');\n    seenDelimiter = true;\n    return cellBreakHead;\n  }\n  /** @type {State} */\n\n\n  function cellBreakHead(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndHead(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceHead;\n    }\n\n    if (seenDelimiter) {\n      seenDelimiter = undefined;\n      tableHeaderCount++;\n    }\n\n    if (code === 124) {\n      return cellDividerHead(code);\n    } // Anything else is cell content.\n\n\n    effects.enter('temporaryTableCellContent');\n    return inCellContentHead(code);\n  }\n  /** @type {State} */\n\n\n  function inWhitespaceHead(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return inWhitespaceHead;\n    }\n\n    effects.exit('whitespace');\n    return cellBreakHead(code);\n  }\n  /** @type {State} */\n\n\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent');\n      return cellBreakHead(code);\n    }\n\n    effects.consume(code);\n    return code === 92 ? inCellContentEscapeHead : inCellContentHead;\n  }\n  /** @type {State} */\n\n\n  function inCellContentEscapeHead(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code);\n      return inCellContentHead;\n    } // Anything else.\n\n\n    return inCellContentHead(code);\n  }\n  /** @type {State} */\n\n\n  function atRowEndHead(code) {\n    if (code === null) {\n      return nok(code);\n    }\n\n    effects.exit('tableRow');\n    effects.exit('tableHead');\n    const originalInterrupt = self.interrupt;\n    self.interrupt = true;\n    return effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, function (code) {\n      self.interrupt = originalInterrupt;\n      effects.enter('tableDelimiterRow');\n      return atDelimiterRowBreak(code);\n    }, function (code) {\n      self.interrupt = originalInterrupt;\n      return nok(code);\n    })(code);\n  }\n  /** @type {State} */\n\n\n  function atDelimiterRowBreak(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    }\n\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller');\n      effects.consume(code);\n      hasDash = true;\n      align.push('none');\n      return inFillerDelimiter;\n    }\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment');\n      effects.consume(code);\n      effects.exit('tableDelimiterAlignment');\n      align.push('left');\n      return afterLeftAlignment;\n    } // If we start with a pipe, we open a cell marker.\n\n\n    if (code === 124) {\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider');\n      return atDelimiterRowBreak;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function inWhitespaceDelimiter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    }\n\n    effects.exit('whitespace');\n    return atDelimiterRowBreak(code);\n  }\n  /** @type {State} */\n\n\n  function inFillerDelimiter(code) {\n    if (code === 45) {\n      effects.consume(code);\n      return inFillerDelimiter;\n    }\n\n    effects.exit('tableDelimiterFiller');\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment');\n      effects.consume(code);\n      effects.exit('tableDelimiterAlignment');\n      align[align.length - 1] = align[align.length - 1] === 'left' ? 'center' : 'right';\n      return afterRightAlignment;\n    }\n\n    return atDelimiterRowBreak(code);\n  }\n  /** @type {State} */\n\n\n  function afterLeftAlignment(code) {\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller');\n      effects.consume(code);\n      hasDash = true;\n      return inFillerDelimiter;\n    } // Anything else is not ok.\n\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function afterRightAlignment(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    } // `|`\n\n\n    if (code === 124) {\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider');\n      return atDelimiterRowBreak;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow'); // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code);\n    }\n\n    if (code === null) {\n      return tableClose(code);\n    }\n\n    return effects.check(nextPrefixedOrBlank, tableClose, effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, factorySpace(effects, bodyStart, 'linePrefix', 4), tableClose))(code);\n  }\n  /** @type {State} */\n\n\n  function tableClose(code) {\n    effects.exit('table');\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function bodyStart(code) {\n    effects.enter('tableBody');\n    return rowStartBody(code);\n  }\n  /** @type {State} */\n\n\n  function rowStartBody(code) {\n    effects.enter('tableRow'); // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerBody(code);\n    }\n\n    effects.enter('temporaryTableCellContent'); // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentBody(code);\n  }\n  /** @type {State} */\n\n\n  function cellDividerBody(code) {\n    effects.enter('tableCellDivider');\n    effects.consume(code);\n    effects.exit('tableCellDivider');\n    return cellBreakBody;\n  }\n  /** @type {State} */\n\n\n  function cellBreakBody(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndBody(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceBody;\n    } // `|`\n\n\n    if (code === 124) {\n      return cellDividerBody(code);\n    } // Anything else is cell content.\n\n\n    effects.enter('temporaryTableCellContent');\n    return inCellContentBody(code);\n  }\n  /** @type {State} */\n\n\n  function inWhitespaceBody(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return inWhitespaceBody;\n    }\n\n    effects.exit('whitespace');\n    return cellBreakBody(code);\n  }\n  /** @type {State} */\n\n\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent');\n      return cellBreakBody(code);\n    }\n\n    effects.consume(code);\n    return code === 92 ? inCellContentEscapeBody : inCellContentBody;\n  }\n  /** @type {State} */\n\n\n  function inCellContentEscapeBody(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code);\n      return inCellContentBody;\n    } // Anything else.\n\n\n    return inCellContentBody(code);\n  }\n  /** @type {State} */\n\n\n  function atRowEndBody(code) {\n    effects.exit('tableRow');\n\n    if (code === null) {\n      return tableBodyClose(code);\n    }\n\n    return effects.check(nextPrefixedOrBlank, tableBodyClose, effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, factorySpace(effects, rowStartBody, 'linePrefix', 4), tableBodyClose))(code);\n  }\n  /** @type {State} */\n\n\n  function tableBodyClose(code) {\n    effects.exit('tableBody');\n    return tableClose(code);\n  }\n  /** @type {Tokenizer} */\n\n\n  function tokenizeRowEnd(effects, ok, nok) {\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return factorySpace(effects, prefixed, 'linePrefix');\n    }\n    /** @type {State} */\n\n\n    function prefixed(code) {\n      // Blank or interrupting line.\n      if (self.parser.lazy[self.now().line] || code === null || markdownLineEnding(code)) {\n        return nok(code);\n      }\n\n      const tail = self.events[self.events.length - 1]; // Indented code can interrupt delimiter and body rows.\n\n      if (!self.parser.constructs.disable.null.includes('codeIndented') && tail && tail[1].type === 'linePrefix' && tail[2].sliceSerialize(tail[1], true).length >= 4) {\n        return nok(code);\n      }\n\n      self._gfmTableDynamicInterruptHack = true;\n      return effects.check(self.parser.constructs.flow, function (code) {\n        self._gfmTableDynamicInterruptHack = false;\n        return nok(code);\n      }, function (code) {\n        self._gfmTableDynamicInterruptHack = false;\n        return ok(code);\n      })(code);\n    }\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  let size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    // This is a check, so we don’t care about tokens, but we open a bogus one\n    // so we’re valid.\n    effects.enter('check'); // EOL.\n\n    effects.consume(code);\n    return whitespace;\n  }\n  /** @type {State} */\n\n\n  function whitespace(code) {\n    if (code === -1 || code === 32) {\n      effects.consume(code);\n      size++;\n      return size === 4 ? ok : whitespace;\n    } // EOF or whitespace\n\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      return ok(code);\n    } // Anything else.\n\n\n    return nok(code);\n  }\n}","map":{"version":3,"names":["factorySpace","markdownLineEnding","markdownLineEndingOrSpace","markdownSpace","gfmTable","flow","null","tokenize","tokenizeTable","resolve","resolveTable","nextPrefixedOrBlank","tokenizeNextPrefixedOrBlank","partial","events","context","index","inHead","inDelimiterRow","inRow","contentStart","contentEnd","cellStart","seenCellInRow","length","token","type","content","start","end","text","contentType","splice","undefined","cell","effects","ok","nok","self","align","tableHeaderCount","seenDelimiter","hasDash","code","enter","_align","cellDividerHead","inCellContentHead","consume","exit","cellBreakHead","atRowEndHead","inWhitespaceHead","inCellContentEscapeHead","originalInterrupt","interrupt","attempt","tokenizeRowEnd","atDelimiterRowBreak","rowEndDelimiter","inWhitespaceDelimiter","push","inFillerDelimiter","afterLeftAlignment","afterRightAlignment","tableClose","check","bodyStart","rowStartBody","cellDividerBody","inCellContentBody","cellBreakBody","atRowEndBody","inWhitespaceBody","inCellContentEscapeBody","tableBodyClose","prefixed","parser","lazy","now","line","tail","constructs","disable","includes","sliceSerialize","_gfmTableDynamicInterruptHack","size","whitespace"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/micromark-extension-gfm-table/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n */\n\n/**\n * @typedef {'left'|'center'|'right'|'none'} Align\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\n\n/** @type {Extension} */\nexport const gfmTable = {\n  flow: {\n    null: {\n      tokenize: tokenizeTable,\n      resolve: resolveTable\n    }\n  }\n}\nconst nextPrefixedOrBlank = {\n  tokenize: tokenizeNextPrefixedOrBlank,\n  partial: true\n}\n/** @type {Resolver} */\n\nfunction resolveTable(events, context) {\n  let index = -1\n  /** @type {boolean|undefined} */\n\n  let inHead\n  /** @type {boolean|undefined} */\n\n  let inDelimiterRow\n  /** @type {boolean|undefined} */\n\n  let inRow\n  /** @type {number|undefined} */\n\n  let contentStart\n  /** @type {number|undefined} */\n\n  let contentEnd\n  /** @type {number|undefined} */\n\n  let cellStart\n  /** @type {boolean|undefined} */\n\n  let seenCellInRow\n\n  while (++index < events.length) {\n    const token = events[index][1]\n\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index\n        contentEnd = index\n      }\n\n      if (\n        // Combine separate content parts into one.\n        (token.type === 'tableCellDivider' || token.type === 'tableRow') &&\n        contentEnd\n      ) {\n        const content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        }\n        /** @type {Token} */\n\n        const text = {\n          type: 'chunkText',\n          start: content.start,\n          end: content.end,\n          // @ts-expect-error It’s fine.\n          contentType: 'text'\n        }\n        events.splice(\n          contentStart,\n          contentEnd - contentStart + 1,\n          ['enter', content, context],\n          ['enter', text, context],\n          ['exit', text, context],\n          ['exit', content, context]\n        )\n        index -= contentEnd - contentStart - 3\n        contentStart = undefined\n        contentEnd = undefined\n      }\n    }\n\n    if (\n      events[index][0] === 'exit' &&\n      cellStart !== undefined &&\n      cellStart + (seenCellInRow ? 0 : 1) < index &&\n      (token.type === 'tableCellDivider' ||\n        (token.type === 'tableRow' &&\n          (cellStart + 3 < index ||\n            events[cellStart][1].type !== 'whitespace')))\n    ) {\n      const cell = {\n        type: inDelimiterRow\n          ? 'tableDelimiter'\n          : inHead\n          ? 'tableHeader'\n          : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      }\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, [\n        'exit',\n        cell,\n        context\n      ])\n      events.splice(cellStart, 0, ['enter', cell, context])\n      index += 2\n      cellStart = index + 1\n      seenCellInRow = true\n    }\n\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter'\n\n      if (inRow) {\n        cellStart = index + 1\n        seenCellInRow = false\n      }\n    }\n\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter'\n\n      if (inDelimiterRow) {\n        cellStart = index + 1\n        seenCellInRow = false\n      }\n    }\n\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter'\n    }\n  }\n\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeTable(effects, ok, nok) {\n  const self = this\n  /** @type {Array<Align>} */\n\n  const align = []\n  let tableHeaderCount = 0\n  /** @type {boolean|undefined} */\n\n  let seenDelimiter\n  /** @type {boolean|undefined} */\n\n  let hasDash\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // @ts-expect-error Custom.\n    effects.enter('table')._align = align\n    effects.enter('tableHead')\n    effects.enter('tableRow') // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerHead(code)\n    }\n\n    tableHeaderCount++\n    effects.enter('temporaryTableCellContent') // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentHead(code)\n  }\n  /** @type {State} */\n\n  function cellDividerHead(code) {\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    seenDelimiter = true\n    return cellBreakHead\n  }\n  /** @type {State} */\n\n  function cellBreakHead(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndHead(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    if (seenDelimiter) {\n      seenDelimiter = undefined\n      tableHeaderCount++\n    }\n\n    if (code === 124) {\n      return cellDividerHead(code)\n    } // Anything else is cell content.\n\n    effects.enter('temporaryTableCellContent')\n    return inCellContentHead(code)\n  }\n  /** @type {State} */\n\n  function inWhitespaceHead(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    effects.exit('whitespace')\n    return cellBreakHead(code)\n  }\n  /** @type {State} */\n\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakHead(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? inCellContentEscapeHead : inCellContentHead\n  }\n  /** @type {State} */\n\n  function inCellContentEscapeHead(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentHead\n    } // Anything else.\n\n    return inCellContentHead(code)\n  }\n  /** @type {State} */\n\n  function atRowEndHead(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    effects.exit('tableRow')\n    effects.exit('tableHead')\n    const originalInterrupt = self.interrupt\n    self.interrupt = true\n    return effects.attempt(\n      {\n        tokenize: tokenizeRowEnd,\n        partial: true\n      },\n      function (code) {\n        self.interrupt = originalInterrupt\n        effects.enter('tableDelimiterRow')\n        return atDelimiterRowBreak(code)\n      },\n      function (code) {\n        self.interrupt = originalInterrupt\n        return nok(code)\n      }\n    )(code)\n  }\n  /** @type {State} */\n\n  function atDelimiterRowBreak(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      align.push('none')\n      return inFillerDelimiter\n    }\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n      align.push('left')\n      return afterLeftAlignment\n    } // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function inWhitespaceDelimiter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    effects.exit('whitespace')\n    return atDelimiterRowBreak(code)\n  }\n  /** @type {State} */\n\n  function inFillerDelimiter(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return inFillerDelimiter\n    }\n\n    effects.exit('tableDelimiterFiller')\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n      align[align.length - 1] =\n        align[align.length - 1] === 'left' ? 'center' : 'right'\n      return afterRightAlignment\n    }\n\n    return atDelimiterRowBreak(code)\n  }\n  /** @type {State} */\n\n  function afterLeftAlignment(code) {\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      return inFillerDelimiter\n    } // Anything else is not ok.\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function afterRightAlignment(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return rowEndDelimiter(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    } // `|`\n\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow') // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code)\n    }\n\n    if (code === null) {\n      return tableClose(code)\n    }\n\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableClose,\n      effects.attempt(\n        {\n          tokenize: tokenizeRowEnd,\n          partial: true\n        },\n        factorySpace(effects, bodyStart, 'linePrefix', 4),\n        tableClose\n      )\n    )(code)\n  }\n  /** @type {State} */\n\n  function tableClose(code) {\n    effects.exit('table')\n    return ok(code)\n  }\n  /** @type {State} */\n\n  function bodyStart(code) {\n    effects.enter('tableBody')\n    return rowStartBody(code)\n  }\n  /** @type {State} */\n\n  function rowStartBody(code) {\n    effects.enter('tableRow') // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerBody(code)\n    }\n\n    effects.enter('temporaryTableCellContent') // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentBody(code)\n  }\n  /** @type {State} */\n\n  function cellDividerBody(code) {\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    return cellBreakBody\n  }\n  /** @type {State} */\n\n  function cellBreakBody(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return atRowEndBody(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceBody\n    } // `|`\n\n    if (code === 124) {\n      return cellDividerBody(code)\n    } // Anything else is cell content.\n\n    effects.enter('temporaryTableCellContent')\n    return inCellContentBody(code)\n  }\n  /** @type {State} */\n\n  function inWhitespaceBody(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceBody\n    }\n\n    effects.exit('whitespace')\n    return cellBreakBody(code)\n  }\n  /** @type {State} */\n\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakBody(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? inCellContentEscapeBody : inCellContentBody\n  }\n  /** @type {State} */\n\n  function inCellContentEscapeBody(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentBody\n    } // Anything else.\n\n    return inCellContentBody(code)\n  }\n  /** @type {State} */\n\n  function atRowEndBody(code) {\n    effects.exit('tableRow')\n\n    if (code === null) {\n      return tableBodyClose(code)\n    }\n\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableBodyClose,\n      effects.attempt(\n        {\n          tokenize: tokenizeRowEnd,\n          partial: true\n        },\n        factorySpace(effects, rowStartBody, 'linePrefix', 4),\n        tableBodyClose\n      )\n    )(code)\n  }\n  /** @type {State} */\n\n  function tableBodyClose(code) {\n    effects.exit('tableBody')\n    return tableClose(code)\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeRowEnd(effects, ok, nok) {\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return factorySpace(effects, prefixed, 'linePrefix')\n    }\n    /** @type {State} */\n\n    function prefixed(code) {\n      // Blank or interrupting line.\n      if (\n        self.parser.lazy[self.now().line] ||\n        code === null ||\n        markdownLineEnding(code)\n      ) {\n        return nok(code)\n      }\n\n      const tail = self.events[self.events.length - 1] // Indented code can interrupt delimiter and body rows.\n\n      if (\n        !self.parser.constructs.disable.null.includes('codeIndented') &&\n        tail &&\n        tail[1].type === 'linePrefix' &&\n        tail[2].sliceSerialize(tail[1], true).length >= 4\n      ) {\n        return nok(code)\n      }\n\n      self._gfmTableDynamicInterruptHack = true\n      return effects.check(\n        self.parser.constructs.flow,\n        function (code) {\n          self._gfmTableDynamicInterruptHack = false\n          return nok(code)\n        },\n        function (code) {\n          self._gfmTableDynamicInterruptHack = false\n          return ok(code)\n        }\n      )(code)\n    }\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  let size = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // This is a check, so we don’t care about tokens, but we open a bogus one\n    // so we’re valid.\n    effects.enter('check') // EOL.\n\n    effects.consume(code)\n    return whitespace\n  }\n  /** @type {State} */\n\n  function whitespace(code) {\n    if (code === -1 || code === 32) {\n      effects.consume(code)\n      size++\n      return size === 4 ? ok : whitespace\n    } // EOF or whitespace\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      return ok(code)\n    } // Anything else.\n\n    return nok(code)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}