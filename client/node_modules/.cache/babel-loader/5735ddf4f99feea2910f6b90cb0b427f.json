{"ast":null,"code":"/**\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').HastNode} HastNode\n * @typedef {import('./types.js').ElementChild} ElementChild\n * @typedef {import('./types.js').Direction} Direction\n * @typedef {import('unist-util-visit/complex-types').Visitor<ElementChild>} Visitor\n */\nimport { direction } from 'direction';\nimport { isElement } from 'hast-util-is-element';\nimport { toString } from 'hast-util-to-string';\nimport { svg } from 'property-information';\nimport { visit, EXIT, SKIP } from 'unist-util-visit';\nimport { element } from './util.js';\n/**\n * @param {SelectState} state\n * @param {HastNode} node\n * @returns {() => void}\n */\n// eslint-disable-next-line complexity\n\nexport function enterState(state, node) {\n  const schema = state.schema;\n  const language = state.language;\n  const currentDirection = state.direction;\n  const editableOrEditingHost = state.editableOrEditingHost;\n  /** @type {Direction|undefined} */\n\n  let dirInferred;\n  /** @type {boolean|undefined} */\n\n  let found;\n\n  if (element(node) && node.properties) {\n    const lang = node.properties.xmlLang || node.properties.lang;\n    const type = node.properties.type || 'text';\n    const dir = dirProperty(node);\n\n    if (lang !== undefined && lang !== null) {\n      state.language = String(lang);\n      found = true;\n    }\n\n    if (schema && schema.space === 'html') {\n      if (node.properties.contentEditable === 'true') {\n        state.editableOrEditingHost = true;\n        found = true;\n      }\n\n      if (isElement(node, 'svg')) {\n        state.schema = svg;\n        found = true;\n      } // See: <https://html.spec.whatwg.org/#the-directionality>.\n      // Explicit `[dir=rtl]`.\n\n\n      if (dir === 'rtl') {\n        dirInferred = dir;\n      } else if ( // Explicit `[dir=ltr]`.\n      dir === 'ltr' || // HTML with an invalid or no `[dir]`.\n      dir !== 'auto' && isElement(node, 'html') || // `input[type=tel]` with an invalid or no `[dir]`.\n      dir !== 'auto' && isElement(node, 'input') && type === 'tel') {\n        dirInferred = 'ltr'; // `[dir=auto]` or `bdi` with an invalid or no `[dir]`.\n      } else if (dir === 'auto' || isElement(node, 'bdi')) {\n        if (isElement(node, 'textarea')) {\n          // Check contents of `<textarea>`.\n          dirInferred = dirBidi(toString(node));\n        } else if (isElement(node, 'input') && (type === 'email' || type === 'search' || type === 'tel' || type === 'text')) {\n          // Check value of `<input>`.\n          // @ts-expect-error something is `never` in types but this is needed.\n          dirInferred = node.properties.value ? // @ts-expect-error Assume string\n          dirBidi(node.properties.value) : 'ltr';\n        } else {\n          // Check text nodes in `node`.\n          visit(node, inferDirectionality);\n        }\n      }\n\n      if (dirInferred) {\n        state.direction = dirInferred;\n        found = true;\n      }\n    } // Turn off editing mode in non-HTML spaces.\n    else if (state.editableOrEditingHost) {\n      state.editableOrEditingHost = false;\n      found = true;\n    }\n  }\n\n  return found ? reset : noop;\n\n  function reset() {\n    state.schema = schema;\n    state.language = language;\n    state.direction = currentDirection;\n    state.editableOrEditingHost = editableOrEditingHost;\n  }\n  /** @type {Visitor} */\n\n\n  function inferDirectionality(child) {\n    if (child.type === 'text') {\n      dirInferred = dirBidi(child.value);\n      return dirInferred ? EXIT : null;\n    }\n\n    if (child !== node && (isElement(child, ['bdi', 'script', 'style', 'textare']) || dirProperty(child))) {\n      return SKIP;\n    }\n  }\n}\n/**\n * @param {string} value\n * @returns {Direction|undefined}\n */\n\nfunction dirBidi(value) {\n  const result = direction(value);\n  return result === 'neutral' ? undefined : result;\n}\n/**\n * @param {ElementChild} node\n * @returns {Direction|undefined}\n */\n\n\nfunction dirProperty(node) {\n  const value = element(node) && node.properties && typeof node.properties.dir === 'string' ? node.properties.dir.toLowerCase() : undefined;\n  return value === 'auto' || value === 'ltr' || value === 'rtl' ? value : undefined;\n}\n\nfunction noop() {}","map":{"version":3,"names":["direction","isElement","toString","svg","visit","EXIT","SKIP","element","enterState","state","node","schema","language","currentDirection","editableOrEditingHost","dirInferred","found","properties","lang","xmlLang","type","dir","dirProperty","undefined","String","space","contentEditable","dirBidi","value","inferDirectionality","reset","noop","child","result","toLowerCase"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/hast-util-select/lib/enter-state.js"],"sourcesContent":["/**\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').HastNode} HastNode\n * @typedef {import('./types.js').ElementChild} ElementChild\n * @typedef {import('./types.js').Direction} Direction\n * @typedef {import('unist-util-visit/complex-types').Visitor<ElementChild>} Visitor\n */\n\nimport {direction} from 'direction'\nimport {isElement} from 'hast-util-is-element'\nimport {toString} from 'hast-util-to-string'\nimport {svg} from 'property-information'\nimport {visit, EXIT, SKIP} from 'unist-util-visit'\nimport {element} from './util.js'\n\n/**\n * @param {SelectState} state\n * @param {HastNode} node\n * @returns {() => void}\n */\n// eslint-disable-next-line complexity\nexport function enterState(state, node) {\n  const schema = state.schema\n  const language = state.language\n  const currentDirection = state.direction\n  const editableOrEditingHost = state.editableOrEditingHost\n  /** @type {Direction|undefined} */\n  let dirInferred\n  /** @type {boolean|undefined} */\n  let found\n\n  if (element(node) && node.properties) {\n    const lang = node.properties.xmlLang || node.properties.lang\n    const type = node.properties.type || 'text'\n    const dir = dirProperty(node)\n\n    if (lang !== undefined && lang !== null) {\n      state.language = String(lang)\n      found = true\n    }\n\n    if (schema && schema.space === 'html') {\n      if (node.properties.contentEditable === 'true') {\n        state.editableOrEditingHost = true\n        found = true\n      }\n\n      if (isElement(node, 'svg')) {\n        state.schema = svg\n        found = true\n      }\n\n      // See: <https://html.spec.whatwg.org/#the-directionality>.\n      // Explicit `[dir=rtl]`.\n      if (dir === 'rtl') {\n        dirInferred = dir\n      } else if (\n        // Explicit `[dir=ltr]`.\n        dir === 'ltr' ||\n        // HTML with an invalid or no `[dir]`.\n        (dir !== 'auto' && isElement(node, 'html')) ||\n        // `input[type=tel]` with an invalid or no `[dir]`.\n        (dir !== 'auto' && isElement(node, 'input') && type === 'tel')\n      ) {\n        dirInferred = 'ltr'\n        // `[dir=auto]` or `bdi` with an invalid or no `[dir]`.\n      } else if (dir === 'auto' || isElement(node, 'bdi')) {\n        if (isElement(node, 'textarea')) {\n          // Check contents of `<textarea>`.\n          dirInferred = dirBidi(toString(node))\n        } else if (\n          isElement(node, 'input') &&\n          (type === 'email' ||\n            type === 'search' ||\n            type === 'tel' ||\n            type === 'text')\n        ) {\n          // Check value of `<input>`.\n          // @ts-expect-error something is `never` in types but this is needed.\n          dirInferred = node.properties.value\n            ? // @ts-expect-error Assume string\n              dirBidi(node.properties.value)\n            : 'ltr'\n        } else {\n          // Check text nodes in `node`.\n          visit(node, inferDirectionality)\n        }\n      }\n\n      if (dirInferred) {\n        state.direction = dirInferred\n        found = true\n      }\n    }\n    // Turn off editing mode in non-HTML spaces.\n    else if (state.editableOrEditingHost) {\n      state.editableOrEditingHost = false\n      found = true\n    }\n  }\n\n  return found ? reset : noop\n\n  function reset() {\n    state.schema = schema\n    state.language = language\n    state.direction = currentDirection\n    state.editableOrEditingHost = editableOrEditingHost\n  }\n\n  /** @type {Visitor} */\n  function inferDirectionality(child) {\n    if (child.type === 'text') {\n      dirInferred = dirBidi(child.value)\n      return dirInferred ? EXIT : null\n    }\n\n    if (\n      child !== node &&\n      (isElement(child, ['bdi', 'script', 'style', 'textare']) ||\n        dirProperty(child))\n    ) {\n      return SKIP\n    }\n  }\n}\n\n/**\n * @param {string} value\n * @returns {Direction|undefined}\n */\nfunction dirBidi(value) {\n  const result = direction(value)\n  return result === 'neutral' ? undefined : result\n}\n\n/**\n * @param {ElementChild} node\n * @returns {Direction|undefined}\n */\nfunction dirProperty(node) {\n  const value =\n    element(node) && node.properties && typeof node.properties.dir === 'string'\n      ? node.properties.dir.toLowerCase()\n      : undefined\n\n  return value === 'auto' || value === 'ltr' || value === 'rtl'\n    ? value\n    : undefined\n}\n\nfunction noop() {}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}