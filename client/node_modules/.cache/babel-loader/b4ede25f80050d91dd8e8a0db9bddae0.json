{"ast":null,"code":"// @ts-nocheck\nsml.displayName = 'sml';\nsml.aliases = ['smlnj'];\n/** @type {import('../core.js').Syntax} */\n\nexport default function sml(Prism) {\n  // https://smlfamily.github.io/sml97-defn.pdf\n  // https://people.mpi-sws.org/~rossberg/sml.html\n  ;\n\n  (function (Prism) {\n    var keywords = /\\b(?:abstype|and|andalso|as|case|datatype|do|else|end|eqtype|exception|fn|fun|functor|handle|if|in|include|infix|infixr|let|local|nonfix|of|op|open|orelse|raise|rec|sharing|sig|signature|struct|structure|then|type|val|where|while|with|withtype)\\b/i;\n    Prism.languages.sml = {\n      // allow one level of nesting\n      comment: /\\(\\*(?:[^*(]|\\*(?!\\))|\\((?!\\*)|\\(\\*(?:[^*(]|\\*(?!\\))|\\((?!\\*))*\\*\\))*\\*\\)/,\n      string: {\n        pattern: /#?\"(?:[^\"\\\\]|\\\\.)*\"/,\n        greedy: true\n      },\n      'class-name': [{\n        // This is only an approximation since the real grammar is context-free\n        //\n        // Why the main loop so complex?\n        // The main loop is approximately the same as /(?:\\s*(?:[*,]|->)\\s*<TERMINAL>)*/ which is, obviously, a lot\n        // simpler. The difference is that if a comma is the last iteration of the loop, then the terminal must be\n        // followed by a long identifier.\n        pattern: RegExp(/((?:^|[^:]):\\s*)<TERMINAL>(?:\\s*(?:(?:\\*|->)\\s*<TERMINAL>|,\\s*<TERMINAL>(?:(?=<NOT-LAST>)|(?!<NOT-LAST>)\\s+<LONG-ID>)))*/.source.replace(/<NOT-LAST>/g, function () {\n          return /\\s*(?:[*,]|->)/.source;\n        }).replace(/<TERMINAL>/g, function () {\n          return /(?:'[\\w']*|<LONG-ID>|\\((?:[^()]|\\([^()]*\\))*\\)|\\{(?:[^{}]|\\{[^{}]*\\})*\\})(?:\\s+<LONG-ID>)*/.source;\n        }).replace(/<LONG-ID>/g, function () {\n          return /(?!<KEYWORD>)[a-z\\d_][\\w'.]*/.source;\n        }).replace(/<KEYWORD>/g, function () {\n          return keywords.source;\n        }), 'i'),\n        lookbehind: true,\n        greedy: true,\n        inside: null // see below\n\n      }, {\n        pattern: /((?:^|[^\\w'])(?:datatype|exception|functor|signature|structure|type)\\s+)[a-z_][\\w'.]*/i,\n        lookbehind: true\n      }],\n      function: {\n        pattern: /((?:^|[^\\w'])fun\\s+)[a-z_][\\w'.]*/i,\n        lookbehind: true\n      },\n      keyword: keywords,\n      variable: {\n        pattern: /(^|[^\\w'])'[\\w']*/,\n        lookbehind: true\n      },\n      number: /~?\\b(?:\\d+(?:\\.\\d+)?(?:e~?\\d+)?|0x[\\da-f]+)\\b/i,\n      word: {\n        pattern: /\\b0w(?:\\d+|x[\\da-f]+)\\b/i,\n        alias: 'constant'\n      },\n      boolean: /\\b(?:false|true)\\b/i,\n      operator: /\\.\\.\\.|:[>=:]|=>?|->|[<>]=?|[!+\\-*/^#|@~]/,\n      punctuation: /[(){}\\[\\].:,;]/\n    };\n    Prism.languages.sml['class-name'][0].inside = Prism.languages.sml;\n    Prism.languages.smlnj = Prism.languages.sml;\n  })(Prism);\n}","map":{"version":3,"names":["sml","displayName","aliases","Prism","keywords","languages","comment","string","pattern","greedy","RegExp","source","replace","lookbehind","inside","function","keyword","variable","number","word","alias","boolean","operator","punctuation","smlnj"],"sources":["C:/Users/apinto2/Desktop/teswordtomd/12 setembro/UPLOAD 9/turorials/client/node_modules/refractor/lang/sml.js"],"sourcesContent":["// @ts-nocheck\nsml.displayName = 'sml'\nsml.aliases = ['smlnj']\n\n/** @type {import('../core.js').Syntax} */\nexport default function sml(Prism) {\n  // https://smlfamily.github.io/sml97-defn.pdf\n  // https://people.mpi-sws.org/~rossberg/sml.html\n  ;(function (Prism) {\n    var keywords =\n      /\\b(?:abstype|and|andalso|as|case|datatype|do|else|end|eqtype|exception|fn|fun|functor|handle|if|in|include|infix|infixr|let|local|nonfix|of|op|open|orelse|raise|rec|sharing|sig|signature|struct|structure|then|type|val|where|while|with|withtype)\\b/i\n    Prism.languages.sml = {\n      // allow one level of nesting\n      comment:\n        /\\(\\*(?:[^*(]|\\*(?!\\))|\\((?!\\*)|\\(\\*(?:[^*(]|\\*(?!\\))|\\((?!\\*))*\\*\\))*\\*\\)/,\n      string: {\n        pattern: /#?\"(?:[^\"\\\\]|\\\\.)*\"/,\n        greedy: true\n      },\n      'class-name': [\n        {\n          // This is only an approximation since the real grammar is context-free\n          //\n          // Why the main loop so complex?\n          // The main loop is approximately the same as /(?:\\s*(?:[*,]|->)\\s*<TERMINAL>)*/ which is, obviously, a lot\n          // simpler. The difference is that if a comma is the last iteration of the loop, then the terminal must be\n          // followed by a long identifier.\n          pattern: RegExp(\n            /((?:^|[^:]):\\s*)<TERMINAL>(?:\\s*(?:(?:\\*|->)\\s*<TERMINAL>|,\\s*<TERMINAL>(?:(?=<NOT-LAST>)|(?!<NOT-LAST>)\\s+<LONG-ID>)))*/.source\n              .replace(/<NOT-LAST>/g, function () {\n                return /\\s*(?:[*,]|->)/.source\n              })\n              .replace(/<TERMINAL>/g, function () {\n                return /(?:'[\\w']*|<LONG-ID>|\\((?:[^()]|\\([^()]*\\))*\\)|\\{(?:[^{}]|\\{[^{}]*\\})*\\})(?:\\s+<LONG-ID>)*/\n                  .source\n              })\n              .replace(/<LONG-ID>/g, function () {\n                return /(?!<KEYWORD>)[a-z\\d_][\\w'.]*/.source\n              })\n              .replace(/<KEYWORD>/g, function () {\n                return keywords.source\n              }),\n            'i'\n          ),\n          lookbehind: true,\n          greedy: true,\n          inside: null // see below\n        },\n        {\n          pattern:\n            /((?:^|[^\\w'])(?:datatype|exception|functor|signature|structure|type)\\s+)[a-z_][\\w'.]*/i,\n          lookbehind: true\n        }\n      ],\n      function: {\n        pattern: /((?:^|[^\\w'])fun\\s+)[a-z_][\\w'.]*/i,\n        lookbehind: true\n      },\n      keyword: keywords,\n      variable: {\n        pattern: /(^|[^\\w'])'[\\w']*/,\n        lookbehind: true\n      },\n      number: /~?\\b(?:\\d+(?:\\.\\d+)?(?:e~?\\d+)?|0x[\\da-f]+)\\b/i,\n      word: {\n        pattern: /\\b0w(?:\\d+|x[\\da-f]+)\\b/i,\n        alias: 'constant'\n      },\n      boolean: /\\b(?:false|true)\\b/i,\n      operator: /\\.\\.\\.|:[>=:]|=>?|->|[<>]=?|[!+\\-*/^#|@~]/,\n      punctuation: /[(){}\\[\\].:,;]/\n    }\n    Prism.languages.sml['class-name'][0].inside = Prism.languages.sml\n    Prism.languages.smlnj = Prism.languages.sml\n  })(Prism)\n}\n"],"mappings":"AAAA;AACAA,GAAG,CAACC,WAAJ,GAAkB,KAAlB;AACAD,GAAG,CAACE,OAAJ,GAAc,CAAC,OAAD,CAAd;AAEA;;AACA,eAAe,SAASF,GAAT,CAAaG,KAAb,EAAoB;EACjC;EACA;EACA;;EAAC,CAAC,UAAUA,KAAV,EAAiB;IACjB,IAAIC,QAAQ,GACV,yPADF;IAEAD,KAAK,CAACE,SAAN,CAAgBL,GAAhB,GAAsB;MACpB;MACAM,OAAO,EACL,2EAHkB;MAIpBC,MAAM,EAAE;QACNC,OAAO,EAAE,qBADH;QAENC,MAAM,EAAE;MAFF,CAJY;MAQpB,cAAc,CACZ;QACE;QACA;QACA;QACA;QACA;QACA;QACAD,OAAO,EAAEE,MAAM,CACb,2HAA2HC,MAA3H,CACGC,OADH,CACW,aADX,EAC0B,YAAY;UAClC,OAAO,iBAAiBD,MAAxB;QACD,CAHH,EAIGC,OAJH,CAIW,aAJX,EAI0B,YAAY;UAClC,OAAO,6FACJD,MADH;QAED,CAPH,EAQGC,OARH,CAQW,YARX,EAQyB,YAAY;UACjC,OAAO,+BAA+BD,MAAtC;QACD,CAVH,EAWGC,OAXH,CAWW,YAXX,EAWyB,YAAY;UACjC,OAAOR,QAAQ,CAACO,MAAhB;QACD,CAbH,CADa,EAeb,GAfa,CAPjB;QAwBEE,UAAU,EAAE,IAxBd;QAyBEJ,MAAM,EAAE,IAzBV;QA0BEK,MAAM,EAAE,IA1BV,CA0Be;;MA1Bf,CADY,EA6BZ;QACEN,OAAO,EACL,wFAFJ;QAGEK,UAAU,EAAE;MAHd,CA7BY,CARM;MA2CpBE,QAAQ,EAAE;QACRP,OAAO,EAAE,oCADD;QAERK,UAAU,EAAE;MAFJ,CA3CU;MA+CpBG,OAAO,EAAEZ,QA/CW;MAgDpBa,QAAQ,EAAE;QACRT,OAAO,EAAE,mBADD;QAERK,UAAU,EAAE;MAFJ,CAhDU;MAoDpBK,MAAM,EAAE,gDApDY;MAqDpBC,IAAI,EAAE;QACJX,OAAO,EAAE,0BADL;QAEJY,KAAK,EAAE;MAFH,CArDc;MAyDpBC,OAAO,EAAE,qBAzDW;MA0DpBC,QAAQ,EAAE,2CA1DU;MA2DpBC,WAAW,EAAE;IA3DO,CAAtB;IA6DApB,KAAK,CAACE,SAAN,CAAgBL,GAAhB,CAAoB,YAApB,EAAkC,CAAlC,EAAqCc,MAArC,GAA8CX,KAAK,CAACE,SAAN,CAAgBL,GAA9D;IACAG,KAAK,CAACE,SAAN,CAAgBmB,KAAhB,GAAwBrB,KAAK,CAACE,SAAN,CAAgBL,GAAxC;EACD,CAlEA,EAkEEG,KAlEF;AAmEF"},"metadata":{},"sourceType":"module"}